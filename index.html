<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://annen-stack.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="annen&#39;s blog">
<meta property="og:url" content="https://annen-stack.github.io/index.html">
<meta property="og:site_name" content="annen&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ah">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://annen-stack.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>annen's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">annen's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-python%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-python%E7%89%88/" class="post-title-link" itemprop="url">数据结构与算法 python版</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-24 15:47:27 / 修改时间：15:48:55" itemprop="dateCreated datePublished" datetime="2020-02-24T15:47:27+08:00">2020-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念"></a>引入概念</h2><h3 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">start_time&#x3D;time.time()</span><br><span class="line"></span><br><span class="line">for a in range(0,1001):</span><br><span class="line">   for b in range(0,1001):</span><br><span class="line">       for c in range(0,1001):</span><br><span class="line">          if a**2+b**2&#x3D;&#x3D;c**2 and a+b+c&#x3D;&#x3D;1000:</span><br><span class="line">             print(&quot;a,b,c: %d,%d,%d&quot;%(a,b,c))</span><br><span class="line">end_time &#x3D; time.time()</span><br><span class="line">print(&quot;elapsed: %f&quot; % (end_time - start_time))</span><br><span class="line">print(&quot;complete!&quot;)</span><br></pre></td></tr></table></figure>
<p>第二次尝试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">start_time&#x3D;time.time()</span><br><span class="line">for a in range(0,1001):</span><br><span class="line">    for b in range(0,1001-a):</span><br><span class="line">        c&#x3D;1001-a-b</span><br><span class="line">        if a**2+b**2&#x3D;&#x3D;c**2:</span><br><span class="line">           print(&quot;a,b,c:%d,%d,%d&quot;%(a,b,c))</span><br></pre></td></tr></table></figure>
<h3 id="算法效率的衡量"><a href="#算法效率的衡量" class="headerlink" title="算法效率的衡量"></a>算法效率的衡量</h3><h4 id="执行时间反应算法效率"><a href="#执行时间反应算法效率" class="headerlink" title="执行时间反应算法效率"></a>执行时间反应算法效率</h4><p>对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。</p>
<h4 id="单靠时间值绝对可信吗？"><a href="#单靠时间值绝对可信吗？" class="headerlink" title="单靠时间值绝对可信吗？"></a>单靠时间值绝对可信吗？</h4><p>单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！</p>
<p>程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？</p>
<h4 id="时间复杂度与“大O记法”"><a href="#时间复杂度与“大O记法”" class="headerlink" title="时间复杂度与“大O记法”"></a>时间复杂度与“大O记法”</h4><p>我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。</p>
<p>对于算法的时间效率，我们可以用“大O记法”来表示。</p>
<p><strong>“大O记法”</strong>：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。</p>
<p><strong>时间复杂度</strong>：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)</p>
<h4 id="如何理解“大o记法”"><a href="#如何理解“大o记法”" class="headerlink" title="如何理解“大o记法”"></a>如何理解“大o记法”</h4><p>对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为3n2和100n2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为n2级。</p>
<h4 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h4><p>分析算法时，存在几种可能的考虑：</p>
<p>算法完成工作最少需要多少基本操作，即最优时间复杂度</p>
<p>算法完成工作最多需要多少基本操作，即最坏时间复杂度</p>
<p>算法完成工作平均需要多少基本操作，即平均时间复杂度</p>
<p>对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。</p>
<p>对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。</p>
<p>对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。</p>
<p>因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。</p>
<h4 id="时间复杂度的几种计算规则"><a href="#时间复杂度的几种计算规则" class="headerlink" title="时间复杂度的几种计算规则"></a>时间复杂度的几种计算规则</h4><ol>
<li>基本操作，即只有常数项，认为其时间复杂度为O(1)</li>
<li>顺序结构，时间复杂度按加法进行计算</li>
<li>循环结构，时间复杂度按乘法进行计算</li>
<li>分支结构，时间复杂度取最大值</li>
</ol>
<p>判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略<br>在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度</p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p><img src="67B1959ECF734D55921F2EE6816B1410" alt="image"></p>
<h3 id="python内置类型性能分析"><a href="#python内置类型性能分析" class="headerlink" title="python内置类型性能分析"></a>python内置类型性能分析</h3><h4 id="list内置操作的时间复杂度"><a href="#list内置操作的时间复杂度" class="headerlink" title="list内置操作的时间复杂度"></a>list内置操作的时间复杂度</h4><p><img src="B61236D5B4BC4D1F89A8EF3021E7DEEB" alt="image"></p>
<h4 id="dict内置操作的时间复杂度"><a href="#dict内置操作的时间复杂度" class="headerlink" title="dict内置操作的时间复杂度"></a>dict内置操作的时间复杂度</h4><p><img src="B56DF53655FA4E3B97DC656972120824" alt="image"></p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。</p>
<p>对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。</p>
<p>这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。</p>
<p>根据线性表的实际存储方式，分为两种实现模型：</p>
<ul>
<li>顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。</li>
<li>链表，将元素存放在通过链接构造起来的一系列存储块中。<h3 id="顺序表的形式"><a href="#顺序表的形式" class="headerlink" title="顺序表的形式"></a>顺序表的形式</h3><img src="BA8AB7366BDF43DCB93A0D56E330DC07" alt="image"></li>
</ul>
<p>图a表示的是顺序表的基本形式，数据元素本身<strong>连续存储</strong>，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的<strong>物理地址</strong>（实际内存地址）可以通过存储区的<strong>起始地址</strong>Loc (e0)加<strong>上逻辑地址</strong>（第i个元素）与<strong>存储单元大小</strong>（c）的乘积计算而得，即：</p>
<ul>
<li>Loc(ei) = Loc(e0) + c*i</li>
</ul>
<p>故<strong>访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)</strong>。</p>
<p>如果<strong>元素的大小不统一</strong>，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的<strong>地址信息（即链接）</strong>。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是<strong>存储一个链接地址所需的存储量</strong>，这个量通常很小。</p>
<p>图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p>
<h3 id="顺序表的结构与实现"><a href="#顺序表的结构与实现" class="headerlink" title="顺序表的结构与实现"></a>顺序表的结构与实现</h3><h4 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构"></a>顺序表的结构</h4><p><img src="3E8F3C0A49CC4A28967F9F74F6F3A1F6" alt="image"></p>
<p>一个顺序表的完整信息包括两部分，一部分是<strong>表中的元素集</strong>合，另一部分是为<strong>实现正确操作而需记录的信息</strong>，即有关表的整体情况的信息，这部分信息主要包括元素<strong>存储区的容量和当前表中已有的元素个数两项</strong>。</p>
<h4 id="顺序表的两种基本实现方式"><a href="#顺序表的两种基本实现方式" class="headerlink" title="顺序表的两种基本实现方式"></a>顺序表的两种基本实现方式</h4><p><img src="3B2F4478823F49CE9A44AE74B8808262" alt="image"></p>
<p>图a<strong>为一体式结构</strong>，<strong>存储表信息的单元与元素存储区</strong>以<strong>连续</strong>的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。</p>
<p>一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，<strong>元素存储区就固定了</strong>。</p>
<p>图b为<strong>分离式结构</strong>，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在<strong>另一个独立的元素存储区里</strong>，通过<strong>链接与基本表对象关联</strong>。</p>
<h4 id="元素存储区替换"><a href="#元素存储区替换" class="headerlink" title="元素存储区替换"></a>元素存储区替换</h4><p><strong>一体式结构</strong>由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能<strong>整体搬迁</strong>，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。</p>
<p><strong>分离式结构</strong>若想更换数据区，只需将表信息区中的<strong>数据区链接地址更新</strong>即可，而该顺序表对象不变。</p>
<h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3><h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><p><img src="3FC12CB512D1483D89537EA9B62A50B6" alt="image"><br>a. 尾端加入元素，时间复杂度为O(1)</p>
<p>b. 非保序的加入元素（不常见），时间复杂度为O(1)</p>
<p>c. 保序的元素加入，时间复杂度为O(n)</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="8E59F6AFFCC04EF68B03CC7FAB477098" alt="image"><br>a. 删除表尾元素，时间复杂度为O(1)</p>
<p>b. 非保序的元素删除（不常见），时间复杂度为O(1)</p>
<p>c. 保序的元素删除，时间复杂度为O(n)</p>
<h3 id="python中的数据表"><a href="#python中的数据表" class="headerlink" title="python中的数据表"></a>python中的数据表</h3><p>Python中的<strong>list和tuple两种类型采用了顺序表</strong>的实现技术，具有前面讨论的顺序表的所有性质。</p>
<p>tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。</p>
<h4 id="list的基本实现方式"><a href="#list的基本实现方式" class="headerlink" title="list的基本实现方式"></a>list的基本实现方式</h4><p>Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征：</p>
<ul>
<li>基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；</li>
</ul>
<p>为满足该特征，应该采用顺序表技术，<strong>表中元素保存在一块连续的存储区中。</strong></p>
<ul>
<li>允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。</li>
</ul>
<p>为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，<strong>只能采用分离式实现技术。</strong></p>
<p>在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x)（或list.insert(len(list),x)，即尾部插入）比在指定位置插入元素效率高的原因。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>顺序表</strong>的构建需要预先知道<strong>数据大小来申请连续的存储空间</strong>，而在<strong>进行扩充时又需要进行数据的搬迁</strong>，所以使用起来并不是很灵活。</p>
<p><strong>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。</strong></p>
<blockquote>
<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。</p>
</blockquote>
<h3 id="单项链表"><a href="#单项链表" class="headerlink" title="单项链表"></a>单项链表</h3><p>单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，<strong>一个信息域（元素域）和一个链接域</strong>。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。<br><img src="FF030ABBFED34856A1E1B6F7A554658B" alt="image"></p>
<ul>
<li>表元素域elem用来存放具体的数据。</li>
<li>链接域next用来存放下一个节点的位置（python中的标识）</li>
<li>变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。<h4 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SingleNode(object):</span><br><span class="line">   &quot;&quot;&quot;单链表的节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self,item):</span><br><span class="line">       self.item&#x3D;item</span><br><span class="line">       self.next&#x3D;None</span><br></pre></td></tr></table></figure>
<h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><ul>
<li>is_empty() 链表是否为空</li>
<li>length() 链表长度</li>
<li>travel() 遍历整个链表</li>
<li>add(item) 链表头部添加元素</li>
<li>append(item) 链表尾部添加元素</li>
<li>insert(pos, item) 指定位置添加元素</li>
<li>remove(item) 删除节点</li>
<li>search(item) 查找节点是否存在<h4 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class SingleLinkList(object):</span><br><span class="line">    &quot;&quot;&quot;单链表&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">       self._head&#x3D;None</span><br><span class="line">    def if_empty(self):</span><br><span class="line">       return self._head&#x3D;&#x3D;None</span><br><span class="line">    def length(self):</span><br><span class="line">       cur&#x3D;self._head</span><br><span class="line">       count&#x3D;0</span><br><span class="line">       while cur!&#x3D;None:</span><br><span class="line">          count +&#x3D; 1</span><br><span class="line">          cur&#x3D;cur.next</span><br><span class="line">       return count</span><br><span class="line">    def travel(self):</span><br><span class="line">       &quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span><br><span class="line">       cur&#x3D;self._head</span><br><span class="line">       while cur!&#x3D;None:</span><br><span class="line">          print (cur.item)</span><br><span class="line">          cur&#x3D;cur.next</span><br><span class="line">       print &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>头部添加元素<br><img src="2ACF3B2DFBDB4F69842BE8308DC922A5" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def add(self,item):</span><br><span class="line">   node&#x3D;SingleNoe(item)</span><br><span class="line">   node.next&#x3D;self._head</span><br><span class="line">   self._head&#x3D;node</span><br></pre></td></tr></table></figure>
<p>尾部添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def append(self,item):</span><br><span class="line">    #创建节点</span><br><span class="line">    node&#x3D;SingleNode(item)</span><br><span class="line">    #判断链表是否为空</span><br><span class="line">    if self.is_empty():</span><br><span class="line">      self._head&#x3D;node</span><br><span class="line">    else:</span><br><span class="line">      cur&#x3D;self._head</span><br><span class="line">      while cur.next!&#x3D;None:</span><br><span class="line">         cur&#x3D;cur.next</span><br><span class="line">      cur.next&#x3D;node</span><br></pre></td></tr></table></figure>
<p>指定位置添加元素<br><img src="44393C63AE554F5794EC67531DA47080" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def insert(self,pos,item):</span><br><span class="line">    #若指定位置pos为第一个元素之前，则执行头部插入</span><br><span class="line">    if pos&lt;&#x3D;0:</span><br><span class="line">      self.add(item)</span><br><span class="line">    #若指定位置超过链表尾部，这执行尾部插入</span><br><span class="line">    elif pos&gt;(self.length()-1):</span><br><span class="line">      self.append(item)</span><br><span class="line">    else:</span><br><span class="line">      node&#x3D;SingleNode(item)</span><br><span class="line">      count&#x3D;0</span><br><span class="line">      pre&#x3D;self._head</span><br><span class="line">      while count&lt;(pos-1):</span><br><span class="line">         count+&#x3D;1</span><br><span class="line">         pre&#x3D;pre.next</span><br><span class="line">     #pre的位置为pos-1</span><br><span class="line">     node.next&#x3D;pre.next</span><br><span class="line">     pre.next&#x3D;node</span><br></pre></td></tr></table></figure>
<p>删除节点<br><img src="B3615493E19140F1BBD47D40CC576A37" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def remove(self,item):</span><br><span class="line">   cur&#x3D;self._head</span><br><span class="line">   pre&#x3D;None</span><br><span class="line">   while cur !&#x3D;None:</span><br><span class="line">    if cur.item&#x3D;&#x3D;item:</span><br><span class="line">         #如果第一个就是删除的节点</span><br><span class="line">         if not pre：</span><br><span class="line">              self._head&#x3D;cur.next</span><br><span class="line">         else:</span><br><span class="line">              pre.next&#x3D;cur.next</span><br><span class="line">         break</span><br><span class="line">    else:</span><br><span class="line">         pre&#x3D;cur</span><br><span class="line">         cur&#x3D;cur.next</span><br></pre></td></tr></table></figure>

<p>查找节点是否存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def search(self.item):</span><br><span class="line">   cur&#x3D;self._head</span><br><span class="line">   while cur!&#x3D;None:</span><br><span class="line">      if cur.item&#x3D;&#x3D;item:</span><br><span class="line">         return True</span><br><span class="line">      cur&#x3D;cur.next</span><br><span class="line">   return False</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ll &#x3D; SingleLinkList()</span><br><span class="line">    ll.add(1)</span><br><span class="line">    ll.add(2)</span><br><span class="line">    ll.append(3)</span><br><span class="line">    ll.insert(2, 4)</span><br><span class="line">    print &quot;length:&quot;,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    print ll.search(3)</span><br><span class="line">    print ll.search(5)</span><br><span class="line">    ll.remove(1)</span><br><span class="line">    print &quot;length:&quot;,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingleNode(object):</span><br><span class="line">    &quot;&quot;&quot;节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.item &#x3D; item</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingleLinkList(object):</span><br><span class="line">    &quot;&quot;&quot;单链表&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, node&#x3D;None):</span><br><span class="line">        self._head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;</span><br><span class="line">        return self._head &#x3D;&#x3D; None</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;链表长度&quot;&quot;&quot;</span><br><span class="line">        # cur游标，用来移动遍历节点</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        # count记录数量</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            print(cur.item)</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;头部添加元素&quot;&quot;&quot;</span><br><span class="line">        # 先创建一个保存item值的节点</span><br><span class="line">        node &#x3D; SingleNode(item)</span><br><span class="line">        # 将新节点的链接域next指向头节点，即_head指向的位置</span><br><span class="line">        node.next &#x3D; self._head</span><br><span class="line">        # 将链表的头_head指向新节点</span><br><span class="line">        self._head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def append(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; SingleNode(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head &#x3D; node</span><br><span class="line">        else:</span><br><span class="line">            cur &#x3D; self._head</span><br><span class="line">            while cur.next !&#x3D; None:</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line">            cur.next &#x3D; node</span><br><span class="line"></span><br><span class="line">    def insert(self, pos, item):</span><br><span class="line">        &quot;&quot;&quot;指定位置添加元素&quot;&quot;&quot;</span><br><span class="line">        # 若指定位置pos为第一个元素之前，则执行头部插入</span><br><span class="line">        if pos &lt;&#x3D; 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">        # 若指定位置超过链表尾部，则执行尾部插入</span><br><span class="line">        elif pos &gt; (self.length()-1):</span><br><span class="line">            self.append(item)</span><br><span class="line">        # 找到指定位置</span><br><span class="line">        else:</span><br><span class="line">            node &#x3D; SingleNode(item)</span><br><span class="line">            count &#x3D; 0</span><br><span class="line">            # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置</span><br><span class="line">            pre &#x3D; self._head</span><br><span class="line">            while count &lt; (pos-1):</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">                pre &#x3D; pre.next</span><br><span class="line">            # 先将新节点node的next指向插入位置的节点</span><br><span class="line">            node.next &#x3D; pre.next</span><br><span class="line">            # 将插入位置的前一个节点的next指向新节点</span><br><span class="line">            pre.next &#x3D; node</span><br><span class="line"></span><br><span class="line">    def remove(self,item):</span><br><span class="line">        &quot;&quot;&quot;删除节点&quot;&quot;&quot;</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        pre &#x3D; None</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            # 找到了指定元素</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                # 如果第一个就是删除的节点</span><br><span class="line">                if not pre:</span><br><span class="line">                    # 将头指针指向头节点的后一个节点</span><br><span class="line">                    self._head &#x3D; cur.next</span><br><span class="line">                else:</span><br><span class="line">                    # 将删除位置前一个节点的next指向删除位置的后一个节点</span><br><span class="line">                    pre.next &#x3D; cur.next</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                # 继续按链表后移节点</span><br><span class="line">                pre &#x3D; cur</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line"></span><br><span class="line">    def search(self,item):</span><br><span class="line">        &quot;&quot;&quot;链表查找节点是否存在，并返回True或者False&quot;&quot;&quot;</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                return True</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ll &#x3D; SingleLinkList()</span><br><span class="line">    ll.add(1)</span><br><span class="line">    ll.add(2)</span><br><span class="line">    ll.append(3)# 2 1 3</span><br><span class="line">    ll.insert(2, 4) # 2 1 4 3</span><br><span class="line">    print (&quot;length:&quot;,ll.length())</span><br><span class="line">    ll.travel()#将链表打印</span><br><span class="line">    print (ll.search(3))</span><br><span class="line">    print (ll.search(5))</span><br><span class="line">    ll.remove(1)</span><br><span class="line">    print (&quot;length:&quot;,ll.length())</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h4 id="链表与顺序表对比"><a href="#链表与顺序表对比" class="headerlink" title="链表与顺序表对比"></a>链表与顺序表对比</h4><p>链表失去了<strong>顺序表随机读取</strong>的优点，同时链表由于增加了结点的指针域，<strong>空间开销比较</strong>大，但对<strong>存储空间的使用要相对灵活</strong>。</p>
<p><img src="A2CA74E030F645B6890286A8C14A5150" alt="image"></p>
<p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是<strong>遍历查找</strong>（即从Head开始查找），删除和插入操作本身的复杂度是O(1),但是搜索插入和删除的位置需要从head开始即遍历查找，O(n)。</p>
<p>顺序表查找很快（位置可以计算出来，固定，不需要遍历查找），主要耗时的操作是<strong>拷贝覆盖</strong>。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的<strong>所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行</strong>。</p>
<h3 id="单项循环链表"><a href="#单项循环链表" class="headerlink" title="单项循环链表"></a>单项循环链表</h3><p>单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。<br><img src="725EFAEE58904D11B3A3C0139B1287EA" alt="image"></p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li>is_empty() 判断链表是否为空</li>
<li>length() 返回链表的长度</li>
<li>travel() 遍历</li>
<li>add(item) 在头部添加一个节点</li>
<li>append(item) 在尾部添加一个节点</li>
<li>insert(pos, item) 在指定位置pos添加节点</li>
<li>remove(item) 删除一个节点</li>
<li>search(item) 查找节点是否存在<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    &quot;&quot;&quot;节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.item &#x3D; item</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SinCycLinkedlist(object):</span><br><span class="line">    &quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._head &#x3D; None</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span><br><span class="line">        return self._head &#x3D;&#x3D; None</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span><br><span class="line">        # 如果链表为空，返回长度0</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return 0</span><br><span class="line">        count &#x3D; 1</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        while cur.next !&#x3D; self._head:</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        print cur.item,</span><br><span class="line">        while cur.next !&#x3D; self._head:</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">            print cur.item,</span><br><span class="line">        print &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;头部添加节点&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head &#x3D; node</span><br><span class="line">            node.next &#x3D; self._head</span><br><span class="line">        else:</span><br><span class="line">            #添加的节点指向_head</span><br><span class="line">            node.next &#x3D; self._head</span><br><span class="line">            # 移到链表尾部，将尾部节点的next指向node</span><br><span class="line">            cur &#x3D; self._head</span><br><span class="line">            while cur.next !&#x3D; self._head:</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line">            cur.next &#x3D; node</span><br><span class="line">            #_head指向添加node的</span><br><span class="line">            self._head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def append(self, item):</span><br><span class="line">        &quot;&quot;&quot;尾部添加节点&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head &#x3D; node</span><br><span class="line">            node.next &#x3D; self._head</span><br><span class="line">        else:</span><br><span class="line">            # 移到链表尾部</span><br><span class="line">            cur &#x3D; self._head</span><br><span class="line">            while cur.next !&#x3D; self._head:</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line">            # 将尾节点指向node</span><br><span class="line">            cur.next &#x3D; node</span><br><span class="line">            # 将node指向头节点_head</span><br><span class="line">            node.next &#x3D; self._head</span><br><span class="line"></span><br><span class="line">    def insert(self, pos, item):</span><br><span class="line">        &quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span><br><span class="line">        if pos &lt;&#x3D; 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">        elif pos &gt; (self.length()-1):</span><br><span class="line">            self.append(item)</span><br><span class="line">        else:</span><br><span class="line">            node &#x3D; Node(item)</span><br><span class="line">            cur &#x3D; self._head</span><br><span class="line">            count &#x3D; 0</span><br><span class="line">            # 移动到指定位置的前一个位置</span><br><span class="line">            while count &lt; (pos-1):</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line">            node.next &#x3D; cur.next</span><br><span class="line">            cur.next &#x3D; node</span><br><span class="line"></span><br><span class="line">    def remove(self, item):</span><br><span class="line">        &quot;&quot;&quot;删除一个节点&quot;&quot;&quot;</span><br><span class="line">        # 若链表为空，则直接返回</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return</span><br><span class="line">        # 将cur指向头节点</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        pre &#x3D; None</span><br><span class="line">        # 若头节点的元素就是要查找的元素item</span><br><span class="line">        if cur.item &#x3D;&#x3D; item:</span><br><span class="line">            # 如果链表不止一个节点</span><br><span class="line">            if cur.next !&#x3D; self._head:</span><br><span class="line">                # 先找到尾节点，将尾节点的next指向第二个节点</span><br><span class="line">                while cur.next !&#x3D; self._head:</span><br><span class="line">                    cur &#x3D; cur.next</span><br><span class="line">                # cur指向了尾节点</span><br><span class="line">                cur.next &#x3D; self._head.next</span><br><span class="line">                self._head &#x3D; self._head.next</span><br><span class="line">            else:</span><br><span class="line">                # 链表只有一个节点</span><br><span class="line">                self._head &#x3D; None</span><br><span class="line">        else:</span><br><span class="line">            pre &#x3D; self._head</span><br><span class="line">            # 第一个节点不是要删除的</span><br><span class="line">            while cur.next !&#x3D; self._head:</span><br><span class="line">                # 找到了要删除的元素</span><br><span class="line">                if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                    # 删除</span><br><span class="line">                    pre.next &#x3D; cur.next</span><br><span class="line">                    return</span><br><span class="line">                else:</span><br><span class="line">                    pre &#x3D; cur</span><br><span class="line">                    cur &#x3D; cur.next</span><br><span class="line">            # cur 指向尾节点</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                # 尾部删除</span><br><span class="line">                pre.next &#x3D; cur.next</span><br><span class="line"></span><br><span class="line">    def search(self, item):</span><br><span class="line">        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return False</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        if cur.item &#x3D;&#x3D; item:</span><br><span class="line">            return True</span><br><span class="line">        while cur.next !&#x3D; self._head:</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ll &#x3D; SinCycLinkedlist()</span><br><span class="line">    ll.add(1)</span><br><span class="line">    ll.add(2)</span><br><span class="line">    ll.append(3)</span><br><span class="line">    ll.insert(2, 4)</span><br><span class="line">    ll.insert(4, 5)</span><br><span class="line">    ll.insert(0, 6)</span><br><span class="line">    print &quot;length:&quot;,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    print ll.search(3)</span><br><span class="line">    print ll.search(7)</span><br><span class="line">    ll.remove(1)</span><br><span class="line">    print &quot;length:&quot;,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，<strong>当此节点为第一个节点时，指向空值</strong>；而另一个指向下一个节点，<strong>当此节点为最后一个节点时，指向空值</strong>。<br><img src="7E66E70E8DB5451DA3F2CA45A5CF8D71" alt="image"></p>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul>
<li>is_empty() 链表是否为空</li>
<li>length() 链表长度</li>
<li>travel() 遍历链表</li>
<li>add(item) 链表头部添加</li>
<li>append(item) 链表尾部添加</li>
<li>insert(pos, item) 指定位置添加</li>
<li>remove(item) 删除节点</li>
<li>search(item) 查找节点是否存在<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    #双向链表节点</span><br><span class="line">    def __init__(self,item):</span><br><span class="line">        self.item&#x3D;item</span><br><span class="line">        self.next&#x3D;None</span><br><span class="line">        self.prev&#x3D;None</span><br><span class="line">class DLinkList(object):</span><br><span class="line">    #双向链表</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._head&#x3D;None</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.__head&#x3D;&#x3D;None</span><br><span class="line">    def length(self):</span><br><span class="line">        cur&#x3D;self._head</span><br><span class="line">        count&#x3D;0</span><br><span class="line">        while cur!&#x3D;None:</span><br><span class="line">             count+&#x3D;1</span><br><span class="line">             cur&#x3D;cur.next</span><br><span class="line">        return count</span><br><span class="line">    def travel(self):</span><br><span class="line">        cur&#x3D;self._head</span><br><span class="line">        while cur!&#x3D;None:</span><br><span class="line">            print (cur.item)</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">        print &quot;&quot;</span><br><span class="line">    def add(self,item):</span><br><span class="line">        #在头部插入元素</span><br><span class="line">        node&#x3D;Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head&#x3D;node</span><br><span class="line">        else:</span><br><span class="line">            node.next&#x3D;self._head</span><br><span class="line">            self._head.prev&#x3D;node</span><br><span class="line">            self._head&#x3D;node</span><br><span class="line">    def append(self,item):</span><br><span class="line">        #尾部插入元素</span><br><span class="line">        node&#x3D;Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head&#x3D;node</span><br><span class="line">        else:</span><br><span class="line">            #遍历，指针指到链表尾部</span><br><span class="line">            cur&#x3D;self._head</span><br><span class="line">            while cur.next!&#x3D;None:</span><br><span class="line">                cur&#x3D;cur.next</span><br><span class="line">            cur.next&#x3D;node</span><br><span class="line">            node.prev&#x3D;cur</span><br><span class="line">    def search(self,item):</span><br><span class="line">        cur&#x3D;self._head</span><br><span class="line">        while cur!&#x3D;None:</span><br><span class="line">            if cur.item&#x3D;&#x3D;item:</span><br><span class="line">                return True</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h4 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h4><p><img src="685650D7BA9641938DF2935C429752CA" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def insert(self, pos, item):</span><br><span class="line">    &quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span><br><span class="line">    if pos &lt;&#x3D; 0:</span><br><span class="line">        self.add(item)</span><br><span class="line">    elif pos &gt; (self.length()-1):</span><br><span class="line">        self.append(item)</span><br><span class="line">    else:</span><br><span class="line">        node &#x3D; Node(item)</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        # 移动到指定位置的前一个位置</span><br><span class="line">        while count &lt; (pos-1):</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">        # 将node的prev指向cur</span><br><span class="line">        node.prev &#x3D; cur</span><br><span class="line">        # 将node的next指向cur的下一个节点</span><br><span class="line">        node.next &#x3D; cur.next</span><br><span class="line">        # 将cur的下一个节点的prev指向node</span><br><span class="line">        cur.next.prev &#x3D; node</span><br><span class="line">        # 将cur的next指向node</span><br><span class="line">        cur.next &#x3D; node</span><br></pre></td></tr></table></figure>
<h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="64D5168E018E411FA23F56D7CDABF83C" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def remove(self, item):</span><br><span class="line">    &quot;&quot;&quot;删除元素&quot;&quot;&quot;</span><br><span class="line">    if self.is_empty():</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        if cur.item &#x3D;&#x3D; item:</span><br><span class="line">            # 如果首节点的元素即是要删除的元素</span><br><span class="line">            if cur.next &#x3D;&#x3D; None:</span><br><span class="line">                # 如果链表只有这一个节点</span><br><span class="line">                self._head &#x3D; None</span><br><span class="line">            else:</span><br><span class="line">                # 将第二个节点的prev设置为None</span><br><span class="line">                cur.next.prev &#x3D; None</span><br><span class="line">                # 将_head指向第二个节点</span><br><span class="line">                self._head &#x3D; cur.next</span><br><span class="line">            return</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                # 将cur的前一个节点的next指向cur的后一个节点</span><br><span class="line">                cur.prev.next &#x3D; cur.next</span><br><span class="line">                # 将cur的后一个节点的prev指向cur的前一个节点</span><br><span class="line">                cur.next.prev &#x3D; cur.prev</span><br><span class="line">                break</span><br><span class="line">            cur &#x3D; cur.next</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ll &#x3D; DLinkList()</span><br><span class="line">    ll.add(1)</span><br><span class="line">    ll.add(2)</span><br><span class="line">    ll.append(3)</span><br><span class="line">    ll.insert(2, 4)</span><br><span class="line">    ll.insert(4, 5)</span><br><span class="line">    ll.insert(0, 6)</span><br><span class="line">    print (&quot;length:&quot;,ll.length())</span><br><span class="line">    ll.travel()</span><br><span class="line">    print ll.search(3)</span><br><span class="line">    print ll.search(4)</span><br><span class="line">    ll.remove(1)</span><br><span class="line">    print (&quot;length:&quot;,ll.length())</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈结构实现"><a href="#栈结构实现" class="headerlink" title="栈结构实现"></a>栈结构实现</h3><blockquote>
<p>先进后出</p>
</blockquote>
<h4 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h4><ul>
<li>Stack() 创建一个新的空栈</li>
<li>push(item) 添加一个新的元素item到栈顶</li>
<li>pop() 弹出栈顶元素</li>
<li>peek() 返回栈顶元素</li>
<li>is_empty() 判断栈是否为空</li>
<li>size() 返回栈的元素个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Stack(object):</span><br><span class="line">    #栈</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items&#x3D;[]</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.items&#x3D;&#x3D;[]</span><br><span class="line">    def push(self,item): #压入元素</span><br><span class="line">        self.items.append(item)####</span><br><span class="line">    def pop(self):</span><br><span class="line">        #弹出元素</span><br><span class="line">        return self.items.pop()####</span><br><span class="line">    def peek(self):</span><br><span class="line">        #返回栈顶元素</span><br><span class="line">        return self.items[len(self.items)-1]</span><br><span class="line">    def size(self):</span><br><span class="line">        #返回栈的大小</span><br><span class="line">        return len(self.items)</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    stack &#x3D; Stack()</span><br><span class="line">    stack.push(&quot;hello&quot;)</span><br><span class="line">    stack.push(&quot;world&quot;)</span><br><span class="line">    stack.push(&quot;itcast&quot;)</span><br><span class="line">    print (stack.size())</span><br><span class="line">    print (stack.peek())#返回栈顶元素</span><br><span class="line">    print (stack.pop())</span><br><span class="line">    print (stack.pop())</span><br><span class="line">    print (stack.pop())</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong></p>
<p><strong>队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作！</strong></p>
<p>假设队列是q=（a1，a2，……，an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。</p>
<h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>同栈一样，队列也可以用顺序表或者链表实现。</p>
<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><ul>
<li>Queue() 创建一个空的队列</li>
<li>enqueue(item) 往队列中添加一个item元素</li>
<li>dequeue() 从队列头部删除一个元素</li>
<li>is_empty() 判断一个队列是否为空</li>
<li>size() 返回队列的大小<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Queue(object):</span><br><span class="line">    &quot;&quot;&quot;队列&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items &#x3D; []</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.items &#x3D;&#x3D; []</span><br><span class="line"></span><br><span class="line">    def enqueue(self, item):</span><br><span class="line">        &quot;&quot;&quot;进队列&quot;&quot;&quot;</span><br><span class="line">        self.items.insert(0,item)</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        &quot;&quot;&quot;出队列&quot;&quot;&quot;</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        &quot;&quot;&quot;返回大小&quot;&quot;&quot;</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    q &#x3D; Queue()</span><br><span class="line">    q.enqueue(&quot;hello&quot;)</span><br><span class="line">    q.enqueue(&quot;world&quot;)</span><br><span class="line">    q.enqueue(&quot;itcast&quot;)</span><br><span class="line">    print (q.size())</span><br><span class="line">    print (q.dequeue())</span><br><span class="line">    print (q.dequeue())</span><br><span class="line">    print (q.dequeue())</span><br></pre></td></tr></table></figure>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。</p>
<p>双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。</p>
<h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ul>
<li>Deque() 创建一个空的双端队列</li>
<li>add_front(item) 从队头加入一个item元素</li>
<li>add_rear(item) 从队尾加入一个item元素</li>
<li>remove_front() 从队头删除一个item元素</li>
<li>remove_rear() 从队尾删除一个item元素</li>
<li>is_empty() 判断双端队列是否为空</li>
<li>size() 返回队列的大小<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Deque(object):</span><br><span class="line">    &quot;&quot;&quot;双端队列&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items &#x3D; []</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span><br><span class="line">        return self.items &#x3D;&#x3D; []</span><br><span class="line"></span><br><span class="line">    def add_front(self, item):</span><br><span class="line">        &quot;&quot;&quot;在队头添加元素&quot;&quot;&quot;</span><br><span class="line">        self.items.insert(0,item)</span><br><span class="line"></span><br><span class="line">    def add_rear(self, item):</span><br><span class="line">        &quot;&quot;&quot;在队尾添加元素&quot;&quot;&quot;</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def remove_front(self):</span><br><span class="line">        &quot;&quot;&quot;从队头删除元素&quot;&quot;&quot;</span><br><span class="line">        return self.items.pop(0)</span><br><span class="line"></span><br><span class="line">    def remove_rear(self):</span><br><span class="line">        &quot;&quot;&quot;从队尾删除元素&quot;&quot;&quot;</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        &quot;&quot;&quot;返回队列大小&quot;&quot;&quot;</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    deque &#x3D; Deque()</span><br><span class="line">    deque.add_front(1)</span><br><span class="line">    deque.add_front(2)</span><br><span class="line">    deque.add_rear(3)</span><br><span class="line">    deque.add_rear(4)</span><br><span class="line">    print deque.size()# 1 2 3 4</span><br><span class="line">    print (deque.remove_front()) #2</span><br><span class="line">    print (deque.remove_front()) #1</span><br><span class="line">    print (deque.remove_rear()) #4</span><br><span class="line">    print (deque.remove_rear()) #3</span><br></pre></td></tr></table></figure>
<h2 id="树与树算法"><a href="#树与树算法" class="headerlink" title="树与树算法"></a>树与树算法</h2><h4 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h4><ul>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>树的度：一棵树中，最大的节点的度称为树的度；</li>
<li>叶节点或终端节点：<strong>度为零的节点</strong>；</li>
<li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的层次：<strong>从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</strong></li>
<li>树的高度或深度：树中节点的最大层次；</li>
<li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；、</li>
</ul>
<h4 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h4><ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul>
<li>二叉树：<strong>每个节点最多含有两个子树的树称为二叉树；</strong><ul>
<li>完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，<strong>其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</strong></li>
<li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li>排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；</li>
<li>霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。<h4 id="树的存储与表示"><a href="#树的存储与表示" class="headerlink" title="树的存储与表示"></a>树的存储与表示</h4></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>顺序存储</strong>：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。<strong>二叉树通常以链式存储。</strong><br><img src="06C2B26768234A5BA95B4EC74332229B" alt="image"></p>
<p><strong>链式存储</strong>：<br><img src="115E8B2940CA4BEDAFBA3E8A08257332" alt="image"></p>
<h4 id="常见树的应用"><a href="#常见树的应用" class="headerlink" title="常见树的应用"></a>常见树的应用</h4><ul>
<li>xml，html等，那么编写这些东西的解析器的时候，不可避免用到树</li>
<li>路由协议就是使用了树的算法</li>
<li>mysql数据库索引</li>
<li>文件系统的目录结构</li>
<li>所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h4>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）<h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4></li>
<li>性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）</li>
<li>性质2: 深度为k的二叉树至多有2^k - 1个结点（k&gt;0）</li>
<li>性质3: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;</li>
<li>性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)</li>
<li>性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</li>
</ul>
<p>(1)完全二叉树——若设二叉树的高度为h，<strong>除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数</strong>，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。<br><img src="2F0514E347464DC98EA193353FA2C4C8" alt="image"></p>
<p>(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。<br><img src="593071516CAF43DA8DD3231F820A2478" alt="image"></p>
<h4 id="二叉树的节点表示以及树的创建"><a href="#二叉树的节点表示以及树的创建" class="headerlink" title="二叉树的节点表示以及树的创建"></a>二叉树的节点表示以及树的创建</h4><p>通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    &quot;&quot;&quot;节点类&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, elem&#x3D;-1, lchild&#x3D;None, rchild&#x3D;None):</span><br><span class="line">        self.elem &#x3D; elem</span><br><span class="line">        self.lchild &#x3D; lchild</span><br><span class="line">        self.rchild &#x3D; rchild</span><br></pre></td></tr></table></figure>
<p>树的创建,创建一个树的类，并给一个root根节点，一开始为空，随后添加节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Tree(object):</span><br><span class="line">    &quot;&quot;&quot;树类&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, root&#x3D;None):</span><br><span class="line">        self.root &#x3D; root</span><br><span class="line"></span><br><span class="line">    def add(self, elem):</span><br><span class="line">        &quot;&quot;&quot;为树添加节点&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; Node(elem)</span><br><span class="line">        #如果树是空的，则对根节点赋值</span><br><span class="line">        if self.root &#x3D;&#x3D; None:</span><br><span class="line">            self.root &#x3D; node</span><br><span class="line">        else: #利用队列</span><br><span class="line">            queue &#x3D; []</span><br><span class="line">            queue.append(self.root)</span><br><span class="line">            #对已有的节点进行层次遍历</span><br><span class="line">            while queue:</span><br><span class="line">                #弹出队列的第一个元素</span><br><span class="line">                cur &#x3D; queue.pop(0)</span><br><span class="line">                if cur.lchild &#x3D;&#x3D; None:</span><br><span class="line">                    cur.lchild &#x3D; node</span><br><span class="line">                    return</span><br><span class="line">                elif cur.rchild &#x3D;&#x3D; None:</span><br><span class="line">                    cur.rchild &#x3D; node</span><br><span class="line">                    return</span><br><span class="line">                else:</span><br><span class="line">                    #如果左右子树都不为空，加入队列继续判断</span><br><span class="line">                    queue.append(cur.lchild)</span><br><span class="line">                    queue.append(cur.rchild)</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>树的遍历是树的一种重要的运算<strong>。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）</strong>。</p>
<p>那么树的两种重要的遍历模式是<strong>深度优先遍历和广度优先遍历</strong>,深度优先一般用<strong>递归</strong>，广度优先一般用<strong>队列</strong>。一般情况下能用递归实现的算法大部分也能用<strong>堆栈</strong>来实现。</p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p>
<ul>
<li>先序遍历 在先序遍历中，我们先访问<strong>根节点</strong>，然后递归使用先序遍历访问<strong>左子树</strong>，再递归使用先序遍历访问<strong>右子树</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def preorder(self, root):</span><br><span class="line">      &quot;&quot;&quot;递归实现先序遍历&quot;&quot;&quot;</span><br><span class="line">      if root &#x3D;&#x3D; None:</span><br><span class="line">          return</span><br><span class="line">      print root.elem</span><br><span class="line">      self.preorder(root.lchild)</span><br><span class="line">      self.preorder(root.rchild)</span><br></pre></td></tr></table></figure>
<ul>
<li>中序遍历 在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def inorder(self, root):</span><br><span class="line">      &quot;&quot;&quot;递归实现中序遍历&quot;&quot;&quot;</span><br><span class="line">      if root &#x3D;&#x3D; None:</span><br><span class="line">          return</span><br><span class="line">      self.inorder(root.lchild)</span><br><span class="line">      print root.elem</span><br><span class="line">      self.inorder(root.rchild)</span><br></pre></td></tr></table></figure>
<ul>
<li>后序遍历 在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def postorder(self, root):</span><br><span class="line">      &quot;&quot;&quot;递归实现后续遍历&quot;&quot;&quot;</span><br><span class="line">      if root &#x3D;&#x3D; None:</span><br><span class="line">          return</span><br><span class="line">      self.postorder(root.lchild)</span><br><span class="line">      self.postorder(root.rchild)</span><br><span class="line">      print root.elem</span><br></pre></td></tr></table></figure>
<h4 id="广度优先遍历-层次遍历"><a href="#广度优先遍历-层次遍历" class="headerlink" title="广度优先遍历(层次遍历)"></a>广度优先遍历(层次遍历)</h4></li>
</ul>
<p>从树的root开始，从上到下从从左到右遍历整个树的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def breadth_travel(self, root):</span><br><span class="line">        &quot;&quot;&quot;利用队列实现树的层次遍历&quot;&quot;&quot;</span><br><span class="line">        if root &#x3D;&#x3D; None:</span><br><span class="line">            return</span><br><span class="line">        queue &#x3D; []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        while queue:</span><br><span class="line">            node &#x3D; queue.pop(0)</span><br><span class="line">            print node.elem,</span><br><span class="line">            if node.lchild !&#x3D; None:</span><br><span class="line">                queue.append(node.lchild)</span><br><span class="line">            if node.rchild !&#x3D; None:</span><br><span class="line">                queue.append(node.rchild)</span><br></pre></td></tr></table></figure>
<h2 id="排序与搜索"><a href="#排序与搜索" class="headerlink" title="排序与搜索"></a>排序与搜索</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序算法的运作如下：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def bubble_sort(alist):</span><br><span class="line">    for j in range(len(alist)-1,0,-1):</span><br><span class="line">        # j表示每次遍历需要比较的次数，是逐渐减小的</span><br><span class="line">        for i in range(j):</span><br><span class="line">            if alist[i] &gt; alist[i+1]:</span><br><span class="line">                alist[i], alist[i+1] &#x3D; alist[i+1], alist[i]</span><br><span class="line"></span><br><span class="line">li &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：稳定<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def selection_sort(alist):</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    # 需要进行n-1次选择操作</span><br><span class="line">    for i in range(n-1):</span><br><span class="line">        # 记录最小位置</span><br><span class="line">        min_index &#x3D; i</span><br><span class="line">        # 从i+1位置到末尾选择出最小数据</span><br><span class="line">        for j in range(i+1, n):</span><br><span class="line">            if alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index &#x3D; j</span><br><span class="line">        # 如果选择出的数据不在正确位置，进行交换</span><br><span class="line">        if min_index !&#x3D; i:</span><br><span class="line">            alist[i], alist[min_index] &#x3D; alist[min_index], alist[i]</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,226,93,17,77,31,44,55,20]</span><br><span class="line">selection_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(n2)</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：不稳定（考虑升序每次选择最大的情况）<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort(alist):</span><br><span class="line">    # 从第二个位置，即下标为1的元素开始向前插入</span><br><span class="line">    for i in range(1, len(alist)):</span><br><span class="line">        # 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span><br><span class="line">        for j in range(i, 0, -1):</span><br><span class="line">            if alist[j] &lt; alist[j-1]:</span><br><span class="line">                alist[j], alist[j-1] &#x3D; alist[j-1], alist[j]</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">insert_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：稳定<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def quick_sort(alist, start, end):</span><br><span class="line">    &quot;&quot;&quot;快速排序&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 递归的退出条件</span><br><span class="line">    if start &gt;&#x3D; end:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 设定起始元素为要寻找位置的基准元素</span><br><span class="line">    mid &#x3D; alist[start]</span><br><span class="line"></span><br><span class="line">    # low为序列左边的由左向右移动的游标</span><br><span class="line">    low &#x3D; start</span><br><span class="line"></span><br><span class="line">    # high为序列右边的由右向左移动的游标</span><br><span class="line">    high &#x3D; end</span><br><span class="line"></span><br><span class="line">    while low &lt; high:</span><br><span class="line">        # 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span><br><span class="line">        while low &lt; high and alist[high] &gt;&#x3D; mid:</span><br><span class="line">            high -&#x3D; 1</span><br><span class="line">        # 将high指向的元素放到low的位置上</span><br><span class="line">        alist[low] &#x3D; alist[high]</span><br><span class="line"></span><br><span class="line">        # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span><br><span class="line">        while low &lt; high and alist[low] &lt; mid:</span><br><span class="line">            low +&#x3D; 1</span><br><span class="line">        # 将low指向的元素放到high的位置上</span><br><span class="line">        alist[high] &#x3D; alist[low]</span><br><span class="line"></span><br><span class="line">    # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span><br><span class="line">    # 将基准元素放到该位置</span><br><span class="line">    alist[low] &#x3D; mid</span><br><span class="line"></span><br><span class="line">    # 对基准元素左边的子序列进行快速排序</span><br><span class="line">    quick_sort(alist, start, low-1)</span><br><span class="line"></span><br><span class="line">    # 对基准元素右边的子序列进行快速排序</span><br><span class="line">    quick_sort(alist, low+1, end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">quick_sort(alist,0,len(alist)-1)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(nlogn)</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：不稳定</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(alist):</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    # 初始步长</span><br><span class="line">    gap &#x3D; n &#x2F; 2</span><br><span class="line">    while gap &gt; 0:</span><br><span class="line">        # 按步长进行插入排序</span><br><span class="line">        for i in range(gap, n):</span><br><span class="line">            j &#x3D; i</span><br><span class="line">            # 插入排序</span><br><span class="line">            while j&gt;&#x3D;gap and alist[j-gap] &gt; alist[j]:</span><br><span class="line">                alist[j-gap], alist[j] &#x3D; alist[j], alist[j-gap]</span><br><span class="line">                j -&#x3D; gap</span><br><span class="line">        # 得到新的步长</span><br><span class="line">        gap &#x3D; gap &#x2F; 2</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">shell_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：根据步长序列的不同而不同</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定想：不稳定</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def merge_sort(alist):</span><br><span class="line">    if len(alist) &lt;&#x3D; 1:</span><br><span class="line">        return alist</span><br><span class="line">    # 二分分解</span><br><span class="line">    num &#x3D; len(alist)&#x2F;2</span><br><span class="line">    left &#x3D; merge_sort(alist[:num])</span><br><span class="line">    right &#x3D; merge_sort(alist[num:])</span><br><span class="line">    # 合并</span><br><span class="line">    return merge(left,right)</span><br><span class="line"></span><br><span class="line">def merge(left, right):</span><br><span class="line">    &#39;&#39;&#39;合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组&#39;&#39;&#39;</span><br><span class="line">    #left与right的下标指针</span><br><span class="line">    l, r &#x3D; 0, 0</span><br><span class="line">    result &#x3D; []</span><br><span class="line">    while l&lt;len(left) and r&lt;len(right):</span><br><span class="line">        if left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r +&#x3D; 1</span><br><span class="line">    result +&#x3D; left[l:]</span><br><span class="line">    result +&#x3D; right[r:]</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">sorted_alist &#x3D; mergeSort(alist)</span><br><span class="line">print(sorted_alist)</span><br></pre></td></tr></table></figure>
<h3 id="常见排序算法比较"><a href="#常见排序算法比较" class="headerlink" title="常见排序算法比较"></a>常见排序算法比较</h3><p><img src="0E3E13D058AB44B38978CF8509AB4FC4" alt="image"></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找。</p>
<h4 id="二分法查找实现"><a href="#二分法查找实现" class="headerlink" title="二分法查找实现"></a>二分法查找实现</h4><h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(alist, item):</span><br><span class="line">      first &#x3D; 0</span><br><span class="line">      last &#x3D; len(alist)-1</span><br><span class="line">      while first&lt;&#x3D;last:</span><br><span class="line">          midpoint &#x3D; (first + last)&#x2F;2</span><br><span class="line">          if alist[midpoint] &#x3D;&#x3D; item:</span><br><span class="line">              return True</span><br><span class="line">          elif item &lt; alist[midpoint]:</span><br><span class="line">              last &#x3D; midpoint-1</span><br><span class="line">          else:</span><br><span class="line">              first &#x3D; midpoint+1</span><br><span class="line">    return False</span><br><span class="line">testlist &#x3D; [0, 1, 2, 8, 13, 17, 19, 32, 42,]</span><br><span class="line">print(binary_search(testlist, 3))</span><br><span class="line">print(binary_search(testlist, 13))</span><br></pre></td></tr></table></figure>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(alist, item):</span><br><span class="line">    if len(alist) &#x3D;&#x3D; 0:</span><br><span class="line">        return False</span><br><span class="line">    else:</span><br><span class="line">        midpoint &#x3D; len(alist)&#x2F;&#x2F;2</span><br><span class="line">        if alist[midpoint]&#x3D;&#x3D;item:</span><br><span class="line">          return True</span><br><span class="line">        else:</span><br><span class="line">          if item&lt;alist[midpoint]:</span><br><span class="line">            return binary_search(alist[:midpoint],item)</span><br><span class="line">          else:</span><br><span class="line">            return binary_search(alist[midpoint+1:],item)</span><br><span class="line"></span><br><span class="line">testlist &#x3D; [0, 1, 2, 8, 13, 17, 19, 32, 42,]</span><br><span class="line">print(binary_search(testlist, 3))</span><br><span class="line">print(binary_search(testlist, 13))</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(1)</li>
<li>最坏时间复杂度：O(logn)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%AF%BB%E6%89%BE%E7%8B%AC%E7%AB%8B%E7%89%B9%E5%BE%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%AF%BB%E6%89%BE%E7%8B%AC%E7%AB%8B%E7%89%B9%E5%BE%81/" class="post-title-link" itemprop="url">集体智慧编程_第十章寻找独立特征</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-13 19:18:47 / 修改时间：19:19:30" itemprop="dateCreated datePublished" datetime="2020-02-13T19:18:47+08:00">2020-02-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>除了第三章的聚类算法属于非监督技术之外，其余大部分章节都主要集中在监督分类器上。本章将研究如何在数据集并未明确表示结果的前提下，从中<strong>提取重要的潜在特征来。</strong><br>鸡尾酒宴会。</p>
<h3 id="搜索一组新闻"><a href="#搜索一组新闻" class="headerlink" title="搜索一组新闻"></a>搜索一组新闻</h3><h4 id="选择新闻来源"><a href="#选择新闻来源" class="headerlink" title="选择新闻来源"></a>选择新闻来源</h4><p>选择的订阅源中的新闻内容存在重叠</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import feedparser</span><br><span class="line">import re</span><br><span class="line">feedlist&#x3D;[&#39;http:&#x2F;&#x2F;...&#39;,&#39;http:&#x2F;&#x2F;...&#39;]</span><br></pre></td></tr></table></figure>
<h4 id="下载新闻来源"><a href="#下载新闻来源" class="headerlink" title="下载新闻来源"></a>下载新闻来源</h4><p>接受一个大型的数据矩阵，每行代表一个数据项，每列代表数据项的一个属性。在本例中，行对应各类文章，列对应单词。<br>从订阅源中得到矩阵如下：</p>
<p>删除文章中所有的图片和HTNL标注</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def striphtml(h):</span><br><span class="line">   p&#x3D;&#39;&#39;</span><br><span class="line">   s&#x3D;0</span><br><span class="line">   for c in h:</span><br><span class="line">      if c&#x3D;&#x3D;&#39;&lt;&#39;:s&#x3D;1</span><br><span class="line">      elif c&#x3D;&#x3D;&#39;&gt;&#39;:s&#x3D;0 p+&#x3D;&#39; &#39;</span><br><span class="line">      elif s&#x3D;&#x3D;0:p+&#x3D;c</span><br><span class="line">   return p</span><br></pre></td></tr></table></figure>
<p>拆分文本中的单词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def separatewords():</span><br><span class="line">   splitter&#x3D;re.compile(&#39;\\W*&#39;)</span><br><span class="line">   return [s.lower() for s in splitter.split(text) if len(s)&gt;3]</span><br></pre></td></tr></table></figure>
<p>综合以上算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def getarticlewords():</span><br><span class="line">   allwords&#x3D;&#123;&#125;</span><br><span class="line">   articlewords&#x3D;[]</span><br><span class="line">   articletitles&#x3D;[]</span><br><span class="line">   ec&#x3D;0</span><br><span class="line">   for feed in feedlist:</span><br><span class="line">      f&#x3D;feedparser.parse(feed)</span><br><span class="line">      for e in f.entries:</span><br><span class="line">         if e.title in  articletitles:continue</span><br><span class="line">         #提取单词</span><br><span class="line">         txt&#x3D;e.title.encode(&#39;utf8&#39;)+stripHTML(e.description.encode(&#39;utf8&#39;))</span><br><span class="line">         words&#x3D;separatewords(txt)</span><br><span class="line">         articlewords.append(&#123;&#125;)</span><br><span class="line">         articletitles.append(e.title)</span><br><span class="line">         </span><br><span class="line">         for word in words:</span><br><span class="line">            allwords.setdefault(word,0)</span><br><span class="line">            allwords[word]+&#x3D;1</span><br><span class="line">            articlewords[ec],setdefault(word,0)</span><br><span class="line">            articlewords[ec][word]+&#x3D;1</span><br><span class="line">        ec+&#x3D;1</span><br><span class="line">  return allwords,articlewords,articletitles</span><br></pre></td></tr></table></figure>
<h4 id="转换成矩阵"><a href="#转换成矩阵" class="headerlink" title="转换成矩阵"></a>转换成矩阵</h4><p>在超过三篇文章中出现过，但在所有文章中出现的比例小于60%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def makematrix(allw,articlew):</span><br><span class="line">   wordvec&#x3D;[]</span><br><span class="line">   for w,c in allw.items():</span><br><span class="line">      if c&gt;3 and c&lt;len(articlew)*0.6:</span><br><span class="line">         wordvec.append(w)</span><br><span class="line">   l1&#x3D;[[(word in f and f[word] or 0)for word in wordvec]for f in articlew]</span><br><span class="line">   return l1,wordvec</span><br></pre></td></tr></table></figure>
<h3 id="先前的方法"><a href="#先前的方法" class="headerlink" title="先前的方法"></a>先前的方法</h3><h4 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h4><p>监督学习法。首先必须对几个样本故事进行分类。必须确定不同的分类。</p>
<h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><p>唯一一种非监督方法。</p>
<h3 id="非负矩阵因式分解NMF"><a href="#非负矩阵因式分解NMF" class="headerlink" title="非负矩阵因式分解NMF"></a>非负矩阵因式分解NMF</h3><p>特征矩阵：代表某个单词相对于某个特征的重要程度。</p>
<p>权值矩阵：将特征矩阵映射到文章矩阵。每个数字代表每个特征应用于每篇文章的程度。</p>
<p>文章矩阵为权值矩阵*特征矩阵。</p>
<h4 id="使用NUMPY"><a href="#使用NUMPY" class="headerlink" title="使用NUMPY"></a>使用NUMPY</h4><p>矩阵分解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def factorize(v,pc&#x3D;10,iter&#x3D;50):</span><br><span class="line">   ic&#x3D;shape(v)[0]</span><br><span class="line">   fc&#x3D;shape(v)[1]</span><br><span class="line">   w&#x3D;matrix([random.random() for j i range(pc)] for i in range(ic)])</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>

<p>略</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%A0%B8%E6%96%B9%E6%B3%95%E4%B8%8ESVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%A0%B8%E6%96%B9%E6%B3%95%E4%B8%8ESVM/" class="post-title-link" itemprop="url">集体智慧编程_第九章核方法与SVM</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-13 17:39:21 / 修改时间：17:40:14" itemprop="dateCreated datePublished" datetime="2020-02-13T17:39:21+08:00">2020-02-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为约会网站的用户寻找配对；数据包含数值型、名词性和大量的非线性关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class matchrow：</span><br><span class="line">    def __init__(self,row,allnum&#x3D;False):</span><br><span class="line">        if allnum:</span><br><span class="line">           self.data&#x3D;[float(row[i]) for i in range(len(row)-1)</span><br><span class="line">        else:</span><br><span class="line">           self.data&#x3D;row[0:len(data)-1]</span><br><span class="line">        self.match&#x3D;int(row[len(row)-1]))</span><br><span class="line">    def loadmatch(f,allnum&#x3D;False):</span><br><span class="line">        rows&#x3D;[]</span><br><span class="line">        for line in file(f):</span><br><span class="line">            rows.append(matchrow(line.split(&#39;,&#39;),allnum))</span><br><span class="line">        return rows</span><br></pre></td></tr></table></figure>
<h4 id="基本的线性分类"><a href="#基本的线性分类" class="headerlink" title="基本的线性分类"></a>基本的线性分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def lineartrain(rows):</span><br><span class="line">    averages&#x3D;&#123;&#125;</span><br><span class="line">    counts&#x3D;&#123;&#125;</span><br><span class="line">    for row in rows:</span><br><span class="line">        c1&#x3D;row.match</span><br><span class="line">        averages.setdefault(c1,[0.0]*(len(row.data)))</span><br><span class="line">        counts,setdefault(c1,0)</span><br><span class="line">        for i in range(len(row.data)):</span><br><span class="line">           averages[c1][i]&#x3D;float(row.data[i])</span><br><span class="line">        counts[c1]+&#x3D;1</span><br><span class="line">    for c1,avg in averages.items():</span><br><span class="line">        for i in range(len(avg)):</span><br><span class="line">            avg[i]&#x3D;avg[i]&#x2F;counts[c1]</span><br><span class="line">    return averages</span><br><span class="line">    确定匹配和不匹配状态下的数据的平均值，显示在图上。</span><br></pre></td></tr></table></figure>
<p>点积。class=sign((x-(m0+m1)/2)*(m0-m1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def dotproduct(v1,v2):</span><br><span class="line">    return sum([v1[i]*v2[i] for i in range(len(v1))])</span><br><span class="line">    </span><br><span class="line">def dpclassify(point,avgs):</span><br><span class="line">    b&#x3D;(dotproduct(avgs[1],avgs[1])-dotproduct(avgs[0],avgs[0]))&#x2F;2</span><br><span class="line">    y&#x3D;dotproduct(point,avgs[0])-dotproduct(point,avgs[1])+b</span><br><span class="line">    if y&gt;0: return 0</span><br><span class="line">    else: return 1</span><br></pre></td></tr></table></figure>
<h4 id="分类特征"><a href="#分类特征" class="headerlink" title="分类特征"></a>分类特征</h4><p>将数据转化为数值型。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def yesno(v):</span><br><span class="line">    if v&#x3D;&#x3D;&#39;yes&#39;: return 1</span><br><span class="line">    elif v&#x3D;&#x3D;&#39;no&#39;:return -1</span><br><span class="line">    else: return 0</span><br></pre></td></tr></table></figure>
<h4 id="兴趣列表"><a href="#兴趣列表" class="headerlink" title="兴趣列表"></a>兴趣列表</h4><p>统计具有相同的兴趣个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def matchcount(interest1,interest2):</span><br><span class="line">    l1&#x3D;interest1.split(&#39;:&#39;)</span><br><span class="line">    l2&#x3D;interest2.split(&#39;:&#39;)</span><br><span class="line">    x&#x3D;0</span><br><span class="line">    for v in l1:</span><br><span class="line">        if v in l2:</span><br><span class="line">           x+&#x3D;1</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>
<h4 id="利用Yahoo-Maps来确定距离"><a href="#利用Yahoo-Maps来确定距离" class="headerlink" title="利用Yahoo! Maps来确定距离"></a>利用Yahoo! Maps来确定距离</h4><p>略</p>
<h4 id="构造新的数据集"><a href="#构造新的数据集" class="headerlink" title="构造新的数据集"></a>构造新的数据集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def loadnumerical():</span><br><span class="line">    oldrows&#x3D;loadmatch(&#39;matchmaker.csv&#39;)</span><br><span class="line">    newrows&#x3D;[]</span><br><span class="line">    for row in oldrows:</span><br><span class="line">       d&#x3D;row.data</span><br><span class="line">       data&#x3D;[float(d[0]),yesno(d[1]),yesno(d[2]),float(d[5]),yesno(d[6]),yesno(d[7]),matchcount(d[3],d[8]),milesdistance(d[4],d[9]),</span><br><span class="line">       row.match]</span><br><span class="line">       newrows.append(matchrow(data))</span><br><span class="line">    return newrows</span><br></pre></td></tr></table></figure>
<h4 id="对数据进行缩放处理"><a href="#对数据进行缩放处理" class="headerlink" title="对数据进行缩放处理"></a>对数据进行缩放处理</h4><p>将所有数据转化为0-1之间的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def scaledata(rows):</span><br><span class="line">   low&#x3D;[99999999]*len(rows[0].data)</span><br><span class="line">   high&#x3D;[-9999999]*len(rows[0].data)</span><br><span class="line">   for row in rows:</span><br><span class="line">      d&#x3D;row.data</span><br><span class="line">      for i in range(len(d)):</span><br><span class="line">         if d[i]&lt;low[i]: low[i]&#x3D;d[i]</span><br><span class="line">         if d[i]&gt;high[i]: high[i]&#x3D;d[i]</span><br><span class="line">  def scaleinput(d):</span><br><span class="line">    return     [(d.data[i]-low[i])&#x2F;(high[i]-low[i])       </span><br><span class="line">    for i in range(len(low))]</span><br><span class="line">  newrows&#x3D;[matchrow(scaleinput(row.data)+[row.match]) for row in rows]</span><br><span class="line">  </span><br><span class="line">  return newrows,scaleinput</span><br></pre></td></tr></table></figure>
<h4 id="理解核方法"><a href="#理解核方法" class="headerlink" title="理解核方法"></a>理解核方法</h4><p>我们可以预先的坐标点进行变换，构造一个用一条直线就可以进行划分的新数据集。</p>
<h5 id="核技法"><a href="#核技法" class="headerlink" title="核技法"></a>核技法</h5><p>用一个新的函数来取代原来的点积函数，当借助某个映射函数将数据第一次变换到更高纬度的坐标空间时，新函数将会返回高纬度坐标空间的点积结果。————径向基函数。是非线性的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def rbf(v1,v2,gamma&#x3D;20):</span><br><span class="line">    dv&#x3D;[v1[i]-v2[i] for i in range(len(v1))]</span><br><span class="line">    l&#x3D;veclength(dv)</span><br><span class="line">    return math.e**(-gamma*l)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def getoffset(rows,gamma&#x3D;10):</span><br><span class="line">略</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def nlclassify(point,rows,offset,gamma&#x3D;10)</span><br><span class="line">    sum0&#x3D;0</span><br><span class="line">    sum1&#x3D;0</span><br><span class="line">    count1&#x3D;0</span><br><span class="line">    count0&#x3D;0</span><br><span class="line">    for row in rows:</span><br><span class="line">        if row.match&#x3D;&#x3D;0:</span><br><span class="line">             sum0+&#x3D;rbf(point,row.data,gamma)</span><br><span class="line">             count0+&#x3D;1</span><br><span class="line">        else:</span><br><span class="line">             sum1+&#x3D;rbf(point,row.data,gamma)</span><br><span class="line">             count1+&#x3D;1</span><br><span class="line">    y&#x3D;(1&#x2F;count0)*sum0-(1&#x2F;count1)*sum1+offset</span><br><span class="line">    </span><br><span class="line">    if y&lt;0:return 0</span><br><span class="line">    else return 1 #将经过处理的数据进行判别(dpclassify)</span><br></pre></td></tr></table></figure>

<h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><p><img src="C1343EB5CB5D470ABFC26C3D334CCC9B" alt="image"></p>
<p>我们引入一个LIBSVM的开源库，它能够对SVM模型进行训练、给出预测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from svm import *</span><br><span class="line">prob&#x3D;svm_problem([1,-1],[[1,0,1],[-1,0,-1]])</span><br><span class="line">param&#x3D;svm_parameter(kernel_type&#x3D;LINEAR,C&#x3D;10)</span><br><span class="line">#训练</span><br><span class="line">m&#x3D;svm_model(prob,param)</span><br><span class="line">#预测</span><br><span class="line">m.predice([1,1,1])</span><br></pre></td></tr></table></figure>
<h5 id="用SVM用于婚介数据集-系统自带的函数"><a href="#用SVM用于婚介数据集-系统自带的函数" class="headerlink" title="用SVM用于婚介数据集,系统自带的函数"></a>用SVM用于婚介数据集,系统自带的函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">answers,inputs&#x3D;[r.match for r in scaledset],[r.data for r in scaledset]</span><br><span class="line">param&#x3D;svm_parameter(kernel_type&#x3D;RBF)</span><br><span class="line">prob&#x3D;svm_problem(answers,inputs)</span><br><span class="line">m&#x3D;svm_model(prob,param)</span><br><span class="line"></span><br><span class="line">m.predict(scalef(newrow))</span><br><span class="line">#利用交叉验证函数来检验模型的质量...</span><br><span class="line">g&#x3D;cross_validation(prob,param,4)</span><br><span class="line">n&#x3D;sum([abs(answers[i]-g[i]) for i in range(len(g))</span><br></pre></td></tr></table></figure>
<p>若n=116,由于初始集为500，则得到了384项正确匹配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/10/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%B3%E7%AD%96%E6%A0%91%E5%BB%BA%E6%A8%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%B3%E7%AD%96%E6%A0%91%E5%BB%BA%E6%A8%A1/" class="post-title-link" itemprop="url">集体智慧编程_第七章决策树建模</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-10 15:26:14 / 修改时间：15:27:07" itemprop="dateCreated datePublished" datetime="2020-02-10T15:26:14+08:00">2020-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="预测注册用户"><a href="#预测注册用户" class="headerlink" title="预测注册用户"></a>预测注册用户</h3><p>针对某个web站点的用户行为及其最终购买决策。最后一栏的服务类型是我们需要预测的内容。<br>来源网站、位置、是否阅读过FAQ、浏览网页数、选择服务类型。</p>
<p>将数据文件加载进来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_data&#x3D;[line.split(&#39;\t&#39;) for line in file(&#39;decision_tree.txt&#39;)]</span><br></pre></td></tr></table></figure>
<h4 id="引入决策树"><a href="#引入决策树" class="headerlink" title="引入决策树"></a>引入决策树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class decisionnode:</span><br><span class="line">   def __init__(self,col&#x3D;-1,value&#x3D;None,results&#x3D;None,tb&#x3D;None,fb&#x3D;None):</span><br><span class="line">     self.col&#x3D;col</span><br><span class="line">     self.value&#x3D;value</span><br><span class="line">     self.results&#x3D;results</span><br><span class="line">     self.tb&#x3D;tb</span><br><span class="line">     self.fb&#x3D;fb</span><br></pre></td></tr></table></figure>
<h4 id="对树进行训练"><a href="#对树进行训练" class="headerlink" title="对树进行训练"></a>对树进行训练</h4><p>根据某一栏的数据将列表拆分成两个数据集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def divideset(rows,column,value):</span><br><span class="line">    #rows为数据集，columns为某一列的名字，</span><br><span class="line">    split_function&#x3D;None</span><br><span class="line">    if isinstance(value,int) or isinstance(value,float):</span><br><span class="line">        #如果value是数值型数据</span><br><span class="line">        #分成两组,row[column]&gt;&#x3D;value的返回true</span><br><span class="line">        split_function&#x3D;lambda row:row[column]&gt;&#x3D;value</span><br><span class="line">    else:#名词性数据</span><br><span class="line">        split_function&#x3D;lambda row:row[column]&#x3D;value</span><br><span class="line">    set1&#x3D;[row for row in rows if split_function(row)]</span><br><span class="line">    set2&#x3D;[row for row in rows if not split_function(row)]</span><br><span class="line">    return (set1,set2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dividest(my_data,2,&#39;yes&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="选择最合适的拆分方案"><a href="#选择最合适的拆分方案" class="headerlink" title="选择最合适的拆分方案"></a>选择最合适的拆分方案</h3><p>对数据集中最后一列的结果进行计数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def uniquecounts(rows):</span><br><span class="line">    results&#x3D;&#123;&#125;</span><br><span class="line">    for row in rows:</span><br><span class="line">       #计数结果在最后一列</span><br><span class="line">       r&#x3D;row[len(row)-1]</span><br><span class="line">       if r not in results: results[r]&#x3D;0</span><br><span class="line">       results[r]+&#x3D;1</span><br><span class="line">     return results</span><br></pre></td></tr></table></figure>
<h4 id="基尼不纯度"><a href="#基尼不纯度" class="headerlink" title="基尼不纯度"></a>基尼不纯度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def giniimpurity(rows):</span><br><span class="line">    total&#x3D;len(rows)</span><br><span class="line">    counts&#x3D;uniquecounts(rows)</span><br><span class="line">    imp&#x3D;0</span><br><span class="line">    for k1 in counts:</span><br><span class="line">        p1&#x3D;float(counts[k1])&#x2F;total</span><br><span class="line">        for k2 in counts:</span><br><span class="line">          if k1&#x3D;&#x3D;k2:continue</span><br><span class="line">          p2&#x3D;float(counts[k2])&#x2F;total</span><br><span class="line">          imp+&#x3D;p2*p1</span><br><span class="line">    return imp</span><br></pre></td></tr></table></figure>
<h4 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def entropy(rows):</span><br><span class="line">    from math import log</span><br><span class="line">    log2&#x3D;lambda x:log(x)&#x2F;log(2)</span><br><span class="line">    results&#x3D;uniquecounts(rows)</span><br><span class="line">    ent&#x3D;0</span><br><span class="line">    for r in results.keys():</span><br><span class="line">       p&#x3D;float(results[r])&#x2F;len(rows)</span><br><span class="line">       ent&#x3D;ent-p*log2(p)</span><br><span class="line">     return ent</span><br></pre></td></tr></table></figure>

<h3 id="以递归的方式构造树"><a href="#以递归的方式构造树" class="headerlink" title="以递归的方式构造树"></a>以递归的方式构造树</h3><p>通过为当前数据集选择最合适的拆分条件来构造树。<br>函数首先接受一个由数据行构成的列表作为参数。它遍历了数据集中的每一列，针对各列查找每一种可能的取值，并将数据集拆分成两个新的子集。通过将每个子集的熵乘以子集中所含数据项在原数据集中所占的比重，并记录熵最低的那一对集。如果该值比当前集合的熵大，则拆分过程结束。否则继续使用buildtree函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def buildtree(rows,scoref&#x3D;entropy):</span><br><span class="line">   if len(rows)&#x3D;&#x3D;0 return decisionnode()</span><br><span class="line">   current_score&#x3D;scoref(rows)</span><br><span class="line">   </span><br><span class="line">   best_gain&#x3D;0</span><br><span class="line">   best_criteria&#x3D;None</span><br><span class="line">   best_sets&#x3D;None</span><br><span class="line">   </span><br><span class="line">   #最后一列</span><br><span class="line">   column_count&#x3D;len(rows[0])-1</span><br><span class="line">   #不包括最后一列</span><br><span class="line">   for col in range(0,column_count):</span><br><span class="line">      column_values&#x3D;&#123;&#125;</span><br><span class="line">      for row in rows:</span><br><span class="line">          column_values[row[col]]&#x3D;1#获得该col列的值</span><br><span class="line">      #根据该列中的每个值，尝试对数据集进行划分</span><br><span class="line">      for value in column_values.keys():</span><br><span class="line">          (set1,set2)&#x3D;dividest(rows,col,value)</span><br><span class="line">          p&#x3D;float(len(set1))&#x2F;len(rows)</span><br><span class="line">          gain&#x3D;current_score-p*scoref(set1)-(1-p)*scoref(set2)</span><br><span class="line">          if gain&gt;best_gain and len(set1)&gt;0 and len(set2)&gt;0:</span><br><span class="line">              best_gain&#x3D;gain</span><br><span class="line">              best_criteria&#x3D;(col,value)</span><br><span class="line">              best_sets&#x3D;(set1,set2)</span><br><span class="line">    #创建子分支</span><br><span class="line">    if best_gain&gt;0:</span><br><span class="line">       truebranch&#x3D;buildtree(bestsets[0])</span><br><span class="line">       falsebranch&#x3D;buildtree(bestsets[1])</span><br><span class="line">       return decisionnode(col&#x3D;best_criteria[0],</span><br><span class="line">       value&#x3D;best_criteria[1],tb&#x3D;truebranch,fb&#x3D;falsebranch)</span><br><span class="line">    else:</span><br><span class="line">       return decisionnode(results&#x3D;uniquecounts(rows))</span><br></pre></td></tr></table></figure>

<h3 id="决策树的显示"><a href="#决策树的显示" class="headerlink" title="决策树的显示"></a>决策树的显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def printtree(tree,indent&#x3D;&#39; &#39;):</span><br><span class="line">    if tree.results!&#x3D;None:</span><br><span class="line">      print str(tree.results)</span><br><span class="line">    else:</span><br><span class="line">      print str(tree.col)+&#39;:&#39;+str(tree.value)+&#39;?&#39;</span><br><span class="line">      print indent+&#39;T-&gt;&#39;</span><br><span class="line">      printtree(tree.tb,indent+&#39; &#39;)</span><br><span class="line">      print indent+&#39;F-&gt;&#39;</span><br><span class="line">      printtree(tree.fb,indent+&#39; &#39;)</span><br></pre></td></tr></table></figure>
<h3 id="对新的观测数据进行分类"><a href="#对新的观测数据进行分类" class="headerlink" title="对新的观测数据进行分类"></a>对新的观测数据进行分类</h3><p>我们对新的观测数据作为参数，然后根据决策树进行分类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def classify(observation,tree):</span><br><span class="line">    if tree.results!&#x3D;None:</span><br><span class="line">       return tree.results</span><br><span class="line">    else:</span><br><span class="line">       v&#x3D;observation[tree.col]</span><br><span class="line">       branch&#x3D;None</span><br><span class="line">       if isinstance(v,int) or isinstance(v,float):</span><br><span class="line">          if v&gt;&#x3D;tree.value: branch&#x3D;tree.tb</span><br><span class="line">          else: branch&#x3D;tree.fb</span><br><span class="line">       else:</span><br><span class="line">          if v&#x3D;&#x3D;tree.value: branch&#x3D;tree.tb</span><br><span class="line">          else: branch&#x3D;tree.fb</span><br><span class="line">    return classify(observation,branch)</span><br></pre></td></tr></table></figure>
<h3 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h3><p>存在过拟合现象，会比实际情况根据特殊性。它可能是专门针对训练集所创建的分支，其熵值比真实情况低。解决办法：当熵减少的数量小于某个最小值时，我们就停止分支的创建。剪枝就是消除多余的节点。</p>
<p>剪枝的过程就是对具有相同父节点的一组节点进行检查，如果将其合并，熵的增加值是否会小于某个指定的阈值。如果确实如此，则将其合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def prune(tree,mingain):</span><br><span class="line">    #如果分支不是叶节点，则进行剪枝</span><br><span class="line">    if tree.tb.results&#x3D;&#x3D;None:</span><br><span class="line">      prune(tree.tb,mingain)</span><br><span class="line">    if tree.fb.results&#x3D;&#x3D;None:</span><br><span class="line">      prune(tree.fb,mingain)</span><br><span class="line">    #如果两个子分支都是叶节点，则判断它们是否需要合并</span><br><span class="line">    if tree.tb.results!&#x3D;None and tree.fb.results!&#x3D;None</span><br><span class="line">       tb,fb&#x3D;[],[]</span><br><span class="line">       for v,c in tree.tb.results.items():</span><br><span class="line">           tb+&#x3D;[[v]]*c</span><br><span class="line">       for v,c in tree.fb.results.items():</span><br><span class="line">           fb+&#x3D;[[v]]*c    </span><br><span class="line">       delta&#x3D;entrop(tb+fb)-(entropy(tb)+entropy(fb)&#x2F;2)</span><br><span class="line">       if delta&lt;mingain:</span><br><span class="line">          tree.tb,tree.fb&#x3D;None,None</span><br><span class="line">          tree.results&#x3D;uniquecounts(tb,fb)</span><br></pre></td></tr></table></figure>
<h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>加权统计</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def mdclassify(observation,tree):</span><br><span class="line">    if tree.results!&#x3D;None:</span><br><span class="line">       return tree.results</span><br><span class="line">     else:</span><br><span class="line">       v&#x3D;observation[tree.col]</span><br><span class="line">       if v&#x3D;&#x3D;None:</span><br><span class="line">          tr,fr&#x3D;mdclassify(observation,tree.tb),mdclassify(observation,tree.fb)</span><br><span class="line">          tcount&#x3D;sum(tr.values())</span><br><span class="line">          fcount&#x3D;sum(fr.values())</span><br><span class="line">          tw&#x3D;float(tcount)&#x2F;(tcount+fcount)</span><br><span class="line">          ....</span><br></pre></td></tr></table></figure>
<p>决策树最大的优势就在于它可以轻易地对一个受训模型进行解释。决策树可以同时接受分类数据和数值数据作为输入。还允许数据的不确定性分配。对于少数的几种可能的结果有效。本章的决策树只能创建满足“大于\小于”条件的节点。决策树最适合处理的是那些带有分界点的、由大量的分类数据和数值数据共同组成的数据集。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/10/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%96%87%E6%A1%A3%E8%BF%87%E6%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%96%87%E6%A1%A3%E8%BF%87%E6%BB%A4/" class="post-title-link" itemprop="url">集体智慧编程_第六章文档过滤</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-10 06:38:10 / 修改时间：06:38:32" itemprop="dateCreated datePublished" datetime="2020-02-10T06:38:10+08:00">2020-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="文档和单词"><a href="#文档和单词" class="headerlink" title="文档和单词"></a>文档和单词</h3><p>将单词作为特征。将任何非字母类字符为分隔符对文本进行划分，将文本拆分为一个个单词，并转化成小写形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import math</span><br><span class="line">def getwords(doc):</span><br><span class="line">    splitter.re.compile(&#39;\\W*&#39;)</span><br><span class="line">    words&#x3D;[s.lower() for s in splitter.split(doc) if len(s)&gt;2 and len(s)&lt;20]</span><br><span class="line">    #只返回一组不重复的单词</span><br><span class="line">    return dict([(w,1) for w in words])</span><br></pre></td></tr></table></figure>
<h3 id="对分类器进行训练"><a href="#对分类器进行训练" class="headerlink" title="对分类器进行训练"></a>对分类器进行训练</h3><p>首先编写一个代表分类器的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class classifier:</span><br><span class="line">    def __init__(self,getfeatures,filename&#x3D;None):</span><br><span class="line">        #统计特征、分类组合的数量</span><br><span class="line">        self.fc&#x3D;&#123;&#125;</span><br><span class="line">        #统计每个分类中的文档数量</span><br><span class="line">        self.cc&#x3D;&#123;&#125;</span><br><span class="line">        self.getfeatures&#x3D;getfeatures</span><br></pre></td></tr></table></figure>

<p>fc将记录位于各分类中不同特征的数量：</p>
<p>{‘python’:{‘bad’:0,’good’:6},’the’:{‘bad’:3,’good’:3}}</p>
<p>变量cc表示记录各分类被使用次数的字典。getfeatures为从即将被归类的内容项中提取出特征，在本例中就是我们定义过的getwords函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#增加对特征f、分类cat组合的计数值</span><br><span class="line">def incf(self,f,cat):</span><br><span class="line">    self.fc.setdefault(f,&#123;&#125;)</span><br><span class="line">    self.fc[f].setdefault(cat,0)</span><br><span class="line">    self.fc[f][cat]+&#x3D;1</span><br><span class="line">#增加对某一分类的计数值</span><br><span class="line">def incc(self,cat):</span><br><span class="line">    self.cc.setdefault(cat,0)</span><br><span class="line">    self.cc[cat]+&#x3D;1</span><br><span class="line">#某一特征出现在某一分类中的次数</span><br><span class="line">def fcount(self,f,cat):</span><br><span class="line">    if f in self.fc and cat in self.fc[f]:</span><br><span class="line">        return float(self.fc[f][cat])</span><br><span class="line">    return 0</span><br><span class="line">#属于某一分类的内容项</span><br><span class="line">def catcount(self,cat):</span><br><span class="line">    if cat in self.cc:</span><br><span class="line">        return float(self.cc[cat])</span><br><span class="line">    return 0</span><br><span class="line">#所有内容项</span><br><span class="line">def totalcount(self):</span><br><span class="line">    return sum(self.cc.values())</span><br><span class="line">#所有分类的列表</span><br><span class="line">def categories(self):</span><br><span class="line">    return self.cc.keys()</span><br></pre></td></tr></table></figure>
<p>Train方法接受一个内容项和一个分类作为参数。利用getfeatures函数，将内容项拆分为彼此独立的各个特征。利用incf函数，针对该分类为每个特征增加计数值。最后，函数会增加针对该分类的总计数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def train(self,item,cat):</span><br><span class="line">    features&#x3D;self.getfeatures(item)</span><br><span class="line">    #features为拆分出来的单词</span><br><span class="line">    for f in features:</span><br><span class="line">        self.incf(f,cat)</span><br><span class="line">    self.incc(cat)</span><br></pre></td></tr></table></figure>
<p>之前的代码放置在docclass.py中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import docclass</span><br><span class="line">c1&#x3D;docclass.classifier(docclass.getwords)</span><br><span class="line">c1.train(&#39;the quick brown fox jumps over the lazy dog&#39;,&#39;good&#39;)</span><br><span class="line">#代表上述单词分到good类</span><br><span class="line">c1.train(&#39;quick&#39;,&#39;good&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="计算概率"><a href="#计算概率" class="headerlink" title="计算概率"></a>计算概率</h3><p>可以用一个单词在一篇属于某个分类的文档中出现的次数，除以该分类的文档总数，计算出单词在分类中出现的概率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def fprob(self,f,cat):</span><br><span class="line">    if self.catcount(cat)&#x3D;&#x3D;0: return 0</span><br><span class="line">    return self.fcount(f,cat)&#x2F;self.catcount(cat)</span><br></pre></td></tr></table></figure>
<p>fprob概率为条件概率，pr(word|classification),即对于给定的分类某个单词出现的概率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.fprob(&#39;quick&#39;,&#39;good&#39;)</span><br></pre></td></tr></table></figure>
<p>表示一篇good分类的文档中包含该单词的概率为，pr(quick|good)=0.666</p>
<h4 id="从一个合理的推测开始"><a href="#从一个合理的推测开始" class="headerlink" title="从一个合理的推测开始"></a>从一个合理的推测开始</h4><p>上述的算法，对那些极少出现的单词异常敏感。对上述算法进行改进。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def weightedprob(self,f,cat,prf,weight&#x3D;1.0,ap&#x3D;0.5):</span><br><span class="line">    #计算当前概率值</span><br><span class="line">    basicprob&#x3D;prf(f,cat)</span><br><span class="line">    #统计特征在所有分类中出现的次数</span><br><span class="line">    totals&#x3D;sum([self.fcount(f,c) for f in self.categories()])</span><br><span class="line">    #计算加权平均</span><br><span class="line">    bp&#x3D;((weight*ap)+(totals*basicprob))&#x2F;(weight+totals)</span><br><span class="line">    return bp</span><br></pre></td></tr></table></figure>

<h3 id="朴素分类器"><a href="#朴素分类器" class="headerlink" title="朴素分类器"></a>朴素分类器</h3><p>朴素表示将要被组合的概率是彼此独立的。</p>
<h4 id="整片文档的概率"><a href="#整片文档的概率" class="headerlink" title="整片文档的概率"></a>整片文档的概率</h4><p>pr(python|bad)=0.2  </p>
<p>pr(casino|bad)=0.8    </p>
<p>pr(python&amp;casino|bad)=0.16</p>
<p>若计算整片文档，曾江文档中出现的特征概率相乘即可。如下算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#新建一个classifier的子类</span><br><span class="line">class naviebayes(classifier):</span><br><span class="line">      def docprob(self,item,cat):</span><br><span class="line">          features&#x3D;self.getfeatures(item)</span><br><span class="line">          #将所有特征概率相乘</span><br><span class="line">          p&#x3D;1</span><br><span class="line">          for f in features:p*&#x3D;self.weightedprob(f,cat,self,fprob)</span><br><span class="line">          return p</span><br></pre></td></tr></table></figure>

<p>目前我们已经知道如何计算pr(document|category),但我们需要给定一篇文档，它属于某个分类的概率是多少？<br>即pr(category|document),为此我们采用贝叶斯定理。</p>
<h4 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h4><p>pr(category|document)=pr(document|category)*pr(category)/pr(document)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def prob(self,item,cat):</span><br><span class="line">    catprob&#x3D;self.catcount(cat)&#x2F;self.totalcount()</span><br><span class="line">    docprob&#x3D;self.docprob(item,cat)</span><br><span class="line">    return catprob*docprob</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1.prob(&#39;quick rabbit&#39;,&#39;good&#39;)</span><br><span class="line">c1.prob(&#39;quick rabbit&#39;,&#39;bad&#39;)</span><br></pre></td></tr></table></figure>
<p>那个概率大，说明该短语更倾向于那个类。</p>
<h4 id="选择分类"><a href="#选择分类" class="headerlink" title="选择分类"></a>选择分类</h4><p>避免将普通邮件当做垃圾邮件。设定阈值。<br>假设过滤到bad的分类阈值为3，则针对bad分类的概率就必须至少3倍于针对good的概率才行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,getfeatures):</span><br><span class="line">    classifier.__init__(self,getfeatures)</span><br><span class="line">    self.thresholds&#x3D;&#123;&#125;</span><br><span class="line">def setthreshold(self,cat,t):</span><br><span class="line">    self.thresholds[cat]&#x3D;t</span><br><span class="line">def getthreshold(self,cat):</span><br><span class="line">    if cat not in self.thresholds: return 1</span><br><span class="line">    return self.thresholds[cat]</span><br></pre></td></tr></table></figure>
<p>将计算每个分类的概率，从中得到最大值，并将其余次大概率值进行对比，确定是否超过了阈值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def classify(self,item,default&#x3D;None):</span><br><span class="line">    probs&#x3D;&#123;&#125;</span><br><span class="line">    #寻找概率最大的分类</span><br><span class="line">    max&#x3D;0</span><br><span class="line">    for cat in self.categories():</span><br><span class="line">       probs[cat]&#x3D;self.prob(item,cat)</span><br><span class="line">       if probs[cat]&gt;max:</span><br><span class="line">          max&#x3D;probs[cat]</span><br><span class="line">          best&#x3D;cat</span><br><span class="line">    #确保概率值超过阈值*次概率值</span><br><span class="line">    for cat in probs:</span><br><span class="line">      if cat&#x3D;&#x3D;best:continue</span><br><span class="line">      if probs[cat]*self.getthreshold(best)&gt;probs[best]:return default</span><br><span class="line">    return best</span><br></pre></td></tr></table></figure>
<p>我们已经建立起一个完整的文档分类系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1.setthreshold(&#39;bad&#39;,3.0)</span><br><span class="line">c1.classify(&#39;quick money&#39;,default&#x3D;&#39;unknown&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="费舍尔方法"><a href="#费舍尔方法" class="headerlink" title="费舍尔方法"></a>费舍尔方法</h3><p>是前面介绍的朴素贝叶斯的一种替代方案</p>
<h3 id="将经过训练的分类器持久化"><a href="#将经过训练的分类器持久化" class="headerlink" title="将经过训练的分类器持久化"></a>将经过训练的分类器持久化</h3><p>本节中将classifier所用的字典，都替换成一个持久化的数据存储结构。请在classifier中添加一个方法，为该分类器打开数据库，执行建表操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pysqlite2 import dbapi2 as sqlite</span><br><span class="line">def setdb(self,dbfile):</span><br><span class="line">    self.con&#x3D;sqlite.connect(dbfile)</span><br><span class="line">    self.con.execute(&#39;create table if not exists fc(feature,category,count)&#39;)</span><br><span class="line">    self.con.execute(&#39;create table if not exists cc(category,count)&#39;)</span><br></pre></td></tr></table></figure>
<p>如果我们打算将分类器移植到另个数据库上，需要修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#增加对特征f、分类cat组合的计数值</span><br><span class="line">def incf(self,f,cat):</span><br><span class="line">    count&#x3D;self.fcount(f.cat)</span><br><span class="line">    if count&#x3D;&#x3D;0:</span><br><span class="line">       self.con.execute(&quot;insert into fc values(&#39;%s&#39;,&#39;%s&#39;,1)&quot; %(f,cat))</span><br><span class="line">    else:</span><br><span class="line">       self.con.execute(&quot;update fc set count&#x3D;&#39;%d&#39; where feature&#x3D;&#39;%s&#39; and category&#x3D;&#39;%s&#39;&quot;   %(count+1,f,cat))</span><br><span class="line">....</span><br></pre></td></tr></table></figure>


<p>获取所用分类的列表与文档总数的方法也被替换掉。<br>最后添加一条提交语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.con.commit()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.setdb(&#39;test1.db&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="过滤博客订阅源"><a href="#过滤博客订阅源" class="headerlink" title="过滤博客订阅源"></a>过滤博客订阅源</h3><p>我们只希望阅读某个分类的文章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import feedparser</span><br><span class="line">import re</span><br><span class="line">def read(feed,classifier):</span><br><span class="line">    f&#x3D;feedparser.parse(feed)</span><br><span class="line">    for entry in f[&#39;entries&#39;]:</span><br><span class="line">       print...</span><br><span class="line">       print &#39;guess: &#39;+str(classifier.classify(fulltext))</span><br><span class="line">       #请求用户给出正确分类，并据此进行训练</span><br><span class="line">       c1&#x3D;raw_input(&#39;enter category: &#39;)</span><br><span class="line">       classifier.train(fulltext,c1)</span><br></pre></td></tr></table></figure>
<p>略</p>
<h3 id="对特征检测的改进"><a href="#对特征检测的改进" class="headerlink" title="对特征检测的改进"></a>对特征检测的改进</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def entryfeatures(entry):</span><br><span class="line">    splitter.re.compile(&#39;\\W*&#39;)</span><br><span class="line">    f&#x3D;&#123;&#125;</span><br><span class="line">    titlewords&#x3D;[s.lower() for s in splitter.split(entry[&#39;title&#39;]) if len(s)&gt;2 and len(s)&lt;20]</span><br><span class="line">    for w in titlewords:f[&#39;title :&#39;+w]&#x3D;1</span><br><span class="line">    summarywords&#x3D;[s.lower() for s in splitter.split(entry[&#39;summary&#39;]) if len(s)&gt;2 and len(s)&lt;20]</span><br><span class="line">    #统计大写单词</span><br><span class="line">    uc&#x3D;0</span><br><span class="line">    for i in range(len(summarywords)):</span><br><span class="line">        w&#x3D;summarywords[i]</span><br><span class="line">        f[w]&#x3D;1</span><br><span class="line">        if w.isupper():uc+&#x3D;1</span><br><span class="line">        if i&lt;len(summarywords)-1:</span><br><span class="line">           twowords&#x3D;&#39; &#39;.join(summarywords[i:i+1])</span><br><span class="line">           f[twowords]&#x3D;1</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure>
<p>贝叶斯分类器经常被用于文档分类的原因是，它所要求的计算资源更少。但是神经网络和支持向量机有个很大的优势，可以捕捉输入特征之间更为复杂的关系。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/09/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/09/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">集体智慧编程_第五章优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-09 15:18:28 / 修改时间：15:19:12" itemprop="dateCreated datePublished" datetime="2020-02-09T15:18:28+08:00">2020-02-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="组团旅游"><a href="#组团旅游" class="headerlink" title="组团旅游"></a>组团旅游</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">import math</span><br><span class="line">people&#x3D;[(&#39;seymour&#39;,&#39;BOS&#39;),</span><br><span class="line">        (&#39;FRANNY&#39;,&#39;DAL&#39;),</span><br><span class="line">        (&#39;ZOOEY&#39;,&#39;CAK&#39;),</span><br><span class="line">        (&#39;WALT&#39;,&#39;MIA&#39;),</span><br><span class="line">        (&#39;buddy&#39;,&#39;ORD&#39;),</span><br><span class="line">        (&#39;LES&#39;,&#39;OMA&#39;)]</span><br><span class="line">destination&#x3D;&#39;LGA&#39;</span><br></pre></td></tr></table></figure>
<p>航班数据schedule.txt</p>
<p>起点,终点,起飞时间,达到时间,价格</p>
<p>加载数据的代码optimization.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flights&#x3D;&#123;&#125;</span><br><span class="line">for line in file(&#39;schedule.txt&#39;):</span><br><span class="line">    origin,dest,depart,arrive,price&#x3D;line.strip().split(&#39;,&#39;)</span><br><span class="line">    #key:(origin,dest) value:(depart,arrive,price)</span><br><span class="line">    flights.setdefault((origin,dest),[])</span><br><span class="line">    flights[(origin,dest)].append((depart,arrive,int(price)))</span><br><span class="line">def getminutes(t):</span><br><span class="line">    x&#x3D;time.strptime(t,&#39;%H:%M&#39;)</span><br><span class="line">    return x[3]*60+x[4]</span><br><span class="line">    #x[3]为小时数；x[4]为分钟数</span><br></pre></td></tr></table></figure>
<h4 id="描述题解"><a href="#描述题解" class="headerlink" title="描述题解"></a>描述题解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r&#x3D;[1,4,3,2,7,3,6,3,2,4,5,3]</span><br><span class="line">def printschedule(r):</span><br><span class="line">    for d in range(len(r)&#x2F;2):</span><br><span class="line">        name&#x3D;people[d][0]</span><br><span class="line">        origin&#x3D;people[d][1]</span><br><span class="line">        out&#x3D;flights[(origin,destination)][r[2*d]]</span><br><span class="line">        ret&#x3D;flights[(destination,origin)][r[2*d+1]]</span><br><span class="line">        print &#39;%10s%10s %5s-%5s $%3s %5s-%5s $3s&#39;%(name,origin,out[0],out[1],out[2],ret[0],ret[1],ret[2])</span><br></pre></td></tr></table></figure>
<h4 id="成本函数"><a href="#成本函数" class="headerlink" title="成本函数"></a>成本函数</h4><p>返回值越小越好</p>
<p>该函数考察了总的旅行成本以及不同的家庭成员在机场的总的等待时间。如果汽车在租用时间后归还，还会追加50美元罚款。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sol&#x3D;r</span><br><span class="line">def schedulecost(sol):</span><br><span class="line">    totalprice&#x3D;0</span><br><span class="line">    latestarrival&#x3D;0</span><br><span class="line">    earliestdep&#x3D;24*60</span><br><span class="line">    for d in range(len(sol)&#x2F;2):</span><br><span class="line">        origin&#x3D;people[d][1]</span><br><span class="line">        </span><br><span class="line">        outbound&#x3D;flights[(origin,desitination)][int(sol[2*d])]</span><br><span class="line">        returnf&#x3D;flights[(desitination,origin)][int(sol[2*d+1])]</span><br><span class="line">        #总价格:往返航班</span><br><span class="line">        totalprice+&#x3D;outbound[2]</span><br><span class="line">        totalprice+&#x3D;returnf[2]</span><br><span class="line">        #记录最晚达到时间和最早离开时间</span><br><span class="line">        if latestarrival&lt;getminutes(outbound[1]):latestarrival&#x3D;getminutes(outbound[1])</span><br><span class="line">        if earliestdep&gt;getminutes(returnf[0]):earliestdep&#x3D;getminutes(returnf[0])</span><br><span class="line">    #每个人必须在机场等待直到最后一个人达到</span><br><span class="line">    #也必须在相同的时间内达到，并等候他们的返程航班</span><br><span class="line">    totalwait&#x3D;0</span><br><span class="line">    for d in range(len(sol)&#x2F;2):</span><br><span class="line">        origin&#x3D;people[d][1]</span><br><span class="line">        outbound&#x3D;flights[(origin,desitination)][int(sol[2*d])]</span><br><span class="line">        returnf&#x3D;flights[(desitination,origin)][int(sol[2*d+1])]</span><br><span class="line">        totalwait+&#x3D;latestarrival-getminutes(outbound[1])</span><br><span class="line">        totalwait+&#x3D;getminutes(returnf[0])-earliestdep</span><br><span class="line">    if latestarrival&gt;earliestdep: totalprice+&#x3D;50</span><br><span class="line">    return totalprice+totalwait</span><br></pre></td></tr></table></figure>
<h4 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h4><p>它是我们评估其他算法优劣的基线。</p>
<p>domain为每个人往返航班的航班号的总和，航班号为（0,9）之间的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">domain&#x3D;[(0,9)]*(len(optimization.people)*2)</span><br><span class="line">def randomoptimize(domain,costf):</span><br><span class="line">    best&#x3D;99999999</span><br><span class="line">    bestr&#x3D;None</span><br><span class="line">    for i in range(1000):</span><br><span class="line">    #r&#x3D;[1,4,3,2,7,3,6,3,2,4,5,3]</span><br><span class="line">       r&#x3D;[random.randint(domain[i][0],domain[i][1]) for i in range(len(domain))]</span><br><span class="line">       cost&#x3D;costf(r)</span><br><span class="line">       if cost&lt;best:</span><br><span class="line">          best&#x3D;cost</span><br><span class="line">          bestr&#x3D;r</span><br><span class="line">    return r</span><br></pre></td></tr></table></figure>

<h4 id="爬山法"><a href="#爬山法" class="headerlink" title="爬山法"></a>爬山法</h4><p>随机尝试各种题解是非常低效的，没有充分利用已经发现的最优解。<br>先从一个随机的旅行安排方案开始，然后再找到所有与之相邻的安排，亦即找到所有相对于最初的随机安排，能够让每个人乘坐的航班稍早或稍晚一些的安排。我们对相邻的时间安排都进行成本计算，就把最低成本的安排将成为新的题解。直至没有安排能够改善成本为止。</p>
<p>domain为每个人往返航班的航班号的总和，航班号为（0,9）之间的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def hillclimb(domain,costf):</span><br><span class="line">    #创建一个随机解SOL类似r</span><br><span class="line">    sol&#x3D;[random.randint(domain[i][0],domain[i][1]) for i in range(len(domain))]</span><br><span class="line">    #主循环</span><br><span class="line">    while 1:</span><br><span class="line">       #创建相邻解的列表</span><br><span class="line">       neighbors&#x3D;[]</span><br><span class="line">       for j in range(len(domain)):</span><br><span class="line">           #在每个方向上偏离原值</span><br><span class="line">          if sol[j]&gt;domain[j][0]:</span><br><span class="line">          #传入的是一串r，只是改动了sol[j]</span><br><span class="line">              neighbors.append(sol[0:j]+[sol[j]-1]+sol[j+1:])</span><br><span class="line">          if sol[j]&lt;domain[j][0]:</span><br><span class="line">          #传入的是一串r，只是改动了sol[j]</span><br><span class="line">              neighbors.append(sol[0:j]+[sol[j]+1]+sol[j+1:])</span><br><span class="line">        #在邻近点中找最优解</span><br><span class="line">        current&#x3D;costf(sol)</span><br><span class="line">        best&#x3D;current</span><br><span class="line">        for j in range(len(neighbors)):</span><br><span class="line">             cost&#x3D;costf(neighbors[j])</span><br><span class="line">             if cost&lt;best:</span><br><span class="line">                best&#x3D;cost</span><br><span class="line">                sol&#x3D;neighbors[j]</span><br><span class="line">            if best&#x3D;&#x3D;current:</span><br><span class="line">                break</span><br><span class="line">    return sol</span><br></pre></td></tr></table></figure>
<p>输出的sol为最优的初始化r航班表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sol&#x3D;optimization.hillclimb(domain,optimization.schedulecost)</span><br><span class="line">optimization.schedulecost(sol)</span><br><span class="line">#将航班安排表打印</span><br><span class="line">#sol&#x3D;[1,4,3,2,7,3,6,3,2,4,5,3]</span><br><span class="line">optimization.printschedule(sol)</span><br></pre></td></tr></table></figure>
<p>最终结果可能是局部最优不是全局最优解。</p>
<h4 id="模拟退火法"><a href="#模拟退火法" class="headerlink" title="模拟退火法"></a>模拟退火法</h4><p>可以避免陷入局部最优解。</p>
<p>在某些情况下，在我们能够得到一个更优的解之前转向一个更差的解释很有必要的。模拟退火算法不仅因为它会接受一个更优的解，还会因为它在退火过程开始阶段会接受表现较差的值。随着退火的不断进行，算法越来越不可能接受较差的解，直到最后，它只会接受更优的解。<br>该算法只会倾向于一个稍差的解而不会是个非常差的解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def annealingoptimize(domain,costf,T&#x3D;10000,cool&#x3D;0.95.step&#x3D;1):</span><br><span class="line">     #随机初始化值</span><br><span class="line">     vec&#x3D;[float(random.randint(domain[i][0],domain[i][1])) for i in range(len(domain))]</span><br><span class="line">     while T&gt;0.1:</span><br><span class="line">         i&#x3D;random.randint(0,len(domain)-1)</span><br><span class="line">         #选择一个改变索引的方向</span><br><span class="line">         dir&#x3D;random.randint(-step,step)</span><br><span class="line">         </span><br><span class="line">         vecb&#x3D;vec[:]</span><br><span class="line">         vecb[i]+&#x3D;dir</span><br><span class="line">         if vecb[i]&lt;domain[i][0]:vecb[i]&#x3D;domain[i][0]</span><br><span class="line">         elif vecb[i]&gt;domain[i][1]: vecb[i]&#x3D;domain[i][0]</span><br><span class="line">         </span><br><span class="line">         ea&#x3D;costf(vec)</span><br><span class="line">         eb&#x3D;costf(vecb)</span><br><span class="line">         </span><br><span class="line">         if(eb&lt;ea or random.random()&lt;pow(math.e,-(eb-ea)&#x2F;T))</span><br><span class="line">                vec&#x3D;vecb</span><br><span class="line">         T&#x3D;T*cool</span><br><span class="line">    return vec</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sol&#x3D;optimization.annealingoptimize(domain,optimization.schedulecost)</span><br><span class="line">optimization.schedulecost(sol)</span><br><span class="line">#将航班安排表打印</span><br><span class="line">#sol&#x3D;[1,4,3,2,7,3,6,3,2,4,5,3]</span><br><span class="line">optimization.printschedule(sol)</span><br></pre></td></tr></table></figure>
<h4 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h4><p>先随机生成一组解，我们称为种群。</p>
<p>在优化的每一步，算法会计算整个种群的成本函数，从而得到一个有关题解的有序列表。</p>
<p>在对题解进行排序后，一个新的种群被创建出来。</p>
<p>我们将当前题解中位于最顶端的题解加入到其所在的新种群中。称为精英选拔法。</p>
<p>新种群的余下部分是由修改最优解后形成的全新解组成的。<br>修改题解有两个方法：<br>变异：改变某个数字。<br>交叉：按照某种方式进行组合。</p>
<p>重复进行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def geneticoptimize(domain,costf,popsize&#x3D;50,size&#x3D;1,mutprob&#x3D;1,mutprob&#x3D;0.2,elite&#x3D;0.2,maxiter&#x3D;100):</span><br><span class="line">    #变异操作,改变某个数字</span><br><span class="line">    def mutate(vec):</span><br><span class="line">       i&#x3D;random.randint(0,len(domain)-1)</span><br><span class="line">       if random.random()&lt;0.5 and vec[i]&gt;domain[i][0]:</span><br><span class="line">            return vec[0:i]+[vec[i]-step]+vec[i+1:]</span><br><span class="line">        elif vec[i]&lt;domain[i][1]:</span><br><span class="line">            return vec[0:i]+[vec[i]+step]+vec[i+1:]</span><br><span class="line">    #交叉操作</span><br><span class="line">    def crossover(r1,r2):</span><br><span class="line">        i&#x3D;random.random(1,len(domain)-2)</span><br><span class="line">        return r1[0:i]+r2[i:]</span><br><span class="line">    #构造初始种群</span><br><span class="line">    pop&#x3D;[]</span><br><span class="line">    for i in range(popsize):</span><br><span class="line">        vec&#x3D;[random.randint(domain[i][0],domain[i][1]) for i in range(len(domain))]</span><br><span class="line">        pop.append(vec)</span><br><span class="line">    #优胜者</span><br><span class="line">    topelite&#x3D;int(elite*popsize)</span><br><span class="line">    #主循环</span><br><span class="line">    for i in range(maxiter):</span><br><span class="line">         scores&#x3D;[(costf(v),v) for v in pop]</span><br><span class="line">         scores.sort()</span><br><span class="line">         ranked&#x3D;[v for (s,v) in scores]</span><br><span class="line">         </span><br><span class="line">         pop&#x3D;ranked[0:topelite]</span><br><span class="line">         #添加变异和配对后的胜出者</span><br><span class="line">         while len(pop)&lt;popsize:</span><br><span class="line">             if random.randint()&lt;mutprob:</span><br><span class="line">                 c&#x3D;random.random(0,topelite)</span><br><span class="line">                 pop.append(mutate(ranked[c]))</span><br><span class="line">             else:#交叉</span><br><span class="line">                c1&#x3D;random.randint(0,topelite)</span><br><span class="line">                c2&#x3D;random.random(0,topelite)</span><br><span class="line">                pop.append(crossover(ranked[c1],ranked[c2]))</span><br><span class="line">    #打印当前最优值,cost</span><br><span class="line">         print scores[0][0]</span><br><span class="line">    return scores[0][1]#打印种群，即最优的排班表</span><br></pre></td></tr></table></figure>
<p>popsize:种群大小</p>
<p>mutprob：种群中的新成员是由变异而非交叉得来的概率</p>
<p>elite:被认为是最优解且被允许传到下一代的部分</p>
<p>maxtrix:运行运行几代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sol&#x3D;optimization.geneticoptimize(domain,optimization.schedulecost)</span><br><span class="line">optimization.schedulecost(sol)</span><br><span class="line">#将航班安排表打印</span><br><span class="line">#sol&#x3D;[1,4,3,2,7,3,6,3,2,4,5,3]</span><br><span class="line">optimization.printschedule(sol)</span><br></pre></td></tr></table></figure>
<h4 id="真实的航班搜索"><a href="#真实的航班搜索" class="headerlink" title="真实的航班搜索"></a>真实的航班搜索</h4><h5 id="Kayak-API"><a href="#Kayak-API" class="headerlink" title="Kayak API"></a>Kayak API</h5><p>获取Kayak的xml接口</p>
<h5 id="minidom包"><a href="#minidom包" class="headerlink" title="minidom包"></a>minidom包</h5><p>将xml文档当做对象树来看待的标准方式。这个包接受xml的开放文件作为输入，然后返回一个对象，可以利用该对象轻松地提取信息。</p>
<h5 id="航班搜索"><a href="#航班搜索" class="headerlink" title="航班搜索"></a>航班搜索</h5><p>新建一个名为kayak.py的文件：<br>编写代码利用开发者密匙来获得一个新的kayak会话，对xml文件进行解析，以得到sid标签的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import urllib2</span><br><span class="line">import xml.dom.minidom</span><br><span class="line">kayakkey&#x3D;&#39;YOURKEYHERE&#39;</span><br><span class="line">def getkayaksession():</span><br><span class="line">    url&#x3D;&#39;http:&#x2F;&#x2F;www.kayak.com&#x2F;k&#x2F;ident&#x2F;apisession?token%s&amp;version&#x3D;1&#39;%kayakkey</span><br><span class="line">    doc&#x3D;xml.dom.minidom.parseString(urllib2.urlopen(url).read())</span><br><span class="line">    sid&#x3D;doc.getElementsByTagName(&#39;sid&#39;)[0].firstChild.data</span><br><span class="line">    return sid</span><br></pre></td></tr></table></figure>
<h4 id="学生宿舍优化问题"><a href="#学生宿舍优化问题" class="headerlink" title="学生宿舍优化问题"></a>学生宿舍优化问题</h4><p>略</p>
<h4 id="网络可视化"><a href="#网络可视化" class="headerlink" title="网络可视化"></a>网络可视化</h4><p>略</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/08/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%8F%91%E7%8E%B0%E7%BE%A4%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/08/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%8F%91%E7%8E%B0%E7%BE%A4%E7%BB%84/" class="post-title-link" itemprop="url">集体智慧编程_第三章发现群组</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-08 15:16:26 / 修改时间：15:17:28" itemprop="dateCreated datePublished" datetime="2020-02-08T15:16:26+08:00">2020-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本章对上一章中的思想加以扩展，并引入数据聚类的概念，这是一种用以寻找紧密相关的事、人或观点，并将其可视化的方法。</p>
</blockquote>
<h4 id="监督学习和无监督学习"><a href="#监督学习和无监督学习" class="headerlink" title="监督学习和无监督学习"></a>监督学习和无监督学习</h4><p>监督学习法：利用样本的输入和期望输出来学习如何预测的技术。包括神经网络、决策树、向量支持机，以及贝叶斯过滤。</p>
<p>无监督学习算法不是带有正确答案进行训练，目的是在一组数据中找寻某种结构，而这些数据本身不是我们所需要的答案。聚类算法的目标是采集数据，然后从中找出不同的分组。其他无监督学习的例子还包括非负矩阵因式分解和自组织映射。</p>
<h4 id="单词向量"><a href="#单词向量" class="headerlink" title="单词向量"></a>单词向量</h4><h5 id="对博客用户进行分类"><a href="#对博客用户进行分类" class="headerlink" title="对博客用户进行分类"></a>对博客用户进行分类</h5><p>在第一个数据集中，被用来聚类的是排名在前120位的一系列博客，为了对博客进行聚类，我们需要的是一组指定的词汇在每个博客订阅源中出现的次数。<br>根据单词出现的频率对博客进行聚类，或许可以帮助我们分析出是否存在这样一类博客用户，这些人经常撰写相似的主题。</p>
<h5 id="对订阅源中的单词进行计数"><a href="#对订阅源中的单词进行计数" class="headerlink" title="对订阅源中的单词进行计数"></a>对订阅源中的单词进行计数</h5><p>RSS订阅源是一个包含博客及其所有文章条目信息的简单的XML文档。为了给每个博客中的单词进行计数，首先第一就是解析这些订阅源。我们利用universal feed parser，从RSS订阅源中得到标题、链接和文章条目了。</p>
<p>下一步，我们编写从订阅源中提取所有单词的函数，新建一个名为generatefeedvector.py的文件，并加入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import feedparser</span><br><span class="line">import re</span><br><span class="line">#返回一个含订阅源的标题和包含单词个数情况的字典</span><br><span class="line">def getwordcounts(url):</span><br><span class="line">    #解析订阅源</span><br><span class="line">    d&#x3D;feedparser.parse(url)</span><br><span class="line">    wc&#x3D;&#123;&#125;#用来存储在文章中出现的单词和次数</span><br><span class="line">    for e in d.entries:</span><br><span class="line">        if &#39;summary&#39; in e: summary&#x3D;e.summary</span><br><span class="line">        else: summary&#x3D;e.description</span><br><span class="line">        #提取一个单词列表</span><br><span class="line">        #传入的是XML文件</span><br><span class="line">        words&#x3D;getwords(e.title+&#39;&#39;+summary)#摘要</span><br><span class="line">        for word in words:</span><br><span class="line">            wc.setdefault(word,0)</span><br><span class="line">            wc[word]+&#x3D;1</span><br><span class="line">    return d.feed.title,wc</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def getwords(html):</span><br><span class="line">    #去除所有html标记</span><br><span class="line">    txt&#x3D;re.compile(r&#39;&lt;[^&gt;]+&gt;&#39;).sub(&#39;&#39;,html)</span><br><span class="line">    #利用所有非字母字符拆分出单词</span><br><span class="line">    words&#x3D;re.compile(r&#39;[^A-Z^a-z]+&#39;).split(txt)</span><br><span class="line">    #转化成小写形式</span><br><span class="line">    return [word.lower() for word in words if word!&#x3D;&#39;&#39;]</span><br></pre></td></tr></table></figure>
<p>为了开始下一步的工作，我们需要一个订阅源列表。我们从此处下载到列表(<a href="http://kiwitobes.com/clusters/feedlist.txt)这是一个普通的文本文件，每一行对应一个url。" target="_blank" rel="noopener">http://kiwitobes.com/clusters/feedlist.txt)这是一个普通的文本文件，每一行对应一个url。</a></p>
<p>generatefeedvector.py文件中的主体代码循环遍历   订阅源并生成数据集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wordcounts&#x3D;&#123;&#125;#key:文章标题；value:单词以及单词数</span><br><span class="line">apcount&#x3D;&#123;&#125;#为出现这些单词的博客数目</span><br><span class="line">#feedurl表示遍历该文本文件的每一行，是个url文件</span><br><span class="line">feedlist&#x3D;[line for line in file(&#39;feedlist.txt&#39;)]</span><br><span class="line">for feedurl in feedlist:  </span><br><span class="line">    title,wc&#x3D;getwordcounts(feedurl)</span><br><span class="line">    #每个博客对应的字典</span><br><span class="line">    wordcounts[title]&#x3D;wc</span><br><span class="line">    for word,count in wc.items():</span><br><span class="line">        apcount.setdefault(word,0)</span><br><span class="line">        if count&gt;1:  #表示博客中有该单词</span><br><span class="line">           apcount[word]+&#x3D;1</span><br></pre></td></tr></table></figure>
<p>把上述代码添加到generatefeedvector.py文件中。接下来，我们对单词进行筛选，减少要考察的单词的总量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#只是添加所需要的单词</span><br><span class="line">wordlist&#x3D;[]</span><br><span class="line">#apcount的key为单词；value为该单词出现的博客数目</span><br><span class="line">for w,bc in apcount.items():</span><br><span class="line">    frac&#x3D;float(bc)&#x2F;len(feedlist)</span><br><span class="line">    if frac&gt;0.1 and frac&lt;0.5: wordlist.append(w)</span><br></pre></td></tr></table></figure>
<p>最后，我们对上述单词列表和博客列表来建立一个文本文件，包含一个大的矩阵，记录针对每个博客的所有单词的统计情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">out&#x3D;file(&#39;blogdata.txt&#39;,&#39;w&#39;)</span><br><span class="line">out.write(&#39;blog&#39;)</span><br><span class="line">for word in wordlist: out.write(&#39;\t%s&#39; %word)#单词的标题</span><br><span class="line">out.write(&#39;\n&#39;)</span><br><span class="line">for blog,wc in wordcounts.items():#blog为博客标题；wc为该博客中的单词及单词数，需要利用wordlist进行筛选</span><br><span class="line">   out.write(blog)#博客标题</span><br><span class="line">   for word in wordlist:</span><br><span class="line">       if word in wc:out.write(&#39;\t%d&#39;%wc[word])#输出该单词数</span><br><span class="line">       else:out.write(&#39;\t0&#39;)</span><br><span class="line">   #一个博客输出完后换行</span><br><span class="line">   out.write(&#39;\n&#39;)</span><br></pre></td></tr></table></figure>
<p>最后得到blogdata.txt文件</p>
<h4 id="分级聚类"><a href="#分级聚类" class="headerlink" title="分级聚类"></a>分级聚类</h4><p>通过连续不断的将最为相似的群组两两合并，来构造一个群组的层级结构。其中每个群组都是从单一元素开始的。在每次迭代过程中，分级聚类算法会计算每两个群组之间的距离，并将距离最近的两个群组合并在一起成一个新的群组。这个过程会持续下去直到只剩一个群组为止。我们也可以采用树状图来展示他们。</p>
<p>本节我们将示范如何对博客数据集进行聚类，以构造博客的层级结构；如果构造成功，我们将实现按主题对博客进行分组。首先我们需要一个方法来加载数据文件：</p>
<p><strong>在clusters.py文件中。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def readfile(filename):</span><br><span class="line">   #lines表示该文件，若读取每一行则：for l in lines</span><br><span class="line">   lines&#x3D;[line for line in file(filename)]</span><br><span class="line">   #第一行为列标题</span><br><span class="line">   rownames&#x3D;[]#列表</span><br><span class="line">   data&#x3D;[]</span><br><span class="line">   colnames&#x3D;lines[0].strip().split(&#39;\t&#39;)[1:]</span><br><span class="line">   for line in lines[1:]:#从第二行开始读取</span><br><span class="line">      p&#x3D;line.strip().split(&#39;\t&#39;)#将每一行的数据按照空格分隔</span><br><span class="line">      #每行的第一列为行名</span><br><span class="line">      rownames.append(p[0])</span><br><span class="line">      data.append([float(x) for x in p[1:]])</span><br><span class="line">   return rownames,colnames,data</span><br></pre></td></tr></table></figure>
<p>data中的每一项对应数据集中的一行数据；rownames为每行的名字；colnames为每列的名字。</p>
<p>下一步我们来定义紧密度：<br>一些博客总体上比其他博客包含更多的文章条目。皮尔逊相关度可以纠正这一问题，因为他判断的是两组数据与某条直线的拟合程度。<br>在两组完全匹配的情况下，为1.0.毫无关系的情况下为0。<br>皮尔逊算法代码略<br>。</p>
<p>新建一个类，代表聚类的类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class bicluster:</span><br><span class="line">     def __init__(self,vec,left&#x3D;None,right&#x3D;None,distance&#x3D;0.0,id&#x3D;None)</span><br><span class="line">          self.left&#x3D;left</span><br><span class="line">          self.right&#x3D;right</span><br><span class="line">          self.vec&#x3D;vec</span><br><span class="line">          self.id&#x3D;id</span><br><span class="line">          self.distance&#x3D;distance</span><br></pre></td></tr></table></figure>
<p><strong>分级聚类算法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def hcluster(rows,distance&#x3D;person):#rows为readfile中的data</span><br><span class="line">      distances&#x3D;&#123;&#125;</span><br><span class="line">      currentclustid&#x3D;-1</span><br><span class="line">      #最开始聚类的就是数据集中的行</span><br><span class="line">      clust&#x3D;[bicluster(row[i],id&#x3D;i) for i in range(len(rows))]</span><br><span class="line">      while len(clust)&gt;1:</span><br><span class="line">           lowestpair&#x3D;(0,1)</span><br><span class="line">           closest&#x3D;distance(clust[0].vec,clust[1].vec)</span><br><span class="line">           #遍历每个配对，寻找最小距离</span><br><span class="line">           for i in range(len(clust)):</span><br><span class="line">               for j in range(i+1,len(clust)):</span><br><span class="line">                     if (clust[i].id,clust[j].id) not in distances:</span><br><span class="line">                         distances[(clust[i].id,clust[j].id)]&#x3D;distance(clust[i].vec,clust[j].vec)</span><br><span class="line">                    d&#x3D;distances[(clust[i].id,clust[j].id)]#d为value；distances为字典</span><br><span class="line">                    if d&lt;closest:</span><br><span class="line">                         closest&#x3D;d</span><br><span class="line">                         lowersetpair&#x3D;(i,j)</span><br><span class="line">            #计算两个距离的平均值</span><br><span class="line">            mergevec&#x3D;[(clust[lowersetpair[0]].vec[i]+clust[lowersetpair[1]].vec[i])&#x2F;2 for i in range(len(clust[0].vec))]</span><br><span class="line">            #建立新的聚类</span><br><span class="line">            newcluster&#x3D;bicluster(mergevec,left&#x3D;clust[lowestpair[0]],right&#x3D;clust[lowestpair[1]],distance&#x3D;closet,id&#x3D;currentclustid&#x3D;-1)</span><br><span class="line">            currentclustid-&#x3D;1</span><br><span class="line">            del clust[lowestpair[1]]</span><br><span class="line">            del clust[lowestpair[0]]</span><br><span class="line">            clust.append(newcluster)</span><br><span class="line">        return clust[0]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import clusters</span><br><span class="line">blognames,words,data&#x3D;clusters.readfile(&#39;blogdata.txt&#39;)</span><br><span class="line">clust&#x3D;clusters.hcluster(data)</span><br><span class="line">clusters.printclust(clust,label&#x3D;blognames)</span><br></pre></td></tr></table></figure>
<p>打印聚类树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def printclust(clust,labels&#x3D;None,n&#x3D;0):</span><br><span class="line">    #利用缩进来建立层次布局</span><br><span class="line">    for i in range(n):print &#39; &#39;,</span><br><span class="line">    if clust.id&lt;0:</span><br><span class="line">        #负数代表是一个分支</span><br><span class="line">        print&#39;-&#39;</span><br><span class="line">    else:</span><br><span class="line">        #正数代表是个叶节点</span><br><span class="line">        if labels&#x3D;None:print clust.id</span><br><span class="line">        else: print labels[clust.id]#打印博客名字</span><br><span class="line">    if clust.left!&#x3D;None: printclust(clust.left,labels&#x3D;labels,n&#x3D;n+1)</span><br><span class="line">    if clust.right!&#x3D;None: printclust(clust.right,labels&#x3D;labels,n&#x3D;n+1)</span><br></pre></td></tr></table></figure>
<h4 id="绘制树状图"><a href="#绘制树状图" class="headerlink" title="绘制树状图"></a>绘制树状图</h4><p>安装PIL，我利用的是anaconda整合好的<br><img src="D58E94581AD24FFDB486BC5D46052BCC" alt="image"></p>
<p>首先确定聚类的总体高度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image,ImageDraw</span><br><span class="line">def getheight(clust):</span><br><span class="line">    if clust.left&#x3D;&#x3D;None and clust.right&#x3D;&#x3D;None: return 1</span><br><span class="line">    return getheight(clust.left)+getheight(clust.right)</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还需要知道根节点的总体误差。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def getdepth(clust):</span><br><span class="line">    if clust.left&#x3D;&#x3D;None and clust.right&#x3D;&#x3D;None: return 0</span><br><span class="line">    return max(getdepth(clust.left),getdepth(clust.right))+clust.distance</span><br></pre></td></tr></table></figure>
<p>函数drawdendrogram为每个生成的聚类创建一个高度为20像素、宽度固定的图片。</p>
<p>略</p>
<h4 id="列聚类"><a href="#列聚类" class="headerlink" title="列聚类"></a>列聚类</h4><p>之前的算法是对博客类型进行聚类，处理的是博客。现在我们将data矩阵倒置，对单词类型进行聚类。<br>倒置函数：将行和列对调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def rotatematrix(data):</span><br><span class="line">    newdata&#x3D;[]</span><br><span class="line">    for i in range(len(data[0])):</span><br><span class="line">        newrow&#x3D;[data[j][i] for j in range(len(data))]</span><br><span class="line">        newdata.append(newrow)</span><br><span class="line">    return newdata</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import clusters</span><br><span class="line">blognames,words,data&#x3D;clusters.readfile(&#39;blogdata.txt&#39;)</span><br><span class="line">rdata&#x3D;clusters.rotatematrix(data)</span><br><span class="line">wordclust&#x3D;clusters.hcluster(rdata)</span><br><span class="line">clusters.drawdendrogram(wordclust,labels&#x3D;words,jpeg&#x3D;&#39;wordclust.jpg&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="K-均值聚类"><a href="#K-均值聚类" class="headerlink" title="K-均值聚类"></a>K-均值聚类</h4><p>首先确定K个中心位置，然后将各个数据项分配到最邻近的中心点。待分配完成后，聚类中心更新到所有节点的平均位置处。然后整个分配过程重新开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">def kcluster(rows,distance&#x3D;pearson,k&#x3D;4)</span><br><span class="line">   #确定每列的最大值和最小值,每行为一个点</span><br><span class="line">   ranges&#x3D;[(min([row[i] for row in rows]),max([row[i] for row in rows])) for i in range(len(rows[0]))]</span><br><span class="line">   #随机创建k个中心点，每个点为一列数</span><br><span class="line">   clusters&#x3D;[[random.random()*(ranges[i][1]-ranges[i][0])+ranges[i][0] for i in range(len(rows[0]))]for j in range(k)]</span><br><span class="line">   </span><br><span class="line">   lastmatches&#x3D;None</span><br><span class="line">   for t in range(100):#迭代次数</span><br><span class="line">       print &#39;iteration %d&#39; % t</span><br><span class="line">       bestmatches&#x3D;[[] for i in range(k)]</span><br><span class="line">       #在每行中寻找最近的中心点</span><br><span class="line">       for j in range(len(rows)):</span><br><span class="line">       #第j行</span><br><span class="line">            row&#x3D;rows[j]</span><br><span class="line">            bestmatch&#x3D;0</span><br><span class="line">            for i in range(k):</span><br><span class="line">               d&#x3D;distance(clusters[i],row)</span><br><span class="line">               if d&lt;distance(clusters[bestmatch],row):bestmatch&#x3D;i</span><br><span class="line">            bestmatches[bestmatch].append(j)</span><br><span class="line">            #直到所有行都确定了最近的中心点</span><br><span class="line">        if bestmatches&#x3D;&#x3D;lastmatches:break</span><br><span class="line">        lastmatches&#x3D;bestmatches</span><br><span class="line">        #把中心点移到所有成员的平均位置处</span><br><span class="line">        for i in range(k):</span><br><span class="line">            avgs&#x3D;[0.0]*len(rows[0])</span><br><span class="line">            if(len(bestmatches[i])&gt;0:</span><br><span class="line">                for rowid in bestmatches[i]:</span><br><span class="line">                    for m in range(len(rows[rowid]))</span><br><span class="line">                       avgs[m]+&#x3D;rows[rowid][m]</span><br><span class="line">                for j in range(len(avgs)):</span><br><span class="line">                    avgs[j]&#x2F;&#x3D;len(bestmatches[i])</span><br><span class="line">                clusters[i]&#x3D;avgs</span><br><span class="line">    return bestmatches</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reload(clusters)</span><br><span class="line">blognames,words,data&#x3D;clusters.readfile(&#39;blogdata.txt&#39;)</span><br><span class="line">kclust&#x3D;clusters.kclusters(data,k&#x3D;10)</span><br><span class="line">#分成了k&#x3D;0,1,...9类别，输出同类别的电影名</span><br><span class="line">[blognames[r] for r in kclust[0]]</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/07/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%8F%90%E4%BE%9B%E6%8E%A8%E8%8D%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/07/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%8F%90%E4%BE%9B%E6%8E%A8%E8%8D%90/" class="post-title-link" itemprop="url">集体智慧编程_第二章提供推荐</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-07 22:04:59 / 修改时间：22:06:09" itemprop="dateCreated datePublished" datetime="2020-02-07T22:04:59+08:00">2020-02-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="协作型推荐"><a href="#协作型推荐" class="headerlink" title="协作型推荐"></a>协作型推荐</h3><p>一个协作型过滤算法是对一大群人进行搜索，并从中找出与我们品味相近的小群人。算法会对这些人所偏爱的其他内容进行考察，并将他们组合起来构造出一个经过排名的推荐列表。</p>
<h3 id="搜集偏好"><a href="#搜集偏好" class="headerlink" title="搜集偏好"></a>搜集偏好</h3><p>我们通过采用嵌套的字典的方法来表达不同人及其偏好的方法。</p>
<p>我们建立一个数据集,命名为recommendations.py 采用1到5的评分，来体现包括本人在内的每位影评者对某给定影片的喜爱程度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from recommendations import critics</span><br><span class="line">critics[&#39;Lisa Rose&#39;][&#39;Lady in the Water&#39;]</span><br><span class="line">#输出Lisa Rose对Lady in the water这部电影的评分。</span><br></pre></td></tr></table></figure>
<h3 id="寻找相近的用户"><a href="#寻找相近的用户" class="headerlink" title="寻找相近的用户"></a>寻找相近的用户</h3><p>在搜集完人们的偏好后，即建立数据集后，我们需要一种方法来确定人民在品味中的相似程度。我们可以将每个人与所有其他人进行对比，并计算他们的相似度评价值。</p>
<h5 id="欧几里得距离评价"><a href="#欧几里得距离评价" class="headerlink" title="欧几里得距离评价"></a>欧几里得距离评价</h5><p>1/(1+sqrt(pow(x1-x2,2)+pow(y1-y2,2)))</p>
<p>上述值越大，表示越相似。</p>
<p>prefs表示数据集名称；person1表示数据集中的key;item表示下一级电影名称；prefs[preson1][item]表示分数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line">#返回一个有关person1与person2的基于距离的相似度评价</span><br><span class="line">def sim_distance(prefs,person1,person2):</span><br><span class="line">    si&#x3D;&#123;&#125;</span><br><span class="line">    for item in prefs[person1]:</span><br><span class="line">        if item in prefs[person2]:  #表示两个人都有电影重合</span><br><span class="line">           si[item]&#x3D;1 #item是key;1是value</span><br><span class="line">    if len(si)&#x3D;&#x3D;0:</span><br><span class="line">        return 0</span><br><span class="line">    #计算两个人中重合的电影中评分的差值的平方和</span><br><span class="line">    sum_of_squares&#x3D;sum([pow(prefs[person1][item]-prefs[preson2][item],2) for item in prefs[person1] if item in prefs[person2]])</span><br><span class="line">    return 1&#x2F;(sqrt(sum_of_squares)+1)</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reload(recommendations)</span><br><span class="line">recommendations.sim_distance(recommendations.critics,&#39;Lisa Rose&#39;,&#39;Gene Seymour&#39;)</span><br><span class="line">#输出相似度数字</span><br></pre></td></tr></table></figure>
<h5 id="皮尔逊相关度评价"><a href="#皮尔逊相关度评价" class="headerlink" title="皮尔逊相关度评价"></a>皮尔逊相关度评价</h5><p>该相关系数是判断两组数据与某一直线拟合程度的一种度量，在数据不是很规范的情况下，会倾向给出更好的结果。<br>它可修正夸大分值的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line">#返回一个有关person1与person2的基于距离的相似度评价</span><br><span class="line">def sim_person(prefs,p1,p2):</span><br><span class="line">    si&#x3D;&#123;&#125;</span><br><span class="line">    for it in prefs[p1]:</span><br><span class="line">        if it in prefs[p2]:  #表示两个人都有电影重合</span><br><span class="line">           si[it]&#x3D;1 #item是key;1是value</span><br><span class="line">    if len(si)&#x3D;&#x3D;0:</span><br><span class="line">        return 0</span><br><span class="line">    #对所有偏好进行求和</span><br><span class="line">    sum1&#x3D;sum([prefs[p1][it] for it in si])</span><br><span class="line">    sum2&#x3D;sum([prefs[p2][it] for it in si])</span><br><span class="line">    #求平方和</span><br><span class="line">    sum1sq&#x3D;sum([pow(prefs[p1][it],2) for it in si])</span><br><span class="line">    sum2sq&#x3D;sum([pow(prefs[p2][it],2) for it in si])</span><br><span class="line">    #求乘积和</span><br><span class="line">    psum&#x3D;sum([prefs[p1][it]*prefs[p2][it] for it in si])</span><br><span class="line">    #计算皮尔逊评价值</span><br><span class="line">    num&#x3D;psum-(sum1*sum2&#x2F;n)</span><br><span class="line">    den&#x3D;sqrt((sum1sq-pow(sum1,2)&#x2F;n)*(sum2sq-pow(sum2,2)&#x2F;n))</span><br><span class="line">    if den&#x3D;&#x3D;0:</span><br><span class="line">       return 0</span><br><span class="line">    r &#x3D; num&#x2F;den</span><br><span class="line">    </span><br><span class="line">    return r</span><br></pre></td></tr></table></figure>
<h4 id="为评论者打分"><a href="#为评论者打分" class="headerlink" title="为评论者打分"></a>为评论者打分</h4><p>我们将下列函数加入recommendation.py中，以得到一个人员的有序列表，这些人与某个指定人员具有相似的品味。</p>
<p>prefs为数据集；person为某个指定人员；similarity为某个相似度函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def topmatches(prefs,person,n&#x3D;5,similarity&#x3D;sim_person):</span><br><span class="line">#将指定人员与数据中除自己外的所有人员一一比较，记录相似度值。</span><br><span class="line">    scores &#x3D; [(similarity(prefs[person],other),other) for other in prefs for other in prefs if other !&#x3D; person]</span><br><span class="line">    #评价最高者排在最前面</span><br><span class="line">    scores.sort()</span><br><span class="line">    scores.reverse()</span><br><span class="line">    return scores[0:n]  #输出前三个数</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#topmatches为函数；critics为数据集；recommendations.py为函数</span><br><span class="line">reload(recommendations)</span><br><span class="line">recommendations.topmatches(recommendations.critics,&#39;Toby&#39;,n&#x3D;3)</span><br></pre></td></tr></table></figure>

<p>输出的是与目标人员兴趣最相近的其他人员。</p>
<h4 id="推荐物品"><a href="#推荐物品" class="headerlink" title="推荐物品"></a>推荐物品</h4><p>如果我们利用为评论者打分算法，得到口味最相近的其他人，在他的电影清单中选择，未免有点随意。本部分之间推荐与目标人员兴趣匹配的最佳电影。输出的是电影。 我们利用数据集，得到所有其他评论者与指定人员的相似度之后，再用相似度乘以他们对每部影片的评分，再把加权后的每部影片相加，除以相似度之和，对最终数据从高到低排序，得到最终的推荐影片排序。</p>
<p>与topmatches对比，输出不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#利用所有其他人评价值的加权平均，为某人提供建议</span><br><span class="line">def getrecommendations(prefs,person,similarity&#x3D;sim_person)</span><br><span class="line">    totals&#x3D;&#123;&#125;#为每部影片的加权后的总和</span><br><span class="line">    simsums&#x3D;&#123;&#125;#为其他人相似度的总和</span><br><span class="line">    #prefs为数据集</span><br><span class="line">    for other in prefs:</span><br><span class="line">       #不和自己做比较,person为指定人员</span><br><span class="line">       if other&#x3D;&#x3D;person:continue</span><br><span class="line">       sim&#x3D;similarity(prefs,person,other)#sim为相似度</span><br><span class="line">       #忽略评价值为零或小于零的情况</span><br><span class="line">       if sim&lt;&#x3D;0:continue</span><br><span class="line">       #item为电影</span><br><span class="line">       for item in prefs[other]:</span><br><span class="line">            if item not in prefs[person] or prefs[person][item]&#x3D;&#x3D;0:</span><br><span class="line">                totals.setdefault(item,0)</span><br><span class="line">                total[item]+&#x3D;prefs[other][item]*sim</span><br><span class="line">                simsums.setdefault(item,0)</span><br><span class="line">                simsums[item]+&#x3D;sim</span><br><span class="line">   ranking&#x3D;[(total&#x2F;simsums[item],item) for item,total in totals.items()]</span><br><span class="line">   </span><br><span class="line">   ranking.sort()</span><br><span class="line">   ranking.reverse()</span><br><span class="line">   return ranking</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reload(recommendations)</span><br><span class="line">recommendations.getcommendations(recommendations.critics,&#39;Toby&#39;)</span><br></pre></td></tr></table></figure>
<p>输出的是推荐的相似度高的电影。</p>
<h4 id="匹配商品-人与物交换"><a href="#匹配商品-人与物交换" class="headerlink" title="匹配商品(人与物交换)"></a>匹配商品(人与物交换)</h4><p>假如我们想了解哪些产品是相近的呢？在这种情况下，我们可以通过哪些人喜欢某一特定物品，以及这些喜欢哪些其他物品来决定相似度。即我们把之前的例子，人与物品互换即可。</p>
<p>人与物品互换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def transformprefs(prefs):  #prefs为数据集</span><br><span class="line">    result&#x3D;&#123;&#125;  #result为与prefs类似的数据集</span><br><span class="line">    for person in prefs:</span><br><span class="line">        for item in prefs[person]:</span><br><span class="line">             result.setdefault(item,&#123;&#125;)</span><br><span class="line">             result[item][person]&#x3D;prefs[person][item]</span><br><span class="line">    return result#新的数据集</span><br></pre></td></tr></table></figure>
<p>获取与《superman returns》最类似的电影</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reload(recommendations)</span><br><span class="line">#movies为新的数据集</span><br><span class="line">movies&#x3D;recomms.transformprefs(recommendations.critics)</span><br><span class="line">recommendations.topmatches(movies,&#39;superman returns&#39;)</span><br></pre></td></tr></table></figure>
<p>我们还可以为该影片推荐评论者，或许我们考虑要求某人参加该电影的首映礼。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reload(recommendations)</span><br><span class="line">#movies为新的数据集</span><br><span class="line">movies&#x3D;recomms.transformprefs(recommendations.critics)</span><br><span class="line">recommendations.getrecommendations(movies,&#39;superman returns&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>在线零售商可以收集{person:{item1,item2}},将商品和人对调，可以帮助他们找到购买某个商品的潜在用户。此外，在专门推荐链接的网站上，可以确保新出现的链接，能够被那些最有可能对它产生兴趣的用户找到。</p>
<h4 id="构建一个基于del-icio-us的链接推荐系统"><a href="#构建一个基于del-icio-us的链接推荐系统" class="headerlink" title="构建一个基于del.icio.us的链接推荐系统"></a>构建一个基于del.icio.us的链接推荐系统</h4><p>本节将介绍，如何从最受欢迎的在线书签网站上获取数据，如何利用这些数据查找相近的用户，并向他们推荐一起未曾看过的链接。</p>
<p>但是这个API已经失效了！！<br>故放弃</p>
<h4 id="使用MOVIELENS数据集做推荐"><a href="#使用MOVIELENS数据集做推荐" class="headerlink" title="使用MOVIELENS数据集做推荐"></a>使用MOVIELENS数据集做推荐</h4><p>  下载MovieLens的地址：<a href="http://grouplens.org/datasets/movielens/" target="_blank" rel="noopener">http://grouplens.org/datasets/movielens/</a>  </p>
<p>  数据集中的格式为：用户ID、影片ID、用户对该片的评分、评价时间</p>
<p>  加载数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def loadMovieLensTrain(filename&#x3D;&#39;u1.base&#39;):</span><br><span class="line"></span><br><span class="line">    str1 &#x3D;&#39;.&#x2F;ml-100k&#x2F;&#39;     </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    #加载数据</span><br><span class="line"></span><br><span class="line">    prefs&#x3D;&#123;&#125;</span><br><span class="line"></span><br><span class="line">    for line in open(str1+filename,&#39;r&#39;):</span><br><span class="line"></span><br><span class="line">        (user,movieid,rating,ts)&#x3D;line.split(&#39;\t&#39;)</span><br><span class="line"></span><br><span class="line">        prefs.setdefault(user,&#123;&#125;)</span><br><span class="line"></span><br><span class="line">        prefs[user][movieid]&#x3D;float(rating)</span><br><span class="line"></span><br><span class="line">    return prefs</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def loadMovieLensTest(filename&#x3D;&#39;u1.test&#39;):                      </span><br><span class="line"></span><br><span class="line">    str1 &#x3D;&#39;.&#x2F;ml-100k&#x2F;&#39;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    #加载数据</span><br><span class="line"></span><br><span class="line">    prefs&#x3D;&#123;&#125;</span><br><span class="line"></span><br><span class="line">    for line in open(str1+filename,&#39;r&#39;):</span><br><span class="line"></span><br><span class="line">        (user,movieid,rating,ts)&#x3D;line.split(&#39;\t&#39;)</span><br><span class="line"></span><br><span class="line">        prefs.setdefault(user,&#123;&#125;)</span><br><span class="line"></span><br><span class="line">        prefs[user][movieid]&#x3D;float(rating)</span><br><span class="line"></span><br><span class="line">    return prefs             </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">    print (&quot;&quot;&quot;这个部分可以进行上面2个函数测试&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    trainDict&#x3D; loadMovieLensTrain()</span><br><span class="line"></span><br><span class="line">    testDict &#x3D; loadMovieLensTest()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    print (len(trainDict))</span><br><span class="line"></span><br><span class="line">    print (len(testDict))</span><br><span class="line"></span><br><span class="line">    print (&quot;&quot;&quot;测试通过&quot;&quot;&quot;)</span><br></pre></td></tr></table></figure>
<p>在该数据集中，建立字典，key为用户，value为电影和评分，与之前的critics数据集类似。</p>
<p><a href="https://blog.csdn.net/luzuiwutong/article/details/42718375" target="_blank" rel="noopener">参考链接</a></p>
<p>测试结果如下：<br>2为用户ID；306为某个电影ID;4.0为该电影的评分<br><img src="FECD665D69B741648ECD1B0B35D71D16" alt="image"><br>为用户28号推荐电影前20部<br><img src="FF37059EE8AB4593901CACED812E8747" alt="image"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/05/Implementing-Recurrent-Neural-Network-from-Scratch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/05/Implementing-Recurrent-Neural-Network-from-Scratch/" class="post-title-link" itemprop="url">Implementing Recurrent Neural Network from Scratch </a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-05 07:11:48 / 修改时间：07:38:59" itemprop="dateCreated datePublished" datetime="2020-02-05T07:11:48+08:00">2020-02-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/pangolulu/rnn-from-scratch" target="_blank" rel="noopener">Implementing Recurrent Neural Network from Scratch</a><br><img src="E1005AF131584DCF92EE6F2DDDEC316B" alt="2"><br><img src="EA04062A53C340DDB36F56245668566C" alt="草稿-3"><br><img src="5FE421509C9649D382385B7C079807B2" alt="草稿-4"><br><img src="27F66B26BFFC4E0A8E325A8F7B97D73E" alt="草稿-5"><br><img src="38FEA3EF46014D14B67B4F30D1BEAA4E" alt="草稿-6"><br><img src="725497E49B3644FAA316F103787E730B" alt="草稿-7"><br><img src="AB2D1AFE7E774376B5EB64A2A1BF33BF" alt="草稿-8"><br><img src="806CDBB1EA9442D4827F373CEA9D1E28" alt="草稿-9"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/04/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/04/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">数据预处理部分代码</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-04 17:46:04 / 修改时间：17:46:32" itemprop="dateCreated datePublished" datetime="2020-02-04T17:46:04+08:00">2020-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-文本格式数据读写"><a href="#1-文本格式数据读写" class="headerlink" title="1.文本格式数据读写"></a>1.文本格式数据读写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df&#x3D;pd.read.csv(&#39;examples&#x2F;ex1.csv&#39;)</span><br></pre></td></tr></table></figure>
<h5 id="添加表头"><a href="#添加表头" class="headerlink" title="添加表头"></a>添加表头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df&#x3D;pd.read.csv(&#39;examples&#x2F;ex1.csv&#39;，names&#x3D;[&#39;a&#39;,&#39;b&#39;],index_col&#x3D;&#39;message&#39;)</span><br></pre></td></tr></table></figure>
<h5 id="传入一个分层索引"><a href="#传入一个分层索引" class="headerlink" title="传入一个分层索引"></a>传入一个分层索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df&#x3D;pd.read.csv(&#39;examples&#x2F;ex1.csv&#39;，index_col&#x3D;[&#39;key1&#39;,&#39;key2&#39;])</span><br></pre></td></tr></table></figure>
<p>当字段是以多种不同数量的空格符分开时，可以传入正则表达式作为分隔符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df&#x3D;pd.read.csv(&#39;examples&#x2F;ex1.csv&#39;，seq&#x3D;&#39;\s+&#39;)</span><br></pre></td></tr></table></figure>
<p>使用skiprows来跳过0，2，3行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df&#x3D;pd.read.csv(&#39;examples&#x2F;ex1.csv&#39;，skiprows&#x3D;[0,2,3])</span><br></pre></td></tr></table></figure>
<h5 id="分块读入文本文件"><a href="#分块读入文本文件" class="headerlink" title="分块读入文本文件"></a>分块读入文本文件</h5><p>在尝试大文件前，先进行设置使之更为紧凑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.options.display.max_rows&#x3D;10</span><br></pre></td></tr></table></figure>
<p>分块读取文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chunker&#x3D;df&#x3D;pd.read.csv(&#39;examples&#x2F;ex1.csv&#39;，chunksize&#x3D;1000)</span><br><span class="line">tot&#x3D;pd.Series([])</span><br><span class="line">for piece in chunker:</span><br><span class="line">     tot&#x3D;tot.add(piece[&#39;key&#39;].value_counts(),fill_value&#x3D;0)</span><br><span class="line">tot&#x3D;tot.sort_values(ascending&#x3D;False)</span><br></pre></td></tr></table></figure>

<h3 id="2-数据清洗与准备"><a href="#2-数据清洗与准备" class="headerlink" title="2.数据清洗与准备"></a>2.数据清洗与准备</h3><h4 id="2-1处理缺失值"><a href="#2-1处理缺失值" class="headerlink" title="2.1处理缺失值"></a>2.1处理缺失值</h4><h5 id="2-1-1过滤缺失值"><a href="#2-1-1过滤缺失值" class="headerlink" title="2.1.1过滤缺失值"></a>2.1.1过滤缺失值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from numpy import nan as NA</span><br><span class="line">data &#x3D; pd.Series([1,NA,3.5,NA,7])</span><br><span class="line">data.dropna()  #过滤掉缺失值</span><br></pre></td></tr></table></figure>
<p>data.dropna()会删掉包括缺失值的行</p>
<p>data.dropna(how=’all’) 仅会删除所有制均为NA的行</p>
<p>如果要删除列，则data.dropna(axis=1,how=’all’)</p>
<p>对矩阵进行重新赋值，利用iloc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df&#x3D;pd.DataFrame(np.random.randn(7,3))</span><br><span class="line">df.iloc[:4,1]&#x3D;NA  #前四行，第二列</span><br><span class="line">df.dropna(thresh&#x3D;2)</span><br></pre></td></tr></table></figure>
<h5 id="2-1-2补全缺失值"><a href="#2-1-2补全缺失值" class="headerlink" title="2.1.2补全缺失值"></a>2.1.2补全缺失值</h5><p>主要使用fillna方法来补全缺失值，可以使用一个常数来代替缺失值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(0)</span><br></pre></td></tr></table></figure>
<p>在调用fillna时，使用字典，可以为不同的列设置不同的填充值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(&#123;1:0.5,2:0&#125;)</span><br></pre></td></tr></table></figure>
<p>利用均值来填充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(df.mean())</span><br></pre></td></tr></table></figure>
<h4 id="2-2数据转换"><a href="#2-2数据转换" class="headerlink" title="2.2数据转换"></a>2.2数据转换</h4><p>替代值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data&#x3D;pd.Series([1.,-999.,2.,-999.,-1000.,3.])</span><br><span class="line">data.replace(-999,np.nan)</span><br><span class="line">data.replace([-999,-1000],np.nan)</span><br><span class="line">#将不同的值替换成不同的值</span><br><span class="line">data.replace([-999,-1000],[np.nan,0])</span><br></pre></td></tr></table></figure>
<p>离散化和分箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age&#x3D;[...]</span><br><span class="line">bin&#x3D;[1,2,3,4,5,6]</span><br><span class="line">cats&#x3D;pd.cut(age,bin)</span><br></pre></td></tr></table></figure>
<p>检测和过滤异常值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data&#x3D;pd.DataFrame(np.random.randn(1000,4))</span><br><span class="line">data.describe()</span><br></pre></td></tr></table></figure>
<p>假设要找出某一列中绝对值大于三的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col&#x3D;data[2]</span><br><span class="line">col[np.abs(col)&gt;3]</span><br></pre></td></tr></table></figure>
<p>要选出所有值绝对值大于三，可以使用any方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[(np.abs(data)&gt;3).any(1)]</span><br></pre></td></tr></table></figure>
<p>下面代码限制了-3到3之间的数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[np.abs(data)&gt;3]&#x3D;np.sign(data)*3</span><br><span class="line">+1&#x2F;-1</span><br></pre></td></tr></table></figure>














      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ah</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ah</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
