<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://annen-stack.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="annen&#39;s blog">
<meta property="og:url" content="https://annen-stack.github.io/index.html">
<meta property="og:site_name" content="annen&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ah">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://annen-stack.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>annen's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">annen's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/28/stacks-and-queues/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/28/stacks-and-queues/" class="post-title-link" itemprop="url">stacks and queues</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-28 20:06:47 / 修改时间：20:07:38" itemprop="dateCreated datePublished" datetime="2020-02-28T20:06:47+08:00">2020-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-stacks"><a href="#1-stacks" class="headerlink" title="1.stacks"></a>1.stacks</h2><h4 id="1-利用数组表示栈"><a href="#1-利用数组表示栈" class="headerlink" title="1.利用数组表示栈"></a>1.利用数组表示栈</h4><p><img src="https://img-blog.csdnimg.cn/20200228193658452.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-利用链表表示栈"><a href="#2-利用链表表示栈" class="headerlink" title="2.利用链表表示栈"></a>2.利用链表表示栈</h4><p><img src="https://img-blog.csdnimg.cn/20200228193757676.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2-resizing-arrays"><a href="#2-resizing-arrays" class="headerlink" title="2.resizing arrays"></a>2.resizing arrays</h2><p><img src="https://img-blog.csdnimg.cn/20200228193947919.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200228194018175.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-queues"><a href="#3-queues" class="headerlink" title="3.queues"></a>3.queues</h2><h4 id="3-1利用链表表示队列"><a href="#3-1利用链表表示队列" class="headerlink" title="3.1利用链表表示队列"></a>3.1利用链表表示队列</h4><p><img src="https://img-blog.csdnimg.cn/20200228194106108.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-generics"><a href="#4-generics" class="headerlink" title="4.generics"></a>4.generics</h2><p>泛型</p>
<h4 id="4-1-使用链表实现的栈泛化"><a href="#4-1-使用链表实现的栈泛化" class="headerlink" title="4.1 使用链表实现的栈泛化"></a>4.1 使用链表实现的栈泛化</h4><p><img src="https://img-blog.csdnimg.cn/20200228194556406.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-2使用数组实现的栈泛化"><a href="#4-2使用数组实现的栈泛化" class="headerlink" title="4.2使用数组实现的栈泛化"></a>4.2使用数组实现的栈泛化</h4><p><img src="https://img-blog.csdnimg.cn/20200228194656196.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-iterators"><a href="#3-iterators" class="headerlink" title="3.iterators"></a>3.iterators</h2><p><img src="https://img-blog.csdnimg.cn/20200228194933565.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200228194945260.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="Interview-Questions-Stacks-and-Queues"><a href="#Interview-Questions-Stacks-and-Queues" class="headerlink" title="Interview Questions: Stacks and Queues"></a>Interview Questions: Stacks and Queues</h4><ol>
<li>利用两个栈来实现队列，具体方法为：入队等同于栈A进栈；出队时如果栈B不空，则栈B出栈，如果栈B为空，则依次将栈A元素出栈，并压入栈B。(因Stack被官方不推荐，采用LinkedList来实现栈结构)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    LinkedList&lt;E&gt; stackA;</span><br><span class="line">    LinkedList&lt;E&gt; stackB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		stackA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stackB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackA.isEmpty() &amp;&amp; stackB.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        stackA.push(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackB.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stackA.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stackA.isEmpty()) &#123;</span><br><span class="line">                E temp = stackA.pop();</span><br><span class="line">                stackB.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackB.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackA.size() + stackB.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.维护两个栈来实现输出最大值：一个为普通栈stack，一个用于保存与当前普通栈中元素相对应的最大值栈maxStack。push新元素x时，如果当前maxStack为空，或者x值大于等于maxStack栈顶元素，说明x是加入后普通栈中的最大值，需要在maxStack入栈；pop栈顶元素x时，如果x与maxStack栈顶元素相同，说明x正是当前普通栈中的最大值，也需要在maxStack出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; maxStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        maxStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxStack.isEmpty() || x &gt;= maxStack.peek()) &#123;</span><br><span class="line">            maxStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意不能用stack.peek()==maxStack.peek()进行判断，</span></span><br><span class="line">        <span class="comment">// 这样做比较的是Integer对象本身而不是int值</span></span><br><span class="line">        <span class="keyword">int</span> max = maxStack.peek();</span><br><span class="line">        <span class="keyword">if</span> (stack.peek() == max) &#123;</span><br><span class="line">            maxStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Deques-and-Randomized-Queues"><a href="#Deques-and-Randomized-Queues" class="headerlink" title="Deques and Randomized Queues"></a>Deques and Randomized Queues</h4><p>Deque.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.utol.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node first=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Node last=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Deque</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> first==<span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addfirst</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(item==<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">		Node oldfirst=first;</span><br><span class="line">		first=<span class="keyword">new</span> Node();</span><br><span class="line">		first.item=item;</span><br><span class="line">		<span class="keyword">if</span>(oldfirst==<span class="keyword">null</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			first=last;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		oldlast.prev=first;</span><br><span class="line">		first.next=oldfisrt;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//入队</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addlast</span><span class="params">(String item)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(item==<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">		Node oldlast=last;</span><br><span class="line">		last=<span class="keyword">new</span> Node();</span><br><span class="line">		last.item=item;</span><br><span class="line">		last.next=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(oldlast==<span class="keyword">null</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			first=last;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		oldlast.next=last;</span><br><span class="line">		last.prev=oldlast;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//出队</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Item <span class="title">removeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">		Item item=first.item;</span><br><span class="line">		first=first.next;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) last=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">else</span> first.prev=<span class="keyword">null</span>;</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> item;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Item <span class="title">removelast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">		Item item=last.item;</span><br><span class="line">		last=last.prev;</span><br><span class="line">		<span class="keyword">if</span>(last==<span class="keyword">null</span>) first=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">else</span> last.next=<span class="keyword">null</span>;</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> item;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DequeIterator();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		Item item;</span><br><span class="line">		Node next;</span><br><span class="line">		Node prev;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DequeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Node current=first;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> current!=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">			Item item=current.item;</span><br><span class="line">			current=current.next;</span><br><span class="line">			<span class="keyword">return</span> item;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">// 需要调用构造器和所有的公开方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; dq = <span class="keyword">new</span> Deque&lt;&gt;();</span><br><span class="line">        dq.addFirst(<span class="string">"1"</span>);</span><br><span class="line">        dq.addLast(<span class="string">"2"</span>);</span><br><span class="line">        dq.addFirst(<span class="string">"3"</span>);</span><br><span class="line">        dq.addLast(<span class="string">"4"</span>);</span><br><span class="line">        System.out.println(dq.size());</span><br><span class="line">        dq.removeFirst();</span><br><span class="line">        dq.removeLast();</span><br><span class="line">        System.out.println(dq.isEmpty());</span><br><span class="line">        Iterator&lt;String&gt; it = dq.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RandomizedQueue.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="comment">//resizing-array(分摊时间) generic</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedQueue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">private</span> Item[] s;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造一个空的随机队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RandomizedQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		s=(Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];<span class="comment">//s=new String[1]数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(item==<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(N==s.length) resize(<span class="number">2</span>*s.length);</span><br><span class="line">		s[N++]=item;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> random=StdRandom.uniform(N);</span><br><span class="line">		Item res=s[random];</span><br><span class="line">		s[random]=s[--N];</span><br><span class="line">		s[N]=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(N&gt;<span class="number">0</span>&amp;&amp;N==s.length/<span class="number">4</span>) resize(s.length/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Item <span class="title">sample</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> random = StdRandom.uniform(N);</span><br><span class="line">        <span class="keyword">return</span> s[random];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RQIterator();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RQIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Item[] temp=(Item[])<span class="keyword">new</span> Object[N];</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> size=N;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">RQIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				temp[i]=s[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> size&gt;<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> random=StdRandom.uniform(size);</span><br><span class="line">			Item res=temp[random];</span><br><span class="line">			temp[random]=temp[--size];</span><br><span class="line">			temp[size]=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Item[] temp = (Item[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            temp[i] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// unit testing (required)</span></span><br><span class="line">    <span class="comment">// 需要调用构造器和所有的公开方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomizedQueue&lt;String&gt; rq = <span class="keyword">new</span> RandomizedQueue&lt;&gt;();</span><br><span class="line">        rq.push(<span class="string">"1"</span>);</span><br><span class="line">        rq.push(<span class="string">"2"</span>);</span><br><span class="line">        rq.push(<span class="string">"3"</span>);</span><br><span class="line">        rq.push(<span class="string">"4"</span>);</span><br><span class="line">        System.out.println(rq.size());</span><br><span class="line">        System.out.println(rq.sample());</span><br><span class="line">        rq.pop();</span><br><span class="line">        System.out.println(rq.isEmpty());</span><br><span class="line">        Iterator&lt;String&gt; it = rq.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Permutation.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdIn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomizedQueue&lt;String&gt; rq = <span class="keyword">new</span> RandomizedQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> k = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 实际需要读取的个数n并没有给出</span></span><br><span class="line">        <span class="keyword">while</span> (!StdIn.isEmpty()) &#123;</span><br><span class="line">            rq.push(StdIn.readString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            System.out.println(rq.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/mapoos/article/details/94630416?ops_request_misc=%7B%22request_id%22:%22158288020519724846462237%22,%22scm%22:%2220140713.130056874..%22%7D&request_id=158288020519724846462237&biz_id=0&utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">reference</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/28/Union-Find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/28/Union-Find/" class="post-title-link" itemprop="url">Union-Find</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-28 20:04:04 / 修改时间：20:06:04" itemprop="dateCreated datePublished" datetime="2020-02-28T20:04:04+08:00">2020-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="动态联通性问题描述："><a href="#动态联通性问题描述：" class="headerlink" title="动态联通性问题描述："></a>动态联通性问题描述：</h3><p> 有N个元素，开始时我们让每一个元素肚子构成一个集合。然后按一定的顺序将属于同一组中的元素合并，构成新的集合。其间要反复查询某个元素在哪个集合中。如下所示：<br> <img src="https://img-blog.csdn.net/20140921144613479" alt="在这里插入图片描述"></p>
<h4 id="（1）Quick-Find"><a href="#（1）Quick-Find" class="headerlink" title="（1）Quick-Find"></a>（1）Quick-Find</h4><p> 声明一个长度为N的数组id，数组中元素的值代表它所属组的编号。将数组中的元素初始化为每个元素的索引值，这样就表示开始时每个元素各自构成一个独立的集合。每次union(i,j)的时候就将所有组编号等于id[i]的元素的组编号变为id[j]。每次查询元素i的组编号时，返回id[i]即可。<br><img src="https://img-blog.csdn.net/20140921145625203" alt="在这里插入图片描述"><br>时间复杂度分析：union操作的时间复杂度为O(n)，find操作的时间复杂度为O(1)</p>
<h4 id="2-Quick-Union"><a href="#2-Quick-Union" class="headerlink" title="(2) Quick-Union"></a>(2) Quick-Union</h4><p>同样是声明一个长度为N的int型数组id。但与Quick-Find方法不同的是，Quick-Union让每一个集合中的元素构成一棵树。</p>
<p>每一个元素对应的id存的是自己在树上的父节点。在执行union(i,j)操作时，<strong>将i元素所在树的根指向j所在元素的根</strong>。在查询元素i的id时，<strong>返回元素i所在集合的树的根节点index即可</strong>。<br><img src="https://img-blog.csdn.net/20140921150920010" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20140921151224230" alt="在这里插入图片描述"></p>
<p>时间复杂度分析：union操作的时间复杂度为O(n),find的时间复杂度为O(n).</p>
<h4 id="（3）Weighted-Quick-Union"><a href="#（3）Weighted-Quick-Union" class="headerlink" title="（3）Weighted Quick-Union"></a>（3）Weighted Quick-Union</h4><p>为了防止构建树的过程中出现tall trees，我们记录每个集合的大小。每次union的时候将小集合对应树的根链接到大集合所对应树的根上。<br><img src="https://img-blog.csdn.net/20140921151956272" alt="
"></p>
<p>时间复杂度分析：union操作的时间复杂度为lg(n),find操作的时间复杂度为lg(n).</p>
<h4 id="4-Path-compression-Quick-Union"><a href="#4-Path-compression-Quick-Union" class="headerlink" title="(4) Path compression Quick-Union"></a>(4) Path compression Quick-Union</h4><p>我们将p指向root路径上的每个节点都展开指向root。<br><img src="https://img-blog.csdnimg.cn/20200227220811668.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="性能总结"><a href="#性能总结" class="headerlink" title="性能总结"></a>性能总结</h4><p><img src="https://img-blog.csdnimg.cn/20200227220852406.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Programming-Assignment-Percolation"><a href="#Programming-Assignment-Percolation" class="headerlink" title="Programming Assignment : Percolation"></a>Programming Assignment : Percolation</h3><p><a href="https://blog.evernightfireworks.com/princeton_algorithms_percolation/" target="_blank" rel="noopener">reference</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.WeightedQuickUnionUF;<span class="comment">//直接调用WeightedQuickUnion算法API</span></span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percolation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> status[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> WeightedQuickUnionUF UF;</span><br><span class="line">    <span class="keyword">private</span> WeightedQuickUnionUF UFTop;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;<span class="comment">//将方格（row,col）转换成一个数字</span></span><br><span class="line">        <span class="keyword">return</span> (row-<span class="number">1</span>)*size+col;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;<span class="comment">//判断方格是否过界</span></span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">1</span>||col&lt;<span class="number">1</span>||row&gt;size||col&gt;size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index out of bounds"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;<span class="comment">//判断方格是否打开</span></span><br><span class="line">        <span class="keyword">return</span> status[pos]==<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> aPos,<span class="keyword">int</span> bPos,WeightedQuickUnionUF aUF)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!aUF.connected(aPos,bPos))<span class="comment">//若两点未连接</span></span><br><span class="line">            aUF.union(aPos,bPos);<span class="comment">//则直接union</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instantiates a new Percolation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n the n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Percolation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//初始化n*n个方格</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal argument"</span>);</span><br><span class="line">        size=n;</span><br><span class="line"> </span><br><span class="line">        status = <span class="keyword">new</span> <span class="keyword">boolean</span>[n * n + <span class="number">2</span>];<span class="comment">//加上虚拟方格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n*n+<span class="number">1</span>;i++)</span><br><span class="line">            status[i]=<span class="keyword">false</span>;<span class="comment">//n*n个方格关闭</span></span><br><span class="line">        status[<span class="number">0</span>]=status[n*n+<span class="number">1</span>]=<span class="keyword">true</span>;<span class="comment">//虚拟方格打开</span></span><br><span class="line">        UF=<span class="keyword">new</span> WeightedQuickUnionUF(n*n+<span class="number">2</span>);</span><br><span class="line">        UFTop=<span class="keyword">new</span> WeightedQuickUnionUF(n*n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Open.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row the row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col the col</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        checkBounds(row, col);</span><br><span class="line">        <span class="keyword">if</span>(isOpen(row,col))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> nowPos=getPosition(row,col);</span><br><span class="line">        <span class="keyword">int</span> prevRowPos=getPosition(row-<span class="number">1</span>,col),nextRowPos=getPosition(row+<span class="number">1</span>,col),</span><br><span class="line">                prevColPos=getPosition(row,col-<span class="number">1</span>),nextColPos=getPosition(row,col+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        status[nowPos]=<span class="keyword">true</span>;<span class="comment">//将该方格打开</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">1</span>)&#123;<span class="comment">//该方格位于第一行，连接顶层的虚拟方格</span></span><br><span class="line">            union(<span class="number">0</span>,nowPos,UF);</span><br><span class="line">            union(<span class="number">0</span>,nowPos,UFTop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isOpen(prevRowPos))&#123;<span class="comment">//将该方格与位于其下边的方格连接</span></span><br><span class="line">            union(nowPos,prevRowPos,UF);</span><br><span class="line">            union(nowPos,prevRowPos,UFTop);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(row==size)&#123;<span class="comment">//该方格位于最后一行，连接底层的虚拟方格</span></span><br><span class="line">            union(size*size+<span class="number">1</span>,nowPos,UF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isOpen(nextRowPos))<span class="comment">//将该方格与位于其上边的方格连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            union(nowPos,nextRowPos,UF);</span><br><span class="line">            union(nowPos, nextRowPos, UFTop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col!=<span class="number">1</span>&amp;&amp;isOpen(prevColPos))&#123;<span class="comment">//如果该方格未位于最左侧，则将其与左侧打开的方格连接</span></span><br><span class="line">            union(nowPos, prevColPos, UF);</span><br><span class="line">            union(nowPos, prevColPos, UFTop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (col!= size &amp;&amp; isOpen(nextColPos)) &#123;<span class="comment">//如果该方格未位于最右侧，则将其与右侧打开的方格连接</span></span><br><span class="line">            union(nowPos,nextColPos,UF);</span><br><span class="line">            union(nowPos,nextColPos,UFTop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is full boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row the row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col the col</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>&#123;<span class="comment">//判断该方格与顶层虚拟方格是否联通</span></span><br><span class="line">        checkBounds(row,col);</span><br><span class="line">        <span class="keyword">return</span> UFTop.connected(<span class="number">0</span>, getPosition(row, col));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is open boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row the row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col the col</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        checkBounds(row,col);</span><br><span class="line">        <span class="keyword">return</span> isOpen(getPosition(row,col));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of open sites int.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfOpenSites</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;size*size+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            count+=(status[i]==<span class="keyword">true</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Percolates boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">percolates</span><span class="params">()</span> </span>&#123; <span class="comment">//判断底层虚拟方格与顶层虚拟方格是否联通</span></span><br><span class="line">        <span class="keyword">return</span> UF.connected(<span class="number">0</span>,size*size+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entry point of application.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the input arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StdOut.println(<span class="string">"This is a simple check for pecolation!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdStats;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdIn;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2017/3/31.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//采用蒙特卡洛算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercolationStats</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] attemps;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instantiates a new Percolation stats.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> N      the n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> trails the trails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PercolationStats</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> trails)</span> </span>&#123;<span class="comment">//N为矩阵长度，trails为试验次数</span></span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">0</span> || trails &lt;= <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Argument!"</span>);</span><br><span class="line">        attemps = <span class="keyword">new</span> <span class="keyword">double</span>[trails];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trails; i++) &#123;</span><br><span class="line">            Percolation checkPerco = <span class="keyword">new</span> Percolation(N);<span class="comment">//初始化方格，全设置为关闭状态</span></span><br><span class="line">            <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!checkPerco.percolates()) &#123;<span class="comment">//表示顶层节点与底层节点未联通，直到联通，统计开放状态的方格个数</span></span><br><span class="line">                <span class="keyword">int</span> row = StdRandom.uniform(N) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> column = StdRandom.uniform(N) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!checkPerco.isOpen(row, column)) &#123;</span><br><span class="line">                    checkPerco.open(row, column);<span class="comment">//随机使某个方格开放</span></span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            attemps[i] = (<span class="keyword">double</span>) step / (N * N);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entry point of application.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the input arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = StdIn.readInt();</span><br><span class="line">        <span class="keyword">int</span> T = StdIn.readInt();</span><br><span class="line">        PercolationStats ps = <span class="keyword">new</span> PercolationStats(N, T);</span><br><span class="line">        StdOut.printf(<span class="string">"%-25s= %.7f\n"</span>, <span class="string">"mean"</span>, ps.mean());</span><br><span class="line">        StdOut.printf(<span class="string">"%-25s= %.17f\n"</span>, <span class="string">"stddev"</span>, ps.stddev());</span><br><span class="line">        StdOut.printf(<span class="string">"%-25s= [%.15f, %.15f]\n"</span>, <span class="string">"95% confidence interval"</span>,</span><br><span class="line">                ps.confidenceLo(), ps.confidenceHi());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mean double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StdStats.mean(attemps);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stddev double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stddev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StdStats.stddev(attemps);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Confidence lo double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceLo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mean() - ((<span class="number">1.96</span> * stddev())) / Math.sqrt(attemps.length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Confidence hi double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mean() + ((<span class="number">1.96</span> * stddev())) / Math.sqrt(attemps.length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/26/%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">用python进行数据清理（下）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-26 12:39:45 / 修改时间：12:41:17" itemprop="dateCreated datePublished" datetime="2020-02-26T12:39:45+08:00">2020-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="不规则的数据-异常值"><a href="#不规则的数据-异常值" class="headerlink" title="不规则的数据(异常值)"></a>不规则的数据(异常值)</h3><p>离群值是与其他观测结果有显著区别的数据。它们可能是真正的异常值或错误。</p>
<p>根据特征是数值型的还是分类型的，我们可以使用不同的技术来研究其分布以检测离群值。</p>
<h4 id="1-柱状图-箱线图"><a href="#1-柱状图-箱线图" class="headerlink" title="1.柱状图/箱线图"></a>1.柱状图/箱线图</h4><p>当特征是数值型时，我们可以使用直方图和箱形图来检测离群值。<br>下面是特征life_sq的直方图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'life_sq'</span>].hist(bins=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>为了更深入地研究这个特性，让我们做一个方框图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.boxplot(column=[<span class="string">'life_sq'</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200226110529744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在这个图中，我们可以看到这个特征有超过7000的离群值。</p>
<h4 id="2-描述统计"><a href="#2-描述统计" class="headerlink" title="2.描述统计"></a>2.描述统计</h4><p>此外，对于数值特性，异常值可能太明显，以至于箱形图无法将它们可视化。相反，我们可以看看它们的描述性统计。</p>
<p>例如，对于特性life_sq，我们可以看到最大值是7478，而该特征中75%的数只有43。故7478值是一个离群值。</p>
<p><img src="https://img-blog.csdnimg.cn/2020022611111775.JPG" alt="在这里插入图片描述"></p>
<h4 id="3-长条图"><a href="#3-长条图" class="headerlink" title="3.长条图"></a>3.长条图</h4><p>当特征是分类的。我们可以用柱状图来了解它的种类和分布。<br>例如，特征生态具有合理的分布。但是如果有一个类别只有一个值叫做“other”，那么它就是一个离群值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'ecology'</span>].value_counts().plot.bar()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200226112110522.JPG" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200226112041579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-其他技术"><a href="#4-其他技术" class="headerlink" title="4.其他技术"></a>4.其他技术</h4><p>许多其他技术也可以发现离群值，比如散点图、z分数和聚类。</p>
<p>虽然异常值不难检测，但我们必须确定正确的解决方案来处理它们。它高度依赖于数据集和项目目标。<br>处理异常值的方法在某种程度上类似于丢失的数据。我们要么放弃，要么调整，要么保留它们。我们可以返回到遗漏的数据部分以获得可能的解决方案。</p>
<h3 id="不必要的数据"><a href="#不必要的数据" class="headerlink" title="不必要的数据"></a>不必要的数据</h3><p>在为丢失的数据和异常值做了这么多工作之后，让我们看看不必要的数据，这更简单。<br>所有输入模型的数据都应该服务于项目的目的。不必要的数据是当数据没有增加价值的时候。由于不同的原因，我们涵盖了三种主要的不必要的数据类型。</p>
<h4 id="不必要数据的类型1：不提供信息-重复"><a href="#不必要数据的类型1：不提供信息-重复" class="headerlink" title="不必要数据的类型1：不提供信息/重复"></a>不必要数据的类型1：不提供信息/重复</h4><p>有时，一个特性是无信息性的，因为它有太多行是相同的值。</p>
<p>我们可以创建一个具有相同值的高百分比的特性列表。<br>例如，我们在下面指定以显示超过95%观察值的相同值（false/no/0）的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">num_rows &#x3D; len(df.index)#观察值个数</span><br><span class="line">low_information_cols &#x3D; [] #</span><br><span class="line"></span><br><span class="line">for col in df.columns:</span><br><span class="line">    cnts &#x3D; df[col].value_counts(dropna&#x3D;False)#no</span><br><span class="line">    top_pct &#x3D; (cnts&#x2F;num_rows).iloc[0]</span><br><span class="line">    </span><br><span class="line">    if top_pct &gt; 0.95:</span><br><span class="line">        low_information_cols.append(col)</span><br><span class="line">        print(&#39;&#123;0&#125;: &#123;1:.5f&#125;%&#39;.format(col, top_pct*100))</span><br><span class="line">        print(cnts)</span><br><span class="line">        print()</span><br></pre></td></tr></table></figure>
<p>我们可以逐个研究这些变量，看看它们是否提供了有用的信息。</p>
<p><img src="https://img-blog.csdnimg.cn/2020022611334267.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>我们需要了解重复特征背后的原因。当它们真的不能提供信息时，我们可以把它们扔掉。</p>
<h4 id="不必要数据的类型2-不相关"><a href="#不必要数据的类型2-不相关" class="headerlink" title="不必要数据的类型2:不相关"></a>不必要数据的类型2:不相关</h4><p>同样，数据需要为项目提供有价值的信息。如果特性与我们试图在项目中解决的问题不相关，那么它们就是不相关的。</p>
<p>我们需要浏览特性来识别不相关的特性。<br>例如，一个记录多伦多气温的功能并不能提供任何有用的洞见来预测俄罗斯的房价。</p>
<p>当特性不能满足项目目标时，我们可以删除该特征。</p>
<h4 id="不必要数据的类型3：重复的数据"><a href="#不必要数据的类型3：重复的数据" class="headerlink" title="不必要数据的类型3：重复的数据"></a>不必要数据的类型3：重复的数据</h4><p>重复数据是指相同观测数据的副本存在。</p>
<p>当观察到的所有特征值都相同时，这种重复就会发生。很容易找到。<br>我们首先删除数据集中的唯一标识符id。然后我们通过删除重复项来创建一个名为df_dedupped的数据集。我们比较两个数据集(df和df_dedupped)的形状，以找出重复的行数。</p>
<p>类型1：基于特征</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df_dedupped = df.drop(<span class="string">'id'</span>, axis=<span class="number">1</span>).drop_duplicates()</span><br><span class="line"></span><br><span class="line"><span class="comment"># there were duplicate rows</span></span><br><span class="line">print(df.shape)</span><br><span class="line">print(df_dedupped.shape)</span><br></pre></td></tr></table></figure>

<p>类型2：基于关键特征</p>
<p>有时，基于一组惟一标识符删除重复的数据会更好。<br>例如，在相同的面积、相同的价格和相同的构建年份中，两个事务同时发生的几率接近于零。<br>我们可以设置一组关键特性作为事务的惟一标识符。我们包括时间戳、full_sq、life_sq、楼层、build_year、num_room、price_doc。我们检查是否有重复的基础上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key = [<span class="string">'timestamp'</span>, <span class="string">'full_sq'</span>, <span class="string">'life_sq'</span>, <span class="string">'floor'</span>, <span class="string">'build_year'</span>, <span class="string">'num_room'</span>, <span class="string">'price_doc'</span>]</span><br><span class="line"></span><br><span class="line">df.fillna(<span class="number">-999</span>).groupby(key)[<span class="string">'id'</span>].count().sort_values(ascending=<span class="literal">False</span>).head(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以根据关键特性删除这些重复项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key = [<span class="string">'timestamp'</span>, <span class="string">'full_sq'</span>, <span class="string">'life_sq'</span>, <span class="string">'floor'</span>, <span class="string">'build_year'</span>, <span class="string">'num_room'</span>, <span class="string">'price_doc'</span>]</span><br><span class="line">df_dedupped2 = df.drop_duplicates(subset=key)</span><br><span class="line"></span><br><span class="line">print(df.shape)</span><br><span class="line">print(df_dedupped2.shape)</span><br></pre></td></tr></table></figure>

<h3 id="非一致的数据"><a href="#非一致的数据" class="headerlink" title="非一致的数据"></a>非一致的数据</h3><p>让数据集遵循特定的标准来适应模型也是非常重要的。我们需要用不同的方式来探究数据，找出不一致的数据。很多时候，这取决于观察和经验。没有设置代码来运行和修复它们。</p>
<h4 id="不一致的类型1-大小写"><a href="#不一致的类型1-大小写" class="headerlink" title="不一致的类型1:大小写"></a>不一致的类型1:大小写</h4><p>在分类值中使用大小写不一致是一个常见的错误。因为Python中的分析是区分大小写的，所以它可能会导致问题。</p>
<p>让我们看看sub_area特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#39;sub_area&#39;].value_counts(dropna&#x3D;False)</span><br></pre></td></tr></table></figure>
<p>它存储不同区域的名称，并且看起来非常标准化。</p>
<p>但有时在同一功能中存在大小写使用不一致的情况。“Poselenie Sosenskoe”和“Poselenie sosenskeo”可以指同一个区域。</p>
<p><img src="https://img-blog.csdnimg.cn/202002261156180.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>为了避免这种情况，我们可以将所有的字母放在小写字母(或大写字母)中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[&#39;sub_area_lower&#39;] &#x3D; df[&#39;sub_area&#39;].str.lower()</span><br><span class="line">df[&#39;sub_area_lower&#39;].value_counts(dropna&#x3D;False)</span><br></pre></td></tr></table></figure>
<h4 id="不一致的类型2-格式"><a href="#不一致的类型2-格式" class="headerlink" title="不一致的类型2:格式"></a>不一致的类型2:格式</h4><p>我们需要执行的另一个标准化是数据格式。<strong>一个例子是将特性从字符串转换为DateTime格式。</strong></p>
<p>特性时间戳是字符串格式的，而它表示日期。</p>
<p>我们可以使用下面的代码转换它并提取日期或时间值。在此之后，可以更容易地分析按年或按月划分的事务量组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'timestamp_dt'</span>] = pd.to_datetime(df[<span class="string">'timestamp'</span>], format=<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">df[<span class="string">'year'</span>] = df[<span class="string">'timestamp_dt'</span>].dt.year</span><br><span class="line">df[<span class="string">'month'</span>] = df[<span class="string">'timestamp_dt'</span>].dt.month</span><br><span class="line">df[<span class="string">'weekday'</span>] = df[<span class="string">'timestamp_dt'</span>].dt.weekday</span><br><span class="line"></span><br><span class="line">print(df[<span class="string">'year'</span>].value_counts(dropna=<span class="literal">False</span>))</span><br><span class="line">print()</span><br><span class="line">print(df[<span class="string">'month'</span>].value_counts(dropna=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure>
<h4 id="不一致类型3-分类值"><a href="#不一致类型3-分类值" class="headerlink" title="不一致类型3:分类值"></a>不一致类型3:分类值</h4><p>不一致的分类值是我们最后讨论的不一致类型。分类特征的值是有限的。有时可能会因为拼写错误等原因而产生其他值。</p>
<p>我们需要观察这个特性来找出这种不一致性。让我们用一个例子来说明这一点。<br>我们在下面创建一个新的数据集，因为我们在不动产数据集中没有这样的问题。</p>
<p>例如，city的值被错误地输入为“torontoo”和“tronto”。但是它们都指向正确的值“toronto”。<br>识别它们的一个简单方法是模糊逻辑(或编辑距离)。它度量我们需要多少字母(距离)来更改一个值的拼写以匹配另一个值。</p>
<p>我们知道，类别应该只有“多伦多”、“温哥华”、“蒙特利尔”和“卡尔加里”四个值。我们计算所有值与单词“toronto”(和“vancouver”)之间的距离。我们可以看到，可能是拼写错误的单词与正确的单词之间的距离更小。因为它们只相差几个字母。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.metrics <span class="keyword">import</span> edit_distance</span><br><span class="line"></span><br><span class="line">df_city_ex = pd.DataFrame(data=&#123;<span class="string">'city'</span>: [<span class="string">'torontoo'</span>, <span class="string">'toronto'</span>, <span class="string">'tronto'</span>, <span class="string">'vancouver'</span>, <span class="string">'vancover'</span>, <span class="string">'vancouvr'</span>, <span class="string">'montreal'</span>, <span class="string">'calgary'</span>]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df_city_ex[<span class="string">'city_distance_toronto'</span>] = df_city_ex[<span class="string">'city'</span>].map(<span class="keyword">lambda</span> x: edit_distance(x, <span class="string">'toronto'</span>))</span><br><span class="line">df_city_ex[<span class="string">'city_distance_vancouver'</span>] = df_city_ex[<span class="string">'city'</span>].map(<span class="keyword">lambda</span> x: edit_distance(x, <span class="string">'vancouver'</span>))</span><br><span class="line">df_city_ex</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020022612261545.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>我们可以设置条件将这些拼写转换为正确的值。例如，下面的代码将距离“toronto”两个字母以内的所有值设置为“toronto”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msk = df_city_ex[<span class="string">'city_distance_toronto'</span>] &lt;= <span class="number">2</span></span><br><span class="line">df_city_ex.loc[msk, <span class="string">'city'</span>] = <span class="string">'toronto'</span></span><br><span class="line"></span><br><span class="line">msk = df_city_ex[<span class="string">'city_distance_vancouver'</span>] &lt;= <span class="number">2</span></span><br><span class="line">df_city_ex.loc[msk, <span class="string">'city'</span>] = <span class="string">'vancouver'</span></span><br><span class="line"></span><br><span class="line">df_city_ex</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200226122416301.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="不一致类型4-地址"><a href="#不一致类型4-地址" class="headerlink" title="不一致类型4:地址"></a>不一致类型4:地址</h4><p>地址功能可能会让我们很多人头疼。因为在数据库中输入数据的人通常不遵循标准格式。</p>
<p>我们可以通过查看来找到混乱的地址数据。即使有时我们不能发现任何问题，我们仍然可以运行代码来标准化它们。<br>由于隐私原因，我们的数据集中没有地址列。因此，我们创建了一个新的数据集df_add_ex，它具有特征地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_add_ex = pd.DataFrame([<span class="string">'123 MAIN St Apartment 15'</span>, <span class="string">'123 Main Street Apt 12   '</span>, <span class="string">'543 FirSt Av'</span>, <span class="string">'  876 FIRst Ave.'</span>], columns=[<span class="string">'address'</span>])</span><br><span class="line">df_add_ex</span><br></pre></td></tr></table></figure>
<p>正如我们所看到的，地址功能相当混乱。</p>
<p>我们运行以下代码进行小写字母、删除空白、删除句点和标准化改写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df_add_ex[<span class="string">'address_std'</span>] = df_add_ex[<span class="string">'address'</span>].str.lower()</span><br><span class="line">df_add_ex[<span class="string">'address_std'</span>] = df_add_ex[<span class="string">'address_std'</span>].str.strip() <span class="comment"># remove leading and trailing whitespace.</span></span><br><span class="line">df_add_ex[<span class="string">'address_std'</span>] = df_add_ex[<span class="string">'address_std'</span>].str.replace(<span class="string">'\\.'</span>, <span class="string">''</span>) <span class="comment"># remove period.</span></span><br><span class="line">df_add_ex[<span class="string">'address_std'</span>] = df_add_ex[<span class="string">'address_std'</span>].str.replace(<span class="string">'\\bstreet\\b'</span>, <span class="string">'st'</span>) <span class="comment"># replace street with st.</span></span><br><span class="line">df_add_ex[<span class="string">'address_std'</span>] = df_add_ex[<span class="string">'address_std'</span>].str.replace(<span class="string">'\\bapartment\\b'</span>, <span class="string">'apt'</span>) <span class="comment"># replace apartment with apt.</span></span><br><span class="line">df_add_ex[<span class="string">'address_std'</span>] = df_add_ex[<span class="string">'address_std'</span>].str.replace(<span class="string">'\\bav\\b'</span>, <span class="string">'ave'</span>) <span class="comment"># replace apartment with apt.</span></span><br><span class="line"></span><br><span class="line">df_add_ex</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200226122925807.JPG" alt="在这里插入图片描述"></p>
<p><a href="https://towardsdatascience.com/data-cleaning-in-python-the-ultimate-guide-2020-c63b88bf0a0d" target="_blank" rel="noopener">Data Cleaning in Python: the Ultimate Guide (2020)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/25/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89/" class="post-title-link" itemprop="url">利用python进行数据清理（上）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-25 23:43:48 / 修改时间：23:44:36" itemprop="dateCreated datePublished" datetime="2020-02-25T23:43:48+08:00">2020-02-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>数据清理是从数据集、表或数据库中检测和纠正(或删除)损坏或不准确的记录的过程，指的是识别数据中不完整、不正确、不准确或不相关的部分，然后进行替换、修改或删除不干净或者粗糙的数据。</p>
</blockquote>
<p><a href="https://towardsdatascience.com/data-cleaning-in-python-the-ultimate-guide-2020-c63b88bf0a0d" target="_blank" rel="noopener">Data Cleaning in Python: the Ultimate Guide (2020)</a></p>
<p>为了使它更简单，我们用Python创建了这个新的完整的分步指南。你将学习如何寻找和清洁的技术:</p>
<ul>
<li>数据缺失</li>
<li>数据不规则（异常值）</li>
<li>非必要的数据（如重复值）</li>
<li>非一致的数据</li>
</ul>
<p>在本指南中，我们使用了<a href="https://storage.googleapis.com/kaggle-competitions-data/kaggle-v2/6392/44054/bundle/archive.zip?GoogleAccessId=web-data@kaggle-161607.iam.gserviceaccount.com&Expires=1582898738&Signature=fQlTg6qKwc5ZEWESiu5YnzJmG0lXEMMPrWlypLK6%2FXAQgflwJW8f64LL9zsIvn68CJctd4Mx4VE8PGOUr9db2Df5tsfO0EHzQw8nMewzzIxXqUUpvQL1IfAVu2Pl%2BhUqOkRPAdbXH4utugaJpRH86WbyGI0rdNd0iYM9HQk3kRLyUhhf1n8OezNROuTmNP9UbkjDyFz0snuGX3bbVon08SqQxgJ0xy%2FDp2ucyq%2FP%2BRsT3DBRgFiEpKFtC3P8FvW10OwNM3oQPrwZB2UPPbdCQ%2BaWeilrC0KXhoe0OsmJhriBy6T4AQK%2B4a8kN%2BNqZU%2FGiMb2gdmAd%2FrXCuBmJneNPQ%3D%3D&response-content-disposition=attachment%3B+filename%3Dsberbank-russian-housing-market.zip" target="_blank" rel="noopener">来自Kaggle的俄罗斯住房数据集</a>。这个项目的目标是预测俄罗斯的房价波动。我们不清理整个数据集，但将显示它的例子。</p>
<p>在进入清理过程之前，让我们简要地看一下数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import packages</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.mlab <span class="keyword">as</span> mlab</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> figure</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line">matplotlib.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">12</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">pd.options.mode.chained_assignment = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># read the data</span></span><br><span class="line">df = pd.read_csv(<span class="string">'train.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shape and data types of the data (30471, 292)</span></span><br><span class="line">print(df.shape)</span><br><span class="line">print(df.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数字列int/float</span></span><br><span class="line">df_numeric = df.select_dtypes(include=[np.number])</span><br><span class="line">numeric_cols = df_numeric.columns.values</span><br><span class="line">print(numeric_cols)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印非数字列object</span></span><br><span class="line">df_non_numeric = df.select_dtypes(exclude=[np.number])</span><br><span class="line">non_numeric_cols = df_non_numeric.columns.values</span><br><span class="line">print(non_numeric_cols)</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">(30471, 292)</span><br><span class="line">id                                         int64</span><br><span class="line">timestamp                                 object</span><br><span class="line">full_sq                                    int64</span><br><span class="line">life_sq                                  float64</span><br><span class="line">floor                                    float64</span><br><span class="line">max_floor                                float64</span><br><span class="line">material                                 float64</span><br><span class="line">build_year                               float64</span><br><span class="line">num_room                                 float64</span><br><span class="line">kitch_sq                                 float64</span><br><span class="line">state                                    float64</span><br><span class="line">product_type                              object</span><br><span class="line">sub_area                                  object</span><br><span class="line">area_m                                   float64</span><br><span class="line">raion_popul                                int64</span><br><span class="line">green_zone_part                          float64</span><br><span class="line">indust_part                              float64</span><br><span class="line">children_preschool                         int64</span><br><span class="line">preschool_quota                          float64</span><br><span class="line">preschool_education_centers_raion          int64</span><br><span class="line">children_school                            int64</span><br><span class="line">school_quota                             float64</span><br><span class="line">school_education_centers_raion             int64</span><br><span class="line">school_education_centers_top_20_raion      int64</span><br><span class="line">hospital_beds_raion                      float64</span><br><span class="line">healthcare_centers_raion                   int64</span><br><span class="line">university_top_20_raion                    int64</span><br><span class="line">sport_objects_raion                        int64</span><br><span class="line">additional_education_raion                 int64</span><br><span class="line">culture_objects_top_25                    object</span><br><span class="line">                                          ...   </span><br><span class="line">big_church_count_3000                      int64</span><br><span class="line">church_count_3000                          int64</span><br><span class="line">mosque_count_3000                          int64</span><br><span class="line">leisure_count_3000                         int64</span><br><span class="line">sport_count_3000                           int64</span><br><span class="line">market_count_3000                          int64</span><br><span class="line">green_part_5000                          float64</span><br><span class="line">prom_part_5000                           float64</span><br><span class="line">office_count_5000                          int64</span><br><span class="line">office_sqm_5000                            int64</span><br><span class="line">trc_count_5000                             int64</span><br><span class="line">trc_sqm_5000                               int64</span><br><span class="line">cafe_count_5000                            int64</span><br><span class="line">cafe_sum_5000_min_price_avg              float64</span><br><span class="line">cafe_sum_5000_max_price_avg              float64</span><br><span class="line">cafe_avg_price_5000                      float64</span><br><span class="line">cafe_count_5000_na_price                   int64</span><br><span class="line">cafe_count_5000_price_500                  int64</span><br><span class="line">cafe_count_5000_price_1000                 int64</span><br><span class="line">cafe_count_5000_price_1500                 int64</span><br><span class="line">cafe_count_5000_price_2500                 int64</span><br><span class="line">cafe_count_5000_price_4000                 int64</span><br><span class="line">cafe_count_5000_price_high                 int64</span><br><span class="line">big_church_count_5000                      int64</span><br><span class="line">church_count_5000                          int64</span><br><span class="line">mosque_count_5000                          int64</span><br><span class="line">leisure_count_5000                         int64</span><br><span class="line">sport_count_5000                           int64</span><br><span class="line">market_count_5000                          int64</span><br><span class="line">price_doc                                  int64</span><br><span class="line">Length: 292, dtype: object</span><br><span class="line">[&#39;id&#39; &#39;full_sq&#39; &#39;life_sq&#39; &#39;floor&#39; &#39;max_floor&#39; &#39;material&#39; &#39;build_year&#39;</span><br><span class="line"> &#39;num_room&#39; &#39;kitch_sq&#39; &#39;state&#39; &#39;area_m&#39; &#39;raion_popul&#39; &#39;green_zone_part&#39;</span><br><span class="line"> &#39;indust_part&#39; &#39;children_preschool&#39; &#39;preschool_quota&#39;</span><br><span class="line"> &#39;preschool_education_centers_raion&#39; &#39;children_school&#39; &#39;school_quota&#39;</span><br><span class="line"> &#39;school_education_centers_raion&#39; &#39;school_education_centers_top_20_raion&#39;</span><br><span class="line"> &#39;hospital_beds_raion&#39; &#39;healthcare_centers_raion&#39;</span><br><span class="line"> &#39;university_top_20_raion&#39; &#39;sport_objects_raion&#39;</span><br><span class="line"> &#39;additional_education_raion&#39; &#39;culture_objects_top_25_raion&#39;</span><br><span class="line"> &#39;shopping_centers_raion&#39; &#39;office_raion&#39; &#39;full_all&#39; &#39;male_f&#39; &#39;female_f&#39;</span><br><span class="line"> &#39;young_all&#39; &#39;young_male&#39; &#39;young_female&#39; &#39;work_all&#39; &#39;work_male&#39;</span><br><span class="line"> &#39;work_female&#39; &#39;ekder_all&#39; &#39;ekder_male&#39; &#39;ekder_female&#39; &#39;0_6_all&#39;</span><br><span class="line"> &#39;0_6_male&#39; &#39;0_6_female&#39; &#39;7_14_all&#39; &#39;7_14_male&#39; &#39;7_14_female&#39; &#39;0_17_all&#39;</span><br><span class="line"> &#39;0_17_male&#39; &#39;0_17_female&#39; &#39;16_29_all&#39; &#39;16_29_male&#39; &#39;16_29_female&#39;</span><br><span class="line"> &#39;0_13_all&#39; &#39;0_13_male&#39; &#39;0_13_female&#39;</span><br><span class="line"> &#39;raion_build_count_with_material_info&#39; &#39;build_count_block&#39;</span><br><span class="line"> &#39;build_count_wood&#39; &#39;build_count_frame&#39; &#39;build_count_brick&#39;</span><br><span class="line"> &#39;build_count_monolith&#39; &#39;build_count_panel&#39; &#39;build_count_foam&#39;</span><br><span class="line"> &#39;build_count_slag&#39; &#39;build_count_mix&#39;</span><br><span class="line"> &#39;raion_build_count_with_builddate_info&#39; &#39;build_count_before_1920&#39;</span><br><span class="line"> &#39;build_count_1921-1945&#39; &#39;build_count_1946-1970&#39; &#39;build_count_1971-1995&#39;</span><br><span class="line"> &#39;build_count_after_1995&#39; &#39;ID_metro&#39; &#39;metro_min_avto&#39; &#39;metro_km_avto&#39;</span><br><span class="line"> &#39;metro_min_walk&#39; &#39;metro_km_walk&#39; &#39;kindergarten_km&#39; &#39;school_km&#39; &#39;park_km&#39;</span><br><span class="line"> &#39;green_zone_km&#39; &#39;industrial_km&#39; &#39;water_treatment_km&#39; &#39;cemetery_km&#39;</span><br><span class="line"> &#39;incineration_km&#39; &#39;railroad_station_walk_km&#39; &#39;railroad_station_walk_min&#39;</span><br><span class="line"> &#39;ID_railroad_station_walk&#39; &#39;railroad_station_avto_km&#39;</span><br><span class="line"> &#39;railroad_station_avto_min&#39; &#39;ID_railroad_station_avto&#39;</span><br><span class="line"> &#39;public_transport_station_km&#39; &#39;public_transport_station_min_walk&#39;</span><br><span class="line"> &#39;water_km&#39; &#39;mkad_km&#39; &#39;ttk_km&#39; &#39;sadovoe_km&#39; &#39;bulvar_ring_km&#39; &#39;kremlin_km&#39;</span><br><span class="line"> &#39;big_road1_km&#39; &#39;ID_big_road1&#39; &#39;big_road2_km&#39; &#39;ID_big_road2&#39; &#39;railroad_km&#39;</span><br><span class="line"> &#39;zd_vokzaly_avto_km&#39; &#39;ID_railroad_terminal&#39; &#39;bus_terminal_avto_km&#39;</span><br><span class="line"> &#39;ID_bus_terminal&#39; &#39;oil_chemistry_km&#39; &#39;nuclear_reactor_km&#39; &#39;radiation_km&#39;</span><br><span class="line"> &#39;power_transmission_line_km&#39; &#39;thermal_power_plant_km&#39; &#39;ts_km&#39;</span><br><span class="line"> &#39;big_market_km&#39; &#39;market_shop_km&#39; &#39;fitness_km&#39; &#39;swim_pool_km&#39;</span><br><span class="line"> &#39;ice_rink_km&#39; &#39;stadium_km&#39; &#39;basketball_km&#39; &#39;hospice_morgue_km&#39;</span><br><span class="line"> &#39;detention_facility_km&#39; &#39;public_healthcare_km&#39; &#39;university_km&#39;</span><br><span class="line"> &#39;workplaces_km&#39; &#39;shopping_centers_km&#39; &#39;office_km&#39;</span><br><span class="line"> &#39;additional_education_km&#39; &#39;preschool_km&#39; &#39;big_church_km&#39;</span><br><span class="line"> &#39;church_synagogue_km&#39; &#39;mosque_km&#39; &#39;theater_km&#39; &#39;museum_km&#39;</span><br><span class="line"> &#39;exhibition_km&#39; &#39;catering_km&#39; &#39;green_part_500&#39; &#39;prom_part_500&#39;</span><br><span class="line"> &#39;office_count_500&#39; &#39;office_sqm_500&#39; &#39;trc_count_500&#39; &#39;trc_sqm_500&#39;</span><br><span class="line"> &#39;cafe_count_500&#39; &#39;cafe_sum_500_min_price_avg&#39;</span><br><span class="line"> &#39;cafe_sum_500_max_price_avg&#39; &#39;cafe_avg_price_500&#39;</span><br><span class="line"> &#39;cafe_count_500_na_price&#39; &#39;cafe_count_500_price_500&#39;</span><br><span class="line"> &#39;cafe_count_500_price_1000&#39; &#39;cafe_count_500_price_1500&#39;</span><br><span class="line"> &#39;cafe_count_500_price_2500&#39; &#39;cafe_count_500_price_4000&#39;</span><br><span class="line"> &#39;cafe_count_500_price_high&#39; &#39;big_church_count_500&#39; &#39;church_count_500&#39;</span><br><span class="line"> &#39;mosque_count_500&#39; &#39;leisure_count_500&#39; &#39;sport_count_500&#39;</span><br><span class="line"> &#39;market_count_500&#39; &#39;green_part_1000&#39; &#39;prom_part_1000&#39; &#39;office_count_1000&#39;</span><br><span class="line"> &#39;office_sqm_1000&#39; &#39;trc_count_1000&#39; &#39;trc_sqm_1000&#39; &#39;cafe_count_1000&#39;</span><br><span class="line"> &#39;cafe_sum_1000_min_price_avg&#39; &#39;cafe_sum_1000_max_price_avg&#39;</span><br><span class="line"> &#39;cafe_avg_price_1000&#39; &#39;cafe_count_1000_na_price&#39;</span><br><span class="line"> &#39;cafe_count_1000_price_500&#39; &#39;cafe_count_1000_price_1000&#39;</span><br><span class="line"> &#39;cafe_count_1000_price_1500&#39; &#39;cafe_count_1000_price_2500&#39;</span><br><span class="line"> &#39;cafe_count_1000_price_4000&#39; &#39;cafe_count_1000_price_high&#39;</span><br><span class="line"> &#39;big_church_count_1000&#39; &#39;church_count_1000&#39; &#39;mosque_count_1000&#39;</span><br><span class="line"> &#39;leisure_count_1000&#39; &#39;sport_count_1000&#39; &#39;market_count_1000&#39;</span><br><span class="line"> &#39;green_part_1500&#39; &#39;prom_part_1500&#39; &#39;office_count_1500&#39; &#39;office_sqm_1500&#39;</span><br><span class="line"> &#39;trc_count_1500&#39; &#39;trc_sqm_1500&#39; &#39;cafe_count_1500&#39;</span><br><span class="line"> &#39;cafe_sum_1500_min_price_avg&#39; &#39;cafe_sum_1500_max_price_avg&#39;</span><br><span class="line"> &#39;cafe_avg_price_1500&#39; &#39;cafe_count_1500_na_price&#39;</span><br><span class="line"> &#39;cafe_count_1500_price_500&#39; &#39;cafe_count_1500_price_1000&#39;</span><br><span class="line"> &#39;cafe_count_1500_price_1500&#39; &#39;cafe_count_1500_price_2500&#39;</span><br><span class="line"> &#39;cafe_count_1500_price_4000&#39; &#39;cafe_count_1500_price_high&#39;</span><br><span class="line"> &#39;big_church_count_1500&#39; &#39;church_count_1500&#39; &#39;mosque_count_1500&#39;</span><br><span class="line"> &#39;leisure_count_1500&#39; &#39;sport_count_1500&#39; &#39;market_count_1500&#39;</span><br><span class="line"> &#39;green_part_2000&#39; &#39;prom_part_2000&#39; &#39;office_count_2000&#39; &#39;office_sqm_2000&#39;</span><br><span class="line"> &#39;trc_count_2000&#39; &#39;trc_sqm_2000&#39; &#39;cafe_count_2000&#39;</span><br><span class="line"> &#39;cafe_sum_2000_min_price_avg&#39; &#39;cafe_sum_2000_max_price_avg&#39;</span><br><span class="line"> &#39;cafe_avg_price_2000&#39; &#39;cafe_count_2000_na_price&#39;</span><br><span class="line"> &#39;cafe_count_2000_price_500&#39; &#39;cafe_count_2000_price_1000&#39;</span><br><span class="line"> &#39;cafe_count_2000_price_1500&#39; &#39;cafe_count_2000_price_2500&#39;</span><br><span class="line"> &#39;cafe_count_2000_price_4000&#39; &#39;cafe_count_2000_price_high&#39;</span><br><span class="line"> &#39;big_church_count_2000&#39; &#39;church_count_2000&#39; &#39;mosque_count_2000&#39;</span><br><span class="line"> &#39;leisure_count_2000&#39; &#39;sport_count_2000&#39; &#39;market_count_2000&#39;</span><br><span class="line"> &#39;green_part_3000&#39; &#39;prom_part_3000&#39; &#39;office_count_3000&#39; &#39;office_sqm_3000&#39;</span><br><span class="line"> &#39;trc_count_3000&#39; &#39;trc_sqm_3000&#39; &#39;cafe_count_3000&#39;</span><br><span class="line"> &#39;cafe_sum_3000_min_price_avg&#39; &#39;cafe_sum_3000_max_price_avg&#39;</span><br><span class="line"> &#39;cafe_avg_price_3000&#39; &#39;cafe_count_3000_na_price&#39;</span><br><span class="line"> &#39;cafe_count_3000_price_500&#39; &#39;cafe_count_3000_price_1000&#39;</span><br><span class="line"> &#39;cafe_count_3000_price_1500&#39; &#39;cafe_count_3000_price_2500&#39;</span><br><span class="line"> &#39;cafe_count_3000_price_4000&#39; &#39;cafe_count_3000_price_high&#39;</span><br><span class="line"> &#39;big_church_count_3000&#39; &#39;church_count_3000&#39; &#39;mosque_count_3000&#39;</span><br><span class="line"> &#39;leisure_count_3000&#39; &#39;sport_count_3000&#39; &#39;market_count_3000&#39;</span><br><span class="line"> &#39;green_part_5000&#39; &#39;prom_part_5000&#39; &#39;office_count_5000&#39; &#39;office_sqm_5000&#39;</span><br><span class="line"> &#39;trc_count_5000&#39; &#39;trc_sqm_5000&#39; &#39;cafe_count_5000&#39;</span><br><span class="line"> &#39;cafe_sum_5000_min_price_avg&#39; &#39;cafe_sum_5000_max_price_avg&#39;</span><br><span class="line"> &#39;cafe_avg_price_5000&#39; &#39;cafe_count_5000_na_price&#39;</span><br><span class="line"> &#39;cafe_count_5000_price_500&#39; &#39;cafe_count_5000_price_1000&#39;</span><br><span class="line"> &#39;cafe_count_5000_price_1500&#39; &#39;cafe_count_5000_price_2500&#39;</span><br><span class="line"> &#39;cafe_count_5000_price_4000&#39; &#39;cafe_count_5000_price_high&#39;</span><br><span class="line"> &#39;big_church_count_5000&#39; &#39;church_count_5000&#39; &#39;mosque_count_5000&#39;</span><br><span class="line"> &#39;leisure_count_5000&#39; &#39;sport_count_5000&#39; &#39;market_count_5000&#39; &#39;price_doc&#39;]</span><br><span class="line">[&#39;timestamp&#39; &#39;product_type&#39; &#39;sub_area&#39; &#39;culture_objects_top_25&#39;</span><br><span class="line"> &#39;thermal_power_plant_raion&#39; &#39;incineration_raion&#39; &#39;oil_chemistry_raion&#39;</span><br><span class="line"> &#39;radiation_raion&#39; &#39;railroad_terminal_raion&#39; &#39;big_market_raion&#39;</span><br><span class="line"> &#39;nuclear_reactor_raion&#39; &#39;detention_facility_raion&#39; &#39;water_1line&#39;</span><br><span class="line"> &#39;big_road1_1line&#39; &#39;railroad_1line&#39; &#39;ecology&#39;]</span><br></pre></td></tr></table></figure>
<p>从这些结果中，我们了解到数据集有30471行和292列。我们还确定特征是数值变量还是分类变量。这些都是有用的信息。<br>现在，我们可以浏览“脏”数据类型的检查表并逐个修复它们。</p>
<h3 id="丢失数据可视化"><a href="#丢失数据可视化" class="headerlink" title="丢失数据可视化"></a>丢失数据可视化</h3><p>处理丢失的数据/值是数据清理中最棘手但最常见的部分之一。虽然许多模型可以处理数据的其他问题，但是大多数模型不接受丢失的数据。</p>
<p>我们将介绍三种技术，以进一步了解数据集中丢失的数据。</p>
<h4 id="1-缺失数据的热图"><a href="#1-缺失数据的热图" class="headerlink" title="1.缺失数据的热图"></a>1.缺失数据的热图</h4><p>当特征数量较少时，我们可以通过heatmap来可视化缺失的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cols = df.columns[:<span class="number">30</span>] <span class="comment"># first 30 columns</span></span><br><span class="line">colours = [<span class="string">'#000099'</span>, <span class="string">'#ffff00'</span>] <span class="comment"># specify the colours - yellow is missing. blue is not missing.</span></span><br><span class="line">sns.heatmap(df[cols].isnull(), cmap=sns.color_palette(colours))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>下面的图表展示了前30个特性中缺失的数据模式。横轴为特征名称;纵轴表示观测值/行数;黄色表示缺少的数据，蓝色表示没缺少的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20200225224926678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>train.csv文件截图如下：</p>
<p>即NA代表黄色。<br><img src="https://img-blog.csdnimg.cn/20200225225210505.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-缺失数据百分比表"><a href="#2-缺失数据百分比表" class="headerlink" title="2.缺失数据百分比表"></a>2.缺失数据百分比表</h4><p>当数据集中有许多特性时，我们可以列出每个特性的缺失数据百分比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for col in df.columns:</span><br><span class="line">    pct_missing &#x3D; np.mean(df[col].isnull())</span><br><span class="line">    print(&#39;&#123;&#125; - &#123;&#125;%&#39;.format(col, round(pct_missing*100)))</span><br></pre></td></tr></table></figure>
<p>这将生成一个列表，在下面的列表中显示每个特性缺失值的百分比。<br>具体来说，我们看到life_sq功能有21%的缺失，而地板只有1%的缺失。这个列表是一个有用的总结，可以补充热图可视化。</p>
<p><img src="https://img-blog.csdnimg.cn/20200225225903312.JPG" alt="在这里插入图片描述"></p>
<h4 id="3-丢失数据直方图"><a href="#3-丢失数据直方图" class="headerlink" title="3.丢失数据直方图"></a>3.丢失数据直方图</h4><p>当我们有很多特征时，丢失数据直方图也是一种技术。<br>为了了解更多关于观测中缺失值模式的信息，我们可以通过直方图将其可视化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    missing = df[col].isnull()</span><br><span class="line">    num_missing = np.sum(missing)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> num_missing &gt; <span class="number">0</span>:  </span><br><span class="line">        print(<span class="string">'created missing indicator for: &#123;&#125;'</span>.format(col))</span><br><span class="line">        df[<span class="string">'&#123;&#125;_ismissing'</span>.format(col)] = missing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># then based on the indicator, plot the histogram of missing values</span></span><br><span class="line">ismissing_cols = [col <span class="keyword">for</span> col <span class="keyword">in</span> df.columns <span class="keyword">if</span> <span class="string">'ismissing'</span> <span class="keyword">in</span> col]</span><br><span class="line">df[<span class="string">'num_missing'</span>] = df[ismissing_cols].sum(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">df[<span class="string">'num_missing'</span>].value_counts().reset_index().sort_values(by=<span class="string">'index'</span>).plot.bar(x=<span class="string">'index'</span>, y=<span class="string">'num_missing'</span>)</span><br></pre></td></tr></table></figure>
<p>这个直方图有助于识别30,471个观察值中缺失的值。<br><img src="https://img-blog.csdnimg.cn/20200225231216930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例如，有6000多个没有缺失值的观测值，而有一个缺失值的观测值接近4000个。</p>
<h3 id="对于缺失数据的处理方法"><a href="#对于缺失数据的处理方法" class="headerlink" title="对于缺失数据的处理方法"></a>对于缺失数据的处理方法</h3><p>对于处理缺失的数据，没有一致的解决方案。我们必须研究特定的特性和数据集，以确定处理它们的最佳方式。<br>下面介绍四种最常见的处理丢失数据的方法。但是，如果情况比通常更复杂，我们需要创造性地使用更复杂的方法，比如缺失数据建模。</p>
<h4 id="1-删除观察值"><a href="#1-删除观察值" class="headerlink" title="1.删除观察值"></a>1.删除观察值</h4><p>在统计学中，这种方法称为列表删除技术。在这个解决方案中，只要整个观察值包含一个丢失的值，我们就删除它。只有当我们确信丢失的数据不能提供信息时，我们才执行此操作。否则，我们应该考虑其他的解决方案。还可以使用其他标准来删除观察结果。</p>
<p>例如，从缺失的数据柱状图中，我们注意到只有少量的<strong>观察数据</strong>总共<strong>丢失了35个以上的特征</strong>。我们可以创建一个新的数据集df_less_missing_rows，删除包含35个以上缺失特性的观察数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ind_missing = df[df[<span class="string">'num_missing'</span>] &gt; <span class="number">35</span>].index</span><br><span class="line">df_less_missing_rows = df.drop(ind_missing, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-删除特征值"><a href="#2-删除特征值" class="headerlink" title="2.删除特征值"></a>2.删除特征值</h4><p>与解决方案1类似，我们只在确信该特性没有提供有用信息时才这样做。例如，<strong>在缺失数据百分比</strong>列表中，我们注意到hospital_beds_raion有47%的高缺失值百分比。我们可能会删除该特征。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cols_to_drop = [<span class="string">'hospital_beds_raion'</span>]</span><br><span class="line">df_less_hos_beds_raion = df.drop(cols_to_drop, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-估算缺失值"><a href="#3-估算缺失值" class="headerlink" title="3.估算缺失值"></a>3.估算缺失值</h4><p>当特征是一个数值变量时，我们可以进行缺失数据的归并。我们将缺失的值替换为未缺失的相同特征数据的平均值或中值。</p>
<p>当特征是一个分类变量时，我们可以通过模式(最频繁的值)来估算缺失的数据。</p>
<p>以life_sq为例，我们可以用它的中值来代替这个特性的缺失值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">med = df[<span class="string">'life_sq'</span>].median()</span><br><span class="line">print(med)</span><br><span class="line">df[<span class="string">'life_sq'</span>] = df[<span class="string">'life_sq'</span>].fillna(med)</span><br></pre></td></tr></table></figure>
<p>此外，我们可以对所有的数值特征同时应用相同的归算策略。<br>即所有数据的缺失值用平均值代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df_numeric = df.select_dtypes(include=[np.number])</span><br><span class="line">numeric_cols = df_numeric.columns.values</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> numeric_cols:</span><br><span class="line">    missing = df[col].isnull()</span><br><span class="line">    num_missing = np.sum(missing)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> num_missing &gt; <span class="number">0</span>:  <span class="comment"># 仅对具有缺失值的列进行估算。</span></span><br><span class="line">        print(<span class="string">'imputing missing values for: &#123;&#125;'</span>.format(col))</span><br><span class="line">        df[<span class="string">'&#123;&#125;_ismissing'</span>.format(col)] = missing</span><br><span class="line">        med = df[col].median()</span><br><span class="line">        df[col] = df[col].fillna(med)</span><br></pre></td></tr></table></figure>

<p>对于非数据类型的缺失值，我们利用该特征中的最频繁值特征代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df_non_numeric = df.select_dtypes(exclude=[np.number])</span><br><span class="line">non_numeric_cols = df_non_numeric.columns.values</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> non_numeric_cols:</span><br><span class="line">    missing = df[col].isnull()</span><br><span class="line">    num_missing = np.sum(missing)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> num_missing &gt; <span class="number">0</span>:  <span class="comment"># only do the imputation for the columns that have missing values.</span></span><br><span class="line">        print(<span class="string">'imputing missing values for: &#123;&#125;'</span>.format(col))</span><br><span class="line">        df[<span class="string">'&#123;&#125;_ismissing'</span>.format(col)] = missing</span><br><span class="line">        </span><br><span class="line">        top = df[col].describe()[<span class="string">'top'</span>] <span class="comment"># impute with the most frequent value.</span></span><br><span class="line">        df[col] = df[col].fillna(top)</span><br></pre></td></tr></table></figure>
<h4 id="4-替换缺失值"><a href="#4-替换缺失值" class="headerlink" title="4.替换缺失值"></a>4.替换缺失值</h4><p>对于分类特性，我们可以添加一个值为“_MISSING_”的新类别。对于数值特征，我们可以用一个特定的值来代替它，比如-999。<br>通过这种方式，我们仍然保留了丢失的值作为有价值的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df[&#39;sub_area&#39;] &#x3D; df[&#39;sub_area&#39;].fillna(&#39;_MISSING_&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># numeric</span><br><span class="line">df[&#39;life_sq&#39;] &#x3D; df[&#39;life_sq&#39;].fillna(-999)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/25/%E9%9D%A2%E5%90%91%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6%E7%9A%84%E6%B5%8B%E8%AF%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/%E9%9D%A2%E5%90%91%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6%E7%9A%84%E6%B5%8B%E8%AF%84/" class="post-title-link" itemprop="url">面向大数据框架的测评</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-25 20:50:12 / 修改时间：20:52:12" itemprop="dateCreated datePublished" datetime="2020-02-25T20:50:12+08:00">2020-02-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>以hadoop为代表的各种大数据框架不断涌现，这些数据处理框架方便了大数据应用的编写，但是由于数据来源的多样性、数据形式的多元化，使得数据质量存在较大的差异，不正确或者不一致的数据可能严重影响分析效果。</p>
</blockquote>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>大数据处理流程一般如下：使用相关工具对分布广泛的非结构化的数据源进行抽取和集成，采用合适的标准对结果进行统一存储，利用数据分析的相关技术分析存储的数据，从所存储的数据中选择有用的内容并通过恰当的方式提供给大数据应用。<br><img src="https://img-blog.csdnimg.cn/20200225135340273.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在处理大数据之前需要对来自不同数据源的数据做数据处理，包括数据抽取和数据集成。通过数据集成和数据抽取操作提取关系和实体，对其进行关联和聚类的相关操作后，采用统一定义的结构来存储这些数据。数据清洗发生在数据集成操作和数据抽取操作之前进行，保证数据质量和可行性。</p>
<p><strong>数据处理的核心部分包括数据抽取、数据集成以及数据清洗</strong>数据抽取的相关研究在传统的数据库领域已经较为成熟，并且数据集成的相关方法也随新数据源的涌现而不断发展。目前数据抽取与集成的方式可以分为以下四种类型：基于物化或ETL方法引擎、基于数据流方法引擎以及基于搜索引擎的方法。数据清洗是指通过一定的规则将脏数据洗掉，规则包括检查数据一致性、处理无效性和缺失值等。</p>
<h3 id="2-面向数据质量的测评"><a href="#2-面向数据质量的测评" class="headerlink" title="2.面向数据质量的测评"></a>2.面向数据质量的测评</h3><h4 id="2-1数据质量"><a href="#2-1数据质量" class="headerlink" title="2.1数据质量"></a>2.1数据质量</h4><p>1)数据质量的定义<br>数据质量包括数据本身质量和数据过程质量。</p>
<ul>
<li>数据真实性：数据真实并且准确地反映实际业务。</li>
<li>数据完备性：数据充分，没有遗漏任何有关的操作数据。</li>
<li>数据自治性：数据不是孤立存在的而是通过不同的约束互相关联，在满足数据之间关联关系的同时不违反相关的规定。</li>
<li>数据的使用质量：数据被正确的使用。</li>
<li>数据存储质量：数据被安全地存储在合适的介质中。</li>
<li>数据传输质量：在传输过程中数据传输地效率以及数据正确性。</li>
</ul>
<p>2)数据质量问题的分类</p>
<p><img src="https://img-blog.csdnimg.cn/20200225173431439.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>很多单数据源诸如文件、web数据等，缺乏数据模式和统一的数据规范，因而更容易发生错误或者不一致问题。实例层问题在模式层次上是不可见的，无法通过改进模式来避免问题产生。多数据源的数据质量问题比单数据源更加复杂。</p>
<p>3)数据质量控制方法及实现<br>从对数据仓库自身数据的监控到对数据形成过程的管理，数据仓库中用于数据质量控制的方法有很多。数据质量逐渐与企业业绩和价值挂钩，企业应当采取合适的方法来评估其数据质量的能力和成熟度，因此提出了数据质量成熟度模型的评估理论。</p>
<h4 id="2-2数据预处理"><a href="#2-2数据预处理" class="headerlink" title="2.2数据预处理"></a>2.2数据预处理</h4><p>1)数据清洗</p>
<p>数据清洗将脏数据转化为满足数据质量要求的数据。数据清洗所处理的主要问题有：空缺值、错误数据、孤立点和噪声。</p>
<p>通常不符合要求的数据有三类：</p>
<p>(1)数据缺失：</p>
<p>数据缺失一般包括两种情况：数据中拥有大量缺失值的属性以及数据重要属性存在少量的缺失值。对于前者可以采用删除的操作来去除缺失的属性；对于后者而言，需要采用数据补充的方法将数据补充完整后再进行数据挖掘操作。</p>
<p>在数据清洗中，对于不完整的数据特征采用两种填补方案：用相同的常数去替换缺失的属性值；用该属性最有可能值填补缺失值。</p>
<p>(2)数据错误：</p>
<p>当业务系统不够健全时，容易产生数据错误。</p>
<p>(3)数据重复：</p>
<p>当出现数据重复的情况时，用户可以将重复的数据字段导出来确认并且整理。MapReduce可以实现数据去重。利用Map将需要去重的数据作为一个&lt;key,value&gt;值，经过shuffle后输入到reduce中并利用值key的唯一性直接输出值。核心代码略。</p>
<p>2)数据集成/数据变换</p>
<p>数据集成是指从逻辑上或者物理上将来源、格式以及特点性质不同的数据有机的集中起来，为数据挖掘提供比较完整的数据源。</p>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>问题描述</th>
</tr>
</thead>
<tbody><tr>
<td>数据表链接不匹配</td>
<td>来自多个数据源中的数据表需要通过相同的主键连接。</td>
</tr>
<tr>
<td>冗余</td>
<td>在连接数据表的过程中，没有对表中的字段严格选择后就连接，造成大量的冗余</td>
</tr>
<tr>
<td>数据值冲突</td>
<td>不同数据源中的不同属性值导致数据表连接字段的类型出现重复</td>
</tr>
</tbody></table>
<p>数据集成代码略</p>
<p>数据变换是数据清洗过程中重要一步，是对数据的标准化处理。通常数据变换需要处理的内容如下表所示：</p>
<table>
<thead>
<tr>
<th>数据分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>属性的数据类型</td>
<td>当属性之间的取值范围相差大时，要进行数据的映射处理。当属性的取值类型较小时，分析数据的分布频率，然后进行数据转换，将其中字符型数据转化为枚举型</td>
</tr>
<tr>
<td>数据离散化</td>
<td>将连续取值的属性离散化成若干区间，来帮助消减一个连续属性的个数</td>
</tr>
<tr>
<td>数据标准化</td>
<td>不同来源得到的相同字段定义可能不一样</td>
</tr>
</tbody></table>
<p>3)数据规约</p>
<p>可以获得数据集的简化表示。</p>
<p>(1)属性选择 </p>
<p>根据用户的指标选择一个优化属性子集的过程。优化属性子集可以是属性数目最小的子集，也可以是含有最佳预测准确率的子集。包括属性评估方法和搜索方法。</p>
<p>(2)实例选择</p>
<p>实例选择是使用部分数据记录代替原来所有的数据记录进行数据挖掘，减小挖掘时间和降低挖掘资源的代价，获得更高效的挖掘性能。<strong>主要通过采样数据集实现</strong>，包括简单随机采样、等级采样等。</p>
<h4 id="2-3数据质量测评"><a href="#2-3数据质量测评" class="headerlink" title="2.3数据质量测评"></a>2.3数据质量测评</h4><p>1)数据清洗框架和工具</p>
<p>文献提出了数据清洗的框架，该框架将逻辑规范层与物理实现层分离开来，并围绕该框架提出了数据清洗的模型和语言。AJAX模型是逻辑层面的模型，将数据清洗分为映射、匹配、聚集、合并、跟踪五个过程。</p>
<p>常用的数据清洗工具如下：</p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>DATASTAGE</td>
<td>针对系统的各个环节可能出现的数据二义性、重复、不完整、违法业务规则等问题，允许通过抽取，将有问题的记录删除，再根据实际情况来调整相应的清洗操作</td>
</tr>
<tr>
<td>Visual Warehousing</td>
<td>IBM公司推出的一个创建和维护数据仓库的集成工具，可以定义、创建、管理、监控和维护数据仓库</td>
</tr>
<tr>
<td>DTS</td>
<td>提供数据输入/输出和自动调度功能，在数据传输过程中完成数据的验证、清洗和转换等操作</td>
</tr>
</tbody></table>
<p>银行数据仓库中的数据清洗的流程如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200225191534274.JPG" alt="在这里插入图片描述"></p>
<p>逻辑规范：<br><img src="https://img-blog.csdnimg.cn/2020022519221662.JPG" alt="在这里插入图片描述"></p>
<p>2)数据清洗评估</p>
<p>通常会参照高质量的数据特征来分析数据质量是否合格，一般通过以下几方面评价数据质量。</p>
<p>(1)相关性<br>数据质量的一个关键目标是信息是否满足客户的要求。</p>
<p>(2)准确性<br>准确的信息能反映基本现实，并且高质量信息应该是准确的。</p>
<p>(3)及时性<br>及时性是指没有延误的信息。<br>等等</p>
<h3 id="3-分布式数据模型及测试"><a href="#3-分布式数据模型及测试" class="headerlink" title="3.分布式数据模型及测试"></a>3.分布式数据模型及测试</h3><h4 id="3-1-框架"><a href="#3-1-框架" class="headerlink" title="3.1 框架"></a>3.1 框架</h4><p>hadoop是最著名的大数据处理框架之一，它以可靠、高效、可伸缩方式进行大数据的储存、处理和分析。用户在开发分布式大数据处理程序时，无需了解分布式底层细节，就可以利用大规模集群进行告诉计算与存储。</p>
<p>Hadoop具有如下几个方面的特征：扩容能力、成本低、高效率、可靠性。</p>
<p>Hadoop的核心是HDFS与mapreduce，为用户提供了系统底层透明的分布式基础框架。</p>
<h4 id="3-2数据模型"><a href="#3-2数据模型" class="headerlink" title="3.2数据模型"></a>3.2数据模型</h4><p>mapreduce能在整个集群上执行map和reduce任务并报告结果。HDFS通过定义来支持大型文件，并且提供了一种支持跨节点复制数据以进行处理的存储模式。</p>
<p>mapreduce采用主/从架构，主要包括:client、jobtracker、tasktracker。mapreduce先对用户提交的数据进行分块，然后交给不同的Map任务处理。</p>
<p>略</p>
<h4 id="3-3单元测试"><a href="#3-3单元测试" class="headerlink" title="3.3单元测试"></a>3.3单元测试</h4><p>MapReduce封装了大量的基础功能，方便用户编程，但给MapReduce的单元测试带来很大挑战。<br>MRUnit是针对MapReduce的单元测试框架，<strong>其基本原理是JUnit4与EasyMock,MRUnit结果简单，依赖于JUnit的单元测试，通过实现Mock对象控制outputcollector操作并且拦截该输出，对比期望结果以达到自动断言的目的。</strong></p>
<p>针对不同的测试对象，MRUnit使用以下几种Driver:</p>
<ul>
<li>MapDriver   测试单独的Map</li>
<li>ReduceDriver  测试单独的Reduce</li>
<li>MapReduce Driver 将Map与Reduce结合起来测试</li>
<li>PipelineMapReduceDriver 将多个Map-Reduce pair结合起来测试</li>
</ul>
<p>从Apache下载MRUnit最新版的jar包，并将jar包添加到hadoop的IDE Classpath 路径中。<br>假设通过MR分析一个电话记录。</p>
<p>其中Mapper代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SMSCDRMapper extends Mapper&lt;LongWritable,Text,Text,IntWritable&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private Text status &#x3D; new Text();</span><br><span class="line">    private final static IntWritable addOne&#x3D; new IntWritable(1);</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context)</span><br><span class="line">        throws java.io.IOEXception, InterruptedException&#123;</span><br><span class="line">            String[] line&#x3D;value.toString().split(&quot;;&quot;);</span><br><span class="line">            if(Integer.parseInt(line[1])&#x3D;&#x3D;1)&#123;</span><br><span class="line">                status.set(line[4]);</span><br><span class="line">                context.write(status,addOne);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reducer代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SMSCDRReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt;</span><br><span class="line">&#123;</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;IntWritable&gt;values, Context context)</span><br><span class="line">        throws java.io.IOEXception, InterruptedException&#123;</span><br><span class="line">               int sum&#x3D;0;</span><br><span class="line">               for (IntWritable value:values)</span><br><span class="line">               &#123;</span><br><span class="line">                   sum+&#x3D;value,get();</span><br><span class="line">               &#125;</span><br><span class="line">                context.write(status,new IntWritable(sum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对以上的Map，可以编写相关的测试代码，通过withInput模拟输入一行，其对的期望为输出(withOutput)。如果输入的数据经过map计算之后为期望的结果：SMS Status Code为5，CDRType为1，则测试通过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SMSCDRMapperTest&#123;</span><br><span class="line">    MapDriver&lt;LongWritable,Text,Text,IntWritable&gt;mapDriver; </span><br><span class="line">  </span><br><span class="line">    @Before</span><br><span class="line">       public void setUp()&#123;</span><br><span class="line">           SMSCDRMapper mapper &#x3D; new SMSCDRMapper();</span><br><span class="line"></span><br><span class="line">           mapDriver &#x3D; MapDriver.newMapDriver(mapper);</span><br><span class="line">       &#125;</span><br><span class="line">   @Test</span><br><span class="line">       public void testMapper()&#123;</span><br><span class="line">                mapDriver.withInput(new LongWritable(),new Text(&quot;5975877;1;756222541;552687123358;5&quot;));</span><br><span class="line">               mapDriver.withOutput(new Text(&quot;5&quot;),new IntWritable(1));</span><br><span class="line">              </span><br><span class="line">               mapDriver.runTest();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReduceDriver针对Reduce的单独测试。略</p>
<p>以下为Map和Reduce测试的例子。模拟两条记录的输入：</p>
<p>“595877;1;7585458855;4441417;5”</p>
<p>“735856;1;5498749558;8478941;3”</p>
<p>期望的输出为</p>
<p>5，1</p>
<p>3，1</p>
<p>相关代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SMSCDRMapperReducerTest&#123;</span><br><span class="line">    MapDriver&lt;LongWritable,Text,Text,IntWritable&gt;mapDriver; </span><br><span class="line">    ReduceDriver&lt;Text,IntWritable,Text,IntWritable&gt;reduceDriver;</span><br><span class="line">    MapReduceDriver&lt;LongWritable,Text,Text,IntWritable,Text,IntWritable&gt;mapReduceDriver;</span><br><span class="line">    @Before</span><br><span class="line">       public void setUp()&#123;</span><br><span class="line">           SMSCDRMapper mapper &#x3D; new SMSCDRMapper();</span><br><span class="line">           SMSCDReducer reducer &#x3D; new SMSCDRReducer();</span><br><span class="line">           mapReduceDriver &#x3D; MapReduceDriver.newMapReduceDriver(mapper,reducer);</span><br><span class="line">       &#125;</span><br><span class="line">   @Text    </span><br><span class="line">       public void testMapReduce()&#123;</span><br><span class="line">               Text mapInputValue1 &#x3D; new Text(&quot;595877;1;7585458855;4441417;5&quot;)</span><br><span class="line">               Text mapInputValue2 &#x3D; new Text(&quot;735856;1;5498749558;8478941;3&quot;)</span><br><span class="line">               mapReduceDriver.withInput(new LongWritable(1),mapInputValue1);</span><br><span class="line">               mapReduceDriver.withInput(new LongWritable(1),mapInputValue2);</span><br><span class="line">               mapReduceDriver.addOutput(new Text(&quot;5&quot;),new IntWritable(1));</span><br><span class="line">               mapReduceDriver.addOutput(new Text(&quot;3&quot;),new IntWritable(1));</span><br><span class="line">               maReduceDriver.runTest();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4大数据的基准测试"><a href="#4大数据的基准测试" class="headerlink" title="4大数据的基准测试"></a>4大数据的基准测试</h3><p><strong>基准测试是一种测量和评估软件性能指标的典型活动。可以在某个时刻通过基准测试建立一个已知的性能水平，当系统的软硬件环境发生变化后再进行一次基准测试，以确定那些变化对性能的影响。</strong></p>
<h4 id="4-1测试方法"><a href="#4-1测试方法" class="headerlink" title="4.1测试方法"></a>4.1测试方法</h4><p>1）测试步骤</p>
<p>通常是在系统上运行一系列的测试程序，并把性能计数器的结果保存起来，这些结果称为“性能指标”,可以让有经验的专业人员对系统过去和现在的性能表现进行对照比较，确定系统或环境的所有变化。</p>
<p>2）测试工具集</p>
<p>包括工业界、科研界提出的测试工具集和大数据提供的测试基准。</p>
<p>具体包括：</p>
<p>1.BigBench</p>
<p>2.<strong>hadoop自带的测试基准</strong>，这些程序可以从多个角度对Hadoop进行测试，TestDFSIO,mrbench和nnbench是三个广泛使用的测试。</p>
<p>TestDFSIO用于测试HDFS的IO性能。</p>
<p>nnbench用于测试NameNode负载。</p>
<p>mrbench会多次重复执行一个小作业，用于检查在机群上小作业的运行是否可以重复以及运行是否高效。</p>
<p>3.HBase系统本身提供了性能测试工具。</p>
<p>3）数据准备</p>
<p><strong>数据发生器是大数据基准中很重要的工具。数据基准测试中常用的数据生成工具包括HiBench与BDGS。</strong></p>
<p>HiBench的容量是扩展的，可以生成非结构的文本数据类型并支持hadoop hive。BDGS在保留原始数据特性的基础上以小规模的真实数据生成大规模的数据。</p>
<p>并行数据生成框架(PDGF)是一种适应性很强的数据生成工具，可以在短时间内生成大量的关系数据。PDGF利用并行随机数发生器来生成独立的相关值。其中间过程和转换的最终结果是可以计算的，其基本关系库模型也使得它可以在数据上产生一致性查询。</p>
<h4 id="4-2测试内容"><a href="#4-2测试内容" class="headerlink" title="4.2测试内容"></a>4.2测试内容</h4><p>基准测试包括面对特定处理功能甚至应用的基准测试程序集的集合。<br>下面给出不同的测试工具集包括的测试内容：</p>
<p>1.Big Data Bench from UC Berkeley</p>
<p>2.BigDataBench</p>
<p>BigDataBench是一个抽取INTERNET典型服务构建的大数据基准测试程序集。<br>3.Hibench基准测试</p>
<p>4.Hadoop基准测试</p>
<p>Hadoop自带了几个基准测试，打包在jar包中，如Hadoop-<em>test</em>.jar和Hadoop<em>examples</em>.jar。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TestDFSIO</td>
<td>测试HDFS的IO性能</td>
</tr>
<tr>
<td>nnbench</td>
<td>测试NameNode的负载</td>
</tr>
<tr>
<td>mrbench</td>
<td>多次重复执行一个小作业，检查运行是否可重复以及是否高效</td>
</tr>
</tbody></table>
<ul>
<li>TestDFSIO的测试步骤：</li>
</ul>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: TestDFSIO[genericOptions]   -read|-write|-append|-clean[-nrFiles N]</span><br></pre></td></tr></table></figure>
<p>命令行：例子将往HDFS中写入10个1000MB的文件： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar $HADOOP_HOME&#x2F;hadoop - *test*.jar TestDFSIO -read -nrFiles 10  -fileSize 1000</span><br></pre></td></tr></table></figure>
<p>使用命令行删除数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar $HADOOP_HOME&#x2F;hadoop - *test*.jar TestDFSIO -clean</span><br></pre></td></tr></table></figure>

<ul>
<li>nnbench：用于测试NameNode的负载。</li>
</ul>
<p>它会生成很多与HDFRS相关的请求，给NameNode施加压力。这个测试能在HDFS上模拟创建、读取、重命名和删除文件等操作。</p>
<p>例如，使用12个mapper和6个reducer来创建1000个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar $HADOOP_HOME&#x2F;hadoop - *test*.jar nnbench\</span><br><span class="line">   -operation create_write -maps 12 -reduces 6 -blockSize 1\</span><br><span class="line">   -bytesToWrite 0 -numberOfFiles 1000 -replicationFactorPerFiles 3\</span><br><span class="line">   -readFileAfterOpen true -baseDir&#x2F;benchmarks&#x2F;NNBench - &#39;hostname -s&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>mrbench会多次重复执行一个小作业，用于检查在机群上小作业的运行是否可以重复以及运行是否高效。</li>
</ul>
<p>例如，运行一个小作业50次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar $HADOOP_HOME&#x2F;hadoop - *test*.jar mrbench -numRuns 50</span><br></pre></td></tr></table></figure>
<ul>
<li>Terasort是测试Hadoop的一个有效的排序程序。</li>
</ul>
<p>通过Hadoop自带的Terasort排序程序，测试不同的Map任务和Reduce任务数量，对hadoop性能的影响。</p>
<p>一个完整的Terasort测试需要按三个步骤执行：</p>
<p>(1).用TeraGen生成1GB的随机数据，并输入到目录/examples/terasort- input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar $HADOOP_HOME&#x2F;hadoop-examples-0.20.2-cdh3u3.jar teragen \</span><br><span class="line">    10000000&#x2F;examples&#x2F;terasort- input</span><br></pre></td></tr></table></figure>
<p>(2).输入数据运行TeraSort对数据进行排序，并将结果输出到目录：examples/terasort- output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar $HADOOP_HOME&#x2F;hadoop-examples-0.20.2-cdh3u3.jar terasort \</span><br><span class="line">    examples&#x2F;terasort- input&#x2F;examples&#x2F;terasort- output</span><br></pre></td></tr></table></figure>
<p>(3).用TeraValidate验证排好序的输出数据，如果有问题，将乱序的Key输出到目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar $HADOOP_HOME&#x2F;hadoop-examples-0.20.2-cdh3u3.jar teravalidate \                            </span><br><span class="line">      examples&#x2F;terasort- input&#x2F;examples&#x2F;terasort- validate</span><br></pre></td></tr></table></figure>
<p>5.微基准测试</p>
<p>用hadoop对sort grep,wordcount进行微基准测试实例，包括数据生成和测试执行两步骤。</p>
<p>6.关系查询</p>
<p>针对数据库中的相关信息进行，基准测试主要包括：装载数据、查询准备和执行查询三个步骤。</p>
<p>7.HBase</p>
<p>HBase自带的测试主要步骤</p>
<p>1）环境配置</p>
<p>2）测试</p>
<p>3）Bulk load对HBase测试</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95python/" class="post-title-link" itemprop="url">数据结构与算法python</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-24 16:50:15 / 修改时间：16:51:04" itemprop="dateCreated datePublished" datetime="2020-02-24T16:50:15+08:00">2020-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念"></a>引入概念</h2><h3 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">start_time&#x3D;time.time()</span><br><span class="line"></span><br><span class="line">for a in range(0,1001):</span><br><span class="line">   for b in range(0,1001):</span><br><span class="line">       for c in range(0,1001):</span><br><span class="line">          if a**2+b**2&#x3D;&#x3D;c**2 and a+b+c&#x3D;&#x3D;1000:</span><br><span class="line">             print(&quot;a,b,c: %d,%d,%d&quot;%(a,b,c))</span><br><span class="line">end_time &#x3D; time.time()</span><br><span class="line">print(&quot;elapsed: %f&quot; % (end_time - start_time))</span><br><span class="line">print(&quot;complete!&quot;)</span><br></pre></td></tr></table></figure>
<p>第二次尝试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">start_time&#x3D;time.time()</span><br><span class="line">for a in range(0,1001):</span><br><span class="line">    for b in range(0,1001-a):</span><br><span class="line">        c&#x3D;1001-a-b</span><br><span class="line">        if a**2+b**2&#x3D;&#x3D;c**2:</span><br><span class="line">           print(&quot;a,b,c:%d,%d,%d&quot;%(a,b,c))</span><br></pre></td></tr></table></figure>
<h3 id="算法效率的衡量"><a href="#算法效率的衡量" class="headerlink" title="算法效率的衡量"></a>算法效率的衡量</h3><h4 id="执行时间反应算法效率"><a href="#执行时间反应算法效率" class="headerlink" title="执行时间反应算法效率"></a>执行时间反应算法效率</h4><p>对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。</p>
<h4 id="单靠时间值绝对可信吗？"><a href="#单靠时间值绝对可信吗？" class="headerlink" title="单靠时间值绝对可信吗？"></a>单靠时间值绝对可信吗？</h4><p>单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！</p>
<p>程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？</p>
<h4 id="时间复杂度与“大O记法”"><a href="#时间复杂度与“大O记法”" class="headerlink" title="时间复杂度与“大O记法”"></a>时间复杂度与“大O记法”</h4><p>我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。</p>
<p>对于算法的时间效率，我们可以用“大O记法”来表示。</p>
<p><strong>“大O记法”</strong>：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。</p>
<p><strong>时间复杂度</strong>：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)</p>
<h4 id="如何理解“大o记法”"><a href="#如何理解“大o记法”" class="headerlink" title="如何理解“大o记法”"></a>如何理解“大o记法”</h4><p>对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为3n2和100n2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为n2级。</p>
<h4 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h4><p>分析算法时，存在几种可能的考虑：</p>
<p>算法完成工作最少需要多少基本操作，即最优时间复杂度</p>
<p>算法完成工作最多需要多少基本操作，即最坏时间复杂度</p>
<p>算法完成工作平均需要多少基本操作，即平均时间复杂度</p>
<p>对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。</p>
<p>对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。</p>
<p>对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。</p>
<p>因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。</p>
<h4 id="时间复杂度的几种计算规则"><a href="#时间复杂度的几种计算规则" class="headerlink" title="时间复杂度的几种计算规则"></a>时间复杂度的几种计算规则</h4><ol>
<li>基本操作，即只有常数项，认为其时间复杂度为O(1)</li>
<li>顺序结构，时间复杂度按加法进行计算</li>
<li>循环结构，时间复杂度按乘法进行计算</li>
<li>分支结构，时间复杂度取最大值</li>
</ol>
<p>判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略<br>在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度</p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p><img src="https://img-blog.csdnimg.cn/20200224161713767.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="python内置类型性能分析"><a href="#python内置类型性能分析" class="headerlink" title="python内置类型性能分析"></a>python内置类型性能分析</h3><h4 id="list内置操作的时间复杂度"><a href="#list内置操作的时间复杂度" class="headerlink" title="list内置操作的时间复杂度"></a>list内置操作的时间复杂度</h4><p><img src="https://img-blog.csdnimg.cn/20200224162727189.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="dict内置操作的时间复杂度"><a href="#dict内置操作的时间复杂度" class="headerlink" title="dict内置操作的时间复杂度"></a>dict内置操作的时间复杂度</h4><p><img src="https://img-blog.csdnimg.cn/202002241628114.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。</p>
<p>对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。</p>
<p>这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。</p>
<p>根据线性表的实际存储方式，分为两种实现模型：</p>
<ul>
<li>顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。</li>
<li>链表，将元素存放在通过链接构造起来的一系列存储块中。<h3 id="顺序表的形式"><a href="#顺序表的形式" class="headerlink" title="顺序表的形式"></a>顺序表的形式</h3><img src="https://img-blog.csdnimg.cn/20200224163026825.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p>图a表示的是顺序表的基本形式，数据元素本身<strong>连续存储</strong>，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的<strong>物理地址</strong>（实际内存地址）可以通过存储区的<strong>起始地址</strong>Loc (e0)加<strong>上逻辑地址</strong>（第i个元素）与<strong>存储单元大小</strong>（c）的乘积计算而得，即：</p>
<ul>
<li>Loc(ei) = Loc(e0) + c*i</li>
</ul>
<p>故<strong>访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)</strong>。</p>
<p>如果<strong>元素的大小不统一</strong>，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的<strong>地址信息（即链接）</strong>。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是<strong>存储一个链接地址所需的存储量</strong>，这个量通常很小。</p>
<p>图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p>
<h3 id="顺序表的结构与实现"><a href="#顺序表的结构与实现" class="headerlink" title="顺序表的结构与实现"></a>顺序表的结构与实现</h3><h4 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构"></a>顺序表的结构</h4><p><img src="https://img-blog.csdnimg.cn/20200224163109600.JPG" alt="在这里插入图片描述"></p>
<p>一个顺序表的完整信息包括两部分，一部分是<strong>表中的元素集</strong>合，另一部分是为<strong>实现正确操作而需记录的信息</strong>，即有关表的整体情况的信息，这部分信息主要包括元素<strong>存储区的容量和当前表中已有的元素个数两项</strong>。</p>
<h4 id="顺序表的两种基本实现方式"><a href="#顺序表的两种基本实现方式" class="headerlink" title="顺序表的两种基本实现方式"></a>顺序表的两种基本实现方式</h4><p>在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20200224163132857.JPG" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20200224163132857.JPG</a>)</p>
<p>图a<strong>为一体式结构</strong>，<strong>存储表信息的单元与元素存储区</strong>以<strong>连续</strong>的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。</p>
<p>一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，<strong>元素存储区就固定了</strong>。</p>
<p>图b为<strong>分离式结构</strong>，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在<strong>另一个独立的元素存储区里</strong>，通过<strong>链接与基本表对象关联</strong>。</p>
<h4 id="元素存储区替换"><a href="#元素存储区替换" class="headerlink" title="元素存储区替换"></a>元素存储区替换</h4><p><strong>一体式结构</strong>由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能<strong>整体搬迁</strong>，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。</p>
<p><strong>分离式结构</strong>若想更换数据区，只需将表信息区中的<strong>数据区链接地址更新</strong>即可，而该顺序表对象不变。</p>
<h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3><h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><p><img src="https://img-blog.csdnimg.cn/20200224163155590.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>a. 尾端加入元素，时间复杂度为O(1)</p>
<p>b. 非保序的加入元素（不常见），时间复杂度为O(1)</p>
<p>c. 保序的元素加入，时间复杂度为O(n)</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="https://img-blog.csdnimg.cn/20200224163252924.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>a. 删除表尾元素，时间复杂度为O(1)</p>
<p>b. 非保序的元素删除（不常见），时间复杂度为O(1)</p>
<p>c. 保序的元素删除，时间复杂度为O(n)</p>
<h3 id="python中的数据表"><a href="#python中的数据表" class="headerlink" title="python中的数据表"></a>python中的数据表</h3><p>Python中的<strong>list和tuple两种类型采用了顺序表</strong>的实现技术，具有前面讨论的顺序表的所有性质。</p>
<p>tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。</p>
<h4 id="list的基本实现方式"><a href="#list的基本实现方式" class="headerlink" title="list的基本实现方式"></a>list的基本实现方式</h4><p>Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征：</p>
<ul>
<li>基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；</li>
</ul>
<p>为满足该特征，应该采用顺序表技术，<strong>表中元素保存在一块连续的存储区中。</strong></p>
<ul>
<li>允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。</li>
</ul>
<p>为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，<strong>只能采用分离式实现技术。</strong></p>
<p>在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x)（或list.insert(len(list),x)，即尾部插入）比在指定位置插入元素效率高的原因。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>顺序表</strong>的构建需要预先知道<strong>数据大小来申请连续的存储空间</strong>，而在<strong>进行扩充时又需要进行数据的搬迁</strong>，所以使用起来并不是很灵活。</p>
<p><strong>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。</strong></p>
<blockquote>
<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。</p>
</blockquote>
<h3 id="单项链表"><a href="#单项链表" class="headerlink" title="单项链表"></a>单项链表</h3><p>单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，<strong>一个信息域（元素域）和一个链接域</strong>。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。<br><img src="https://img-blog.csdnimg.cn/20200224163454763.JPG" alt="在这里插入图片描述"></p>
<ul>
<li>表元素域elem用来存放具体的数据。</li>
<li>链接域next用来存放下一个节点的位置（python中的标识）</li>
<li>变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。<h4 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SingleNode(object):</span><br><span class="line">   &quot;&quot;&quot;单链表的节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self,item):</span><br><span class="line">       self.item&#x3D;item</span><br><span class="line">       self.next&#x3D;None</span><br></pre></td></tr></table></figure>
<h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><ul>
<li>is_empty() 链表是否为空</li>
<li>length() 链表长度</li>
<li>travel() 遍历整个链表</li>
<li>add(item) 链表头部添加元素</li>
<li>append(item) 链表尾部添加元素</li>
<li>insert(pos, item) 指定位置添加元素</li>
<li>remove(item) 删除节点</li>
<li>search(item) 查找节点是否存在<h4 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class SingleLinkList(object):</span><br><span class="line">    &quot;&quot;&quot;单链表&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">       self._head&#x3D;None</span><br><span class="line">    def if_empty(self):</span><br><span class="line">       return self._head&#x3D;&#x3D;None</span><br><span class="line">    def length(self):</span><br><span class="line">       cur&#x3D;self._head</span><br><span class="line">       count&#x3D;0</span><br><span class="line">       while cur!&#x3D;None:</span><br><span class="line">          count +&#x3D; 1</span><br><span class="line">          cur&#x3D;cur.next</span><br><span class="line">       return count</span><br><span class="line">    def travel(self):</span><br><span class="line">       &quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span><br><span class="line">       cur&#x3D;self._head</span><br><span class="line">       while cur!&#x3D;None:</span><br><span class="line">          print (cur.item)</span><br><span class="line">          cur&#x3D;cur.next</span><br><span class="line">       print &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>头部添加元素<br><img src="https://img-blog.csdnimg.cn/2020022416360715.JPG" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def add(self,item):</span><br><span class="line">   node&#x3D;SingleNoe(item)</span><br><span class="line">   node.next&#x3D;self._head</span><br><span class="line">   self._head&#x3D;node</span><br></pre></td></tr></table></figure>
<p>尾部添加元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def append(self,item):</span><br><span class="line">    #创建节点</span><br><span class="line">    node&#x3D;SingleNode(item)</span><br><span class="line">    #判断链表是否为空</span><br><span class="line">    if self.is_empty():</span><br><span class="line">      self._head&#x3D;node</span><br><span class="line">    else:</span><br><span class="line">      cur&#x3D;self._head</span><br><span class="line">      while cur.next!&#x3D;None:</span><br><span class="line">         cur&#x3D;cur.next</span><br><span class="line">      cur.next&#x3D;node</span><br></pre></td></tr></table></figure>
<p>指定位置添加元素<br><img src="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95python/44393C63AE554F5794EC67531DA47080" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def insert(self,pos,item):</span><br><span class="line">    #若指定位置pos为第一个元素之前，则执行头部插入</span><br><span class="line">    if pos&lt;&#x3D;0:</span><br><span class="line">      self.add(item)</span><br><span class="line">    #若指定位置超过链表尾部，这执行尾部插入</span><br><span class="line">    elif pos&gt;(self.length()-1):</span><br><span class="line">      self.append(item)</span><br><span class="line">    else:</span><br><span class="line">      node&#x3D;SingleNode(item)</span><br><span class="line">      count&#x3D;0</span><br><span class="line">      pre&#x3D;self._head</span><br><span class="line">      while count&lt;(pos-1):</span><br><span class="line">         count+&#x3D;1</span><br><span class="line">         pre&#x3D;pre.next</span><br><span class="line">     #pre的位置为pos-1</span><br><span class="line">     node.next&#x3D;pre.next</span><br><span class="line">     pre.next&#x3D;node</span><br></pre></td></tr></table></figure>
<p>删除节点<br><img src="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95python/B3615493E19140F1BBD47D40CC576A37" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def remove(self,item):</span><br><span class="line">   cur&#x3D;self._head</span><br><span class="line">   pre&#x3D;None</span><br><span class="line">   while cur !&#x3D;None:</span><br><span class="line">    if cur.item&#x3D;&#x3D;item:</span><br><span class="line">         #如果第一个就是删除的节点</span><br><span class="line">         if not pre：</span><br><span class="line">              self._head&#x3D;cur.next</span><br><span class="line">         else:</span><br><span class="line">              pre.next&#x3D;cur.next</span><br><span class="line">         break</span><br><span class="line">    else:</span><br><span class="line">         pre&#x3D;cur</span><br><span class="line">         cur&#x3D;cur.next</span><br></pre></td></tr></table></figure>

<p>查找节点是否存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def search(self.item):</span><br><span class="line">   cur&#x3D;self._head</span><br><span class="line">   while cur!&#x3D;None:</span><br><span class="line">      if cur.item&#x3D;&#x3D;item:</span><br><span class="line">         return True</span><br><span class="line">      cur&#x3D;cur.next</span><br><span class="line">   return False</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ll &#x3D; SingleLinkList()</span><br><span class="line">    ll.add(1)</span><br><span class="line">    ll.add(2)</span><br><span class="line">    ll.append(3)</span><br><span class="line">    ll.insert(2, 4)</span><br><span class="line">    print &quot;length:&quot;,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    print ll.search(3)</span><br><span class="line">    print ll.search(5)</span><br><span class="line">    ll.remove(1)</span><br><span class="line">    print &quot;length:&quot;,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingleNode(object):</span><br><span class="line">    &quot;&quot;&quot;节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.item &#x3D; item</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingleLinkList(object):</span><br><span class="line">    &quot;&quot;&quot;单链表&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, node&#x3D;None):</span><br><span class="line">        self._head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;</span><br><span class="line">        return self._head &#x3D;&#x3D; None</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;链表长度&quot;&quot;&quot;</span><br><span class="line">        # cur游标，用来移动遍历节点</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        # count记录数量</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            print(cur.item)</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;头部添加元素&quot;&quot;&quot;</span><br><span class="line">        # 先创建一个保存item值的节点</span><br><span class="line">        node &#x3D; SingleNode(item)</span><br><span class="line">        # 将新节点的链接域next指向头节点，即_head指向的位置</span><br><span class="line">        node.next &#x3D; self._head</span><br><span class="line">        # 将链表的头_head指向新节点</span><br><span class="line">        self._head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def append(self, item):</span><br><span class="line">        &quot;&quot;&quot;链表尾部添加元素&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; SingleNode(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head &#x3D; node</span><br><span class="line">        else:</span><br><span class="line">            cur &#x3D; self._head</span><br><span class="line">            while cur.next !&#x3D; None:</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line">            cur.next &#x3D; node</span><br><span class="line"></span><br><span class="line">    def insert(self, pos, item):</span><br><span class="line">        &quot;&quot;&quot;指定位置添加元素&quot;&quot;&quot;</span><br><span class="line">        # 若指定位置pos为第一个元素之前，则执行头部插入</span><br><span class="line">        if pos &lt;&#x3D; 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">        # 若指定位置超过链表尾部，则执行尾部插入</span><br><span class="line">        elif pos &gt; (self.length()-1):</span><br><span class="line">            self.append(item)</span><br><span class="line">        # 找到指定位置</span><br><span class="line">        else:</span><br><span class="line">            node &#x3D; SingleNode(item)</span><br><span class="line">            count &#x3D; 0</span><br><span class="line">            # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置</span><br><span class="line">            pre &#x3D; self._head</span><br><span class="line">            while count &lt; (pos-1):</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">                pre &#x3D; pre.next</span><br><span class="line">            # 先将新节点node的next指向插入位置的节点</span><br><span class="line">            node.next &#x3D; pre.next</span><br><span class="line">            # 将插入位置的前一个节点的next指向新节点</span><br><span class="line">            pre.next &#x3D; node</span><br><span class="line"></span><br><span class="line">    def remove(self,item):</span><br><span class="line">        &quot;&quot;&quot;删除节点&quot;&quot;&quot;</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        pre &#x3D; None</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            # 找到了指定元素</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                # 如果第一个就是删除的节点</span><br><span class="line">                if not pre:</span><br><span class="line">                    # 将头指针指向头节点的后一个节点</span><br><span class="line">                    self._head &#x3D; cur.next</span><br><span class="line">                else:</span><br><span class="line">                    # 将删除位置前一个节点的next指向删除位置的后一个节点</span><br><span class="line">                    pre.next &#x3D; cur.next</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                # 继续按链表后移节点</span><br><span class="line">                pre &#x3D; cur</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line"></span><br><span class="line">    def search(self,item):</span><br><span class="line">        &quot;&quot;&quot;链表查找节点是否存在，并返回True或者False&quot;&quot;&quot;</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                return True</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ll &#x3D; SingleLinkList()</span><br><span class="line">    ll.add(1)</span><br><span class="line">    ll.add(2)</span><br><span class="line">    ll.append(3)# 2 1 3</span><br><span class="line">    ll.insert(2, 4) # 2 1 4 3</span><br><span class="line">    print (&quot;length:&quot;,ll.length())</span><br><span class="line">    ll.travel()#将链表打印</span><br><span class="line">    print (ll.search(3))</span><br><span class="line">    print (ll.search(5))</span><br><span class="line">    ll.remove(1)</span><br><span class="line">    print (&quot;length:&quot;,ll.length())</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h4 id="链表与顺序表对比"><a href="#链表与顺序表对比" class="headerlink" title="链表与顺序表对比"></a>链表与顺序表对比</h4><p>链表失去了<strong>顺序表随机读取</strong>的优点，同时链表由于增加了结点的指针域，<strong>空间开销比较</strong>大，但对<strong>存储空间的使用要相对灵活</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200224163728279.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是<strong>遍历查找</strong>（即从Head开始查找），删除和插入操作本身的复杂度是O(1),但是搜索插入和删除的位置需要从head开始即遍历查找，O(n)。</p>
<p>顺序表查找很快（位置可以计算出来，固定，不需要遍历查找），主要耗时的操作是<strong>拷贝覆盖</strong>。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的<strong>所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行</strong>。</p>
<h3 id="单项循环链表"><a href="#单项循环链表" class="headerlink" title="单项循环链表"></a>单项循环链表</h3><p>单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。<br><img src="https://img-blog.csdnimg.cn/20200224164052575.JPG" alt="在这里插入图片描述"></p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li>is_empty() 判断链表是否为空</li>
<li>length() 返回链表的长度</li>
<li>travel() 遍历</li>
<li>add(item) 在头部添加一个节点</li>
<li>append(item) 在尾部添加一个节点</li>
<li>insert(pos, item) 在指定位置pos添加节点</li>
<li>remove(item) 删除一个节点</li>
<li>search(item) 查找节点是否存在<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    &quot;&quot;&quot;节点&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, item):</span><br><span class="line">        self.item &#x3D; item</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SinCycLinkedlist(object):</span><br><span class="line">    &quot;&quot;&quot;单向循环链表&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._head &#x3D; None</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot;</span><br><span class="line">        return self._head &#x3D;&#x3D; None</span><br><span class="line"></span><br><span class="line">    def length(self):</span><br><span class="line">        &quot;&quot;&quot;返回链表的长度&quot;&quot;&quot;</span><br><span class="line">        # 如果链表为空，返回长度0</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return 0</span><br><span class="line">        count &#x3D; 1</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        while cur.next !&#x3D; self._head:</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def travel(self):</span><br><span class="line">        &quot;&quot;&quot;遍历链表&quot;&quot;&quot;</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        print cur.item,</span><br><span class="line">        while cur.next !&#x3D; self._head:</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">            print cur.item,</span><br><span class="line">        print &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def add(self, item):</span><br><span class="line">        &quot;&quot;&quot;头部添加节点&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head &#x3D; node</span><br><span class="line">            node.next &#x3D; self._head</span><br><span class="line">        else:</span><br><span class="line">            #添加的节点指向_head</span><br><span class="line">            node.next &#x3D; self._head</span><br><span class="line">            # 移到链表尾部，将尾部节点的next指向node</span><br><span class="line">            cur &#x3D; self._head</span><br><span class="line">            while cur.next !&#x3D; self._head:</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line">            cur.next &#x3D; node</span><br><span class="line">            #_head指向添加node的</span><br><span class="line">            self._head &#x3D; node</span><br><span class="line"></span><br><span class="line">    def append(self, item):</span><br><span class="line">        &quot;&quot;&quot;尾部添加节点&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head &#x3D; node</span><br><span class="line">            node.next &#x3D; self._head</span><br><span class="line">        else:</span><br><span class="line">            # 移到链表尾部</span><br><span class="line">            cur &#x3D; self._head</span><br><span class="line">            while cur.next !&#x3D; self._head:</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line">            # 将尾节点指向node</span><br><span class="line">            cur.next &#x3D; node</span><br><span class="line">            # 将node指向头节点_head</span><br><span class="line">            node.next &#x3D; self._head</span><br><span class="line"></span><br><span class="line">    def insert(self, pos, item):</span><br><span class="line">        &quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span><br><span class="line">        if pos &lt;&#x3D; 0:</span><br><span class="line">            self.add(item)</span><br><span class="line">        elif pos &gt; (self.length()-1):</span><br><span class="line">            self.append(item)</span><br><span class="line">        else:</span><br><span class="line">            node &#x3D; Node(item)</span><br><span class="line">            cur &#x3D; self._head</span><br><span class="line">            count &#x3D; 0</span><br><span class="line">            # 移动到指定位置的前一个位置</span><br><span class="line">            while count &lt; (pos-1):</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">                cur &#x3D; cur.next</span><br><span class="line">            node.next &#x3D; cur.next</span><br><span class="line">            cur.next &#x3D; node</span><br><span class="line"></span><br><span class="line">    def remove(self, item):</span><br><span class="line">        &quot;&quot;&quot;删除一个节点&quot;&quot;&quot;</span><br><span class="line">        # 若链表为空，则直接返回</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return</span><br><span class="line">        # 将cur指向头节点</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        pre &#x3D; None</span><br><span class="line">        # 若头节点的元素就是要查找的元素item</span><br><span class="line">        if cur.item &#x3D;&#x3D; item:</span><br><span class="line">            # 如果链表不止一个节点</span><br><span class="line">            if cur.next !&#x3D; self._head:</span><br><span class="line">                # 先找到尾节点，将尾节点的next指向第二个节点</span><br><span class="line">                while cur.next !&#x3D; self._head:</span><br><span class="line">                    cur &#x3D; cur.next</span><br><span class="line">                # cur指向了尾节点</span><br><span class="line">                cur.next &#x3D; self._head.next</span><br><span class="line">                self._head &#x3D; self._head.next</span><br><span class="line">            else:</span><br><span class="line">                # 链表只有一个节点</span><br><span class="line">                self._head &#x3D; None</span><br><span class="line">        else:</span><br><span class="line">            pre &#x3D; self._head</span><br><span class="line">            # 第一个节点不是要删除的</span><br><span class="line">            while cur.next !&#x3D; self._head:</span><br><span class="line">                # 找到了要删除的元素</span><br><span class="line">                if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                    # 删除</span><br><span class="line">                    pre.next &#x3D; cur.next</span><br><span class="line">                    return</span><br><span class="line">                else:</span><br><span class="line">                    pre &#x3D; cur</span><br><span class="line">                    cur &#x3D; cur.next</span><br><span class="line">            # cur 指向尾节点</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                # 尾部删除</span><br><span class="line">                pre.next &#x3D; cur.next</span><br><span class="line"></span><br><span class="line">    def search(self, item):</span><br><span class="line">        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            return False</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        if cur.item &#x3D;&#x3D; item:</span><br><span class="line">            return True</span><br><span class="line">        while cur.next !&#x3D; self._head:</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ll &#x3D; SinCycLinkedlist()</span><br><span class="line">    ll.add(1)</span><br><span class="line">    ll.add(2)</span><br><span class="line">    ll.append(3)</span><br><span class="line">    ll.insert(2, 4)</span><br><span class="line">    ll.insert(4, 5)</span><br><span class="line">    ll.insert(0, 6)</span><br><span class="line">    print &quot;length:&quot;,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    print ll.search(3)</span><br><span class="line">    print ll.search(7)</span><br><span class="line">    ll.remove(1)</span><br><span class="line">    print &quot;length:&quot;,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，<strong>当此节点为第一个节点时，指向空值</strong>；而另一个指向下一个节点，<strong>当此节点为最后一个节点时，指向空值</strong>。<br><img src="https://img-blog.csdnimg.cn/20200224164126882.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul>
<li>is_empty() 链表是否为空</li>
<li>length() 链表长度</li>
<li>travel() 遍历链表</li>
<li>add(item) 链表头部添加</li>
<li>append(item) 链表尾部添加</li>
<li>insert(pos, item) 指定位置添加</li>
<li>remove(item) 删除节点</li>
<li>search(item) 查找节点是否存在<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    #双向链表节点</span><br><span class="line">    def __init__(self,item):</span><br><span class="line">        self.item&#x3D;item</span><br><span class="line">        self.next&#x3D;None</span><br><span class="line">        self.prev&#x3D;None</span><br><span class="line">class DLinkList(object):</span><br><span class="line">    #双向链表</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._head&#x3D;None</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.__head&#x3D;&#x3D;None</span><br><span class="line">    def length(self):</span><br><span class="line">        cur&#x3D;self._head</span><br><span class="line">        count&#x3D;0</span><br><span class="line">        while cur!&#x3D;None:</span><br><span class="line">             count+&#x3D;1</span><br><span class="line">             cur&#x3D;cur.next</span><br><span class="line">        return count</span><br><span class="line">    def travel(self):</span><br><span class="line">        cur&#x3D;self._head</span><br><span class="line">        while cur!&#x3D;None:</span><br><span class="line">            print (cur.item)</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">        print &quot;&quot;</span><br><span class="line">    def add(self,item):</span><br><span class="line">        #在头部插入元素</span><br><span class="line">        node&#x3D;Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head&#x3D;node</span><br><span class="line">        else:</span><br><span class="line">            node.next&#x3D;self._head</span><br><span class="line">            self._head.prev&#x3D;node</span><br><span class="line">            self._head&#x3D;node</span><br><span class="line">    def append(self,item):</span><br><span class="line">        #尾部插入元素</span><br><span class="line">        node&#x3D;Node(item)</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            self._head&#x3D;node</span><br><span class="line">        else:</span><br><span class="line">            #遍历，指针指到链表尾部</span><br><span class="line">            cur&#x3D;self._head</span><br><span class="line">            while cur.next!&#x3D;None:</span><br><span class="line">                cur&#x3D;cur.next</span><br><span class="line">            cur.next&#x3D;node</span><br><span class="line">            node.prev&#x3D;cur</span><br><span class="line">    def search(self,item):</span><br><span class="line">        cur&#x3D;self._head</span><br><span class="line">        while cur!&#x3D;None:</span><br><span class="line">            if cur.item&#x3D;&#x3D;item:</span><br><span class="line">                return True</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h4 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h4><p><img src="https://img-blog.csdnimg.cn/20200224164152289.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def insert(self, pos, item):</span><br><span class="line">    &quot;&quot;&quot;在指定位置添加节点&quot;&quot;&quot;</span><br><span class="line">    if pos &lt;&#x3D; 0:</span><br><span class="line">        self.add(item)</span><br><span class="line">    elif pos &gt; (self.length()-1):</span><br><span class="line">        self.append(item)</span><br><span class="line">    else:</span><br><span class="line">        node &#x3D; Node(item)</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        # 移动到指定位置的前一个位置</span><br><span class="line">        while count &lt; (pos-1):</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">        # 将node的prev指向cur</span><br><span class="line">        node.prev &#x3D; cur</span><br><span class="line">        # 将node的next指向cur的下一个节点</span><br><span class="line">        node.next &#x3D; cur.next</span><br><span class="line">        # 将cur的下一个节点的prev指向node</span><br><span class="line">        cur.next.prev &#x3D; node</span><br><span class="line">        # 将cur的next指向node</span><br><span class="line">        cur.next &#x3D; node</span><br></pre></td></tr></table></figure>
<h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95python/64D5168E018E411FA23F56D7CDABF83C" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def remove(self, item):</span><br><span class="line">    &quot;&quot;&quot;删除元素&quot;&quot;&quot;</span><br><span class="line">    if self.is_empty():</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        cur &#x3D; self._head</span><br><span class="line">        if cur.item &#x3D;&#x3D; item:</span><br><span class="line">            # 如果首节点的元素即是要删除的元素</span><br><span class="line">            if cur.next &#x3D;&#x3D; None:</span><br><span class="line">                # 如果链表只有这一个节点</span><br><span class="line">                self._head &#x3D; None</span><br><span class="line">            else:</span><br><span class="line">                # 将第二个节点的prev设置为None</span><br><span class="line">                cur.next.prev &#x3D; None</span><br><span class="line">                # 将_head指向第二个节点</span><br><span class="line">                self._head &#x3D; cur.next</span><br><span class="line">            return</span><br><span class="line">        while cur !&#x3D; None:</span><br><span class="line">            if cur.item &#x3D;&#x3D; item:</span><br><span class="line">                # 将cur的前一个节点的next指向cur的后一个节点</span><br><span class="line">                cur.prev.next &#x3D; cur.next</span><br><span class="line">                # 将cur的后一个节点的prev指向cur的前一个节点</span><br><span class="line">                cur.next.prev &#x3D; cur.prev</span><br><span class="line">                break</span><br><span class="line">            cur &#x3D; cur.next</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    ll &#x3D; DLinkList()</span><br><span class="line">    ll.add(1)</span><br><span class="line">    ll.add(2)</span><br><span class="line">    ll.append(3)</span><br><span class="line">    ll.insert(2, 4)</span><br><span class="line">    ll.insert(4, 5)</span><br><span class="line">    ll.insert(0, 6)</span><br><span class="line">    print (&quot;length:&quot;,ll.length())</span><br><span class="line">    ll.travel()</span><br><span class="line">    print ll.search(3)</span><br><span class="line">    print ll.search(4)</span><br><span class="line">    ll.remove(1)</span><br><span class="line">    print (&quot;length:&quot;,ll.length())</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈结构实现"><a href="#栈结构实现" class="headerlink" title="栈结构实现"></a>栈结构实现</h3><blockquote>
<p>先进后出</p>
</blockquote>
<h4 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h4><ul>
<li>Stack() 创建一个新的空栈</li>
<li>push(item) 添加一个新的元素item到栈顶</li>
<li>pop() 弹出栈顶元素</li>
<li>peek() 返回栈顶元素</li>
<li>is_empty() 判断栈是否为空</li>
<li>size() 返回栈的元素个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Stack(object):</span><br><span class="line">    #栈</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items&#x3D;[]</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.items&#x3D;&#x3D;[]</span><br><span class="line">    def push(self,item): #压入元素</span><br><span class="line">        self.items.append(item)####</span><br><span class="line">    def pop(self):</span><br><span class="line">        #弹出元素</span><br><span class="line">        return self.items.pop()####</span><br><span class="line">    def peek(self):</span><br><span class="line">        #返回栈顶元素</span><br><span class="line">        return self.items[len(self.items)-1]</span><br><span class="line">    def size(self):</span><br><span class="line">        #返回栈的大小</span><br><span class="line">        return len(self.items)</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    stack &#x3D; Stack()</span><br><span class="line">    stack.push(&quot;hello&quot;)</span><br><span class="line">    stack.push(&quot;world&quot;)</span><br><span class="line">    stack.push(&quot;itcast&quot;)</span><br><span class="line">    print (stack.size())</span><br><span class="line">    print (stack.peek())#返回栈顶元素</span><br><span class="line">    print (stack.pop())</span><br><span class="line">    print (stack.pop())</span><br><span class="line">    print (stack.pop())</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong></p>
<p><strong>队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作！</strong></p>
<p>假设队列是q=（a1，a2，……，an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。</p>
<h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>同栈一样，队列也可以用顺序表或者链表实现。</p>
<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><ul>
<li>Queue() 创建一个空的队列</li>
<li>enqueue(item) 往队列中添加一个item元素</li>
<li>dequeue() 从队列头部删除一个元素</li>
<li>is_empty() 判断一个队列是否为空</li>
<li>size() 返回队列的大小<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Queue(object):</span><br><span class="line">    &quot;&quot;&quot;队列&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items &#x3D; []</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.items &#x3D;&#x3D; []</span><br><span class="line"></span><br><span class="line">    def enqueue(self, item):</span><br><span class="line">        &quot;&quot;&quot;进队列&quot;&quot;&quot;</span><br><span class="line">        self.items.insert(0,item)</span><br><span class="line"></span><br><span class="line">    def dequeue(self):</span><br><span class="line">        &quot;&quot;&quot;出队列&quot;&quot;&quot;</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        &quot;&quot;&quot;返回大小&quot;&quot;&quot;</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    q &#x3D; Queue()</span><br><span class="line">    q.enqueue(&quot;hello&quot;)</span><br><span class="line">    q.enqueue(&quot;world&quot;)</span><br><span class="line">    q.enqueue(&quot;itcast&quot;)</span><br><span class="line">    print (q.size())</span><br><span class="line">    print (q.dequeue())</span><br><span class="line">    print (q.dequeue())</span><br><span class="line">    print (q.dequeue())</span><br></pre></td></tr></table></figure>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。</p>
<p>双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。</p>
<h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ul>
<li>Deque() 创建一个空的双端队列</li>
<li>add_front(item) 从队头加入一个item元素</li>
<li>add_rear(item) 从队尾加入一个item元素</li>
<li>remove_front() 从队头删除一个item元素</li>
<li>remove_rear() 从队尾删除一个item元素</li>
<li>is_empty() 判断双端队列是否为空</li>
<li>size() 返回队列的大小<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Deque(object):</span><br><span class="line">    &quot;&quot;&quot;双端队列&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items &#x3D; []</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        &quot;&quot;&quot;判断队列是否为空&quot;&quot;&quot;</span><br><span class="line">        return self.items &#x3D;&#x3D; []</span><br><span class="line"></span><br><span class="line">    def add_front(self, item):</span><br><span class="line">        &quot;&quot;&quot;在队头添加元素&quot;&quot;&quot;</span><br><span class="line">        self.items.insert(0,item)</span><br><span class="line"></span><br><span class="line">    def add_rear(self, item):</span><br><span class="line">        &quot;&quot;&quot;在队尾添加元素&quot;&quot;&quot;</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def remove_front(self):</span><br><span class="line">        &quot;&quot;&quot;从队头删除元素&quot;&quot;&quot;</span><br><span class="line">        return self.items.pop(0)</span><br><span class="line"></span><br><span class="line">    def remove_rear(self):</span><br><span class="line">        &quot;&quot;&quot;从队尾删除元素&quot;&quot;&quot;</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def size(self):</span><br><span class="line">        &quot;&quot;&quot;返回队列大小&quot;&quot;&quot;</span><br><span class="line">        return len(self.items)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    deque &#x3D; Deque()</span><br><span class="line">    deque.add_front(1)</span><br><span class="line">    deque.add_front(2)</span><br><span class="line">    deque.add_rear(3)</span><br><span class="line">    deque.add_rear(4)</span><br><span class="line">    print deque.size()# 1 2 3 4</span><br><span class="line">    print (deque.remove_front()) #2</span><br><span class="line">    print (deque.remove_front()) #1</span><br><span class="line">    print (deque.remove_rear()) #4</span><br><span class="line">    print (deque.remove_rear()) #3</span><br></pre></td></tr></table></figure>
<h2 id="树与树算法"><a href="#树与树算法" class="headerlink" title="树与树算法"></a>树与树算法</h2><h4 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h4><ul>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>树的度：一棵树中，最大的节点的度称为树的度；</li>
<li>叶节点或终端节点：<strong>度为零的节点</strong>；</li>
<li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的层次：<strong>从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</strong></li>
<li>树的高度或深度：树中节点的最大层次；</li>
<li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；、</li>
</ul>
<h4 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h4><ul>
<li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<ul>
<li>二叉树：<strong>每个节点最多含有两个子树的树称为二叉树；</strong><ul>
<li>完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，<strong>其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;</strong></li>
<li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li>排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；</li>
<li>霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。<h4 id="树的存储与表示"><a href="#树的存储与表示" class="headerlink" title="树的存储与表示"></a>树的存储与表示</h4></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>顺序存储</strong>：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。<strong>二叉树通常以链式存储。</strong><br><img src="https://img-blog.csdnimg.cn/2020022416434750.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>链式存储</strong>：<br><img src="https://img-blog.csdnimg.cn/20200224164408241.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="常见树的应用"><a href="#常见树的应用" class="headerlink" title="常见树的应用"></a>常见树的应用</h4><ul>
<li>xml，html等，那么编写这些东西的解析器的时候，不可避免用到树</li>
<li>路由协议就是使用了树的算法</li>
<li>mysql数据库索引</li>
<li>文件系统的目录结构</li>
<li>所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h4>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）<h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4></li>
<li>性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）</li>
<li>性质2: 深度为k的二叉树至多有2^k - 1个结点（k&gt;0）</li>
<li>性质3: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;</li>
<li>性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)</li>
<li>性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</li>
</ul>
<p>(1)完全二叉树——若设二叉树的高度为h，<strong>除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数</strong>，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。<br><img src="https://img-blog.csdnimg.cn/20200224164431533.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。<br><img src="https://img-blog.csdnimg.cn/202002241644558.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="二叉树的节点表示以及树的创建"><a href="#二叉树的节点表示以及树的创建" class="headerlink" title="二叉树的节点表示以及树的创建"></a>二叉树的节点表示以及树的创建</h4><p>通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    &quot;&quot;&quot;节点类&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, elem&#x3D;-1, lchild&#x3D;None, rchild&#x3D;None):</span><br><span class="line">        self.elem &#x3D; elem</span><br><span class="line">        self.lchild &#x3D; lchild</span><br><span class="line">        self.rchild &#x3D; rchild</span><br></pre></td></tr></table></figure>
<p>树的创建,创建一个树的类，并给一个root根节点，一开始为空，随后添加节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Tree(object):</span><br><span class="line">    &quot;&quot;&quot;树类&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, root&#x3D;None):</span><br><span class="line">        self.root &#x3D; root</span><br><span class="line"></span><br><span class="line">    def add(self, elem):</span><br><span class="line">        &quot;&quot;&quot;为树添加节点&quot;&quot;&quot;</span><br><span class="line">        node &#x3D; Node(elem)</span><br><span class="line">        #如果树是空的，则对根节点赋值</span><br><span class="line">        if self.root &#x3D;&#x3D; None:</span><br><span class="line">            self.root &#x3D; node</span><br><span class="line">        else: #利用队列</span><br><span class="line">            queue &#x3D; []</span><br><span class="line">            queue.append(self.root)</span><br><span class="line">            #对已有的节点进行层次遍历</span><br><span class="line">            while queue:</span><br><span class="line">                #弹出队列的第一个元素</span><br><span class="line">                cur &#x3D; queue.pop(0)</span><br><span class="line">                if cur.lchild &#x3D;&#x3D; None:</span><br><span class="line">                    cur.lchild &#x3D; node</span><br><span class="line">                    return</span><br><span class="line">                elif cur.rchild &#x3D;&#x3D; None:</span><br><span class="line">                    cur.rchild &#x3D; node</span><br><span class="line">                    return</span><br><span class="line">                else:</span><br><span class="line">                    #如果左右子树都不为空，加入队列继续判断</span><br><span class="line">                    queue.append(cur.lchild)</span><br><span class="line">                    queue.append(cur.rchild)</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>树的遍历是树的一种重要的运算<strong>。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）</strong>。</p>
<p>那么树的两种重要的遍历模式是<strong>深度优先遍历和广度优先遍历</strong>,深度优先一般用<strong>递归</strong>，广度优先一般用<strong>队列</strong>。一般情况下能用递归实现的算法大部分也能用<strong>堆栈</strong>来实现。</p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p>
<ul>
<li>先序遍历 在先序遍历中，我们先访问<strong>根节点</strong>，然后递归使用先序遍历访问<strong>左子树</strong>，再递归使用先序遍历访问<strong>右子树</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def preorder(self, root):</span><br><span class="line">      &quot;&quot;&quot;递归实现先序遍历&quot;&quot;&quot;</span><br><span class="line">      if root &#x3D;&#x3D; None:</span><br><span class="line">          return</span><br><span class="line">      print root.elem</span><br><span class="line">      self.preorder(root.lchild)</span><br><span class="line">      self.preorder(root.rchild)</span><br></pre></td></tr></table></figure>
<ul>
<li>中序遍历 在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def inorder(self, root):</span><br><span class="line">      &quot;&quot;&quot;递归实现中序遍历&quot;&quot;&quot;</span><br><span class="line">      if root &#x3D;&#x3D; None:</span><br><span class="line">          return</span><br><span class="line">      self.inorder(root.lchild)</span><br><span class="line">      print root.elem</span><br><span class="line">      self.inorder(root.rchild)</span><br></pre></td></tr></table></figure>
<ul>
<li>后序遍历 在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点。</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def postorder(self, root):</span><br><span class="line">      &quot;&quot;&quot;递归实现后续遍历&quot;&quot;&quot;</span><br><span class="line">      if root &#x3D;&#x3D; None:</span><br><span class="line">          return</span><br><span class="line">      self.postorder(root.lchild)</span><br><span class="line">      self.postorder(root.rchild)</span><br><span class="line">      print root.elem</span><br></pre></td></tr></table></figure>
<h4 id="广度优先遍历-层次遍历"><a href="#广度优先遍历-层次遍历" class="headerlink" title="广度优先遍历(层次遍历)"></a>广度优先遍历(层次遍历)</h4></li>
</ul>
<p>从树的root开始，从上到下从从左到右遍历整个树的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def breadth_travel(self, root):</span><br><span class="line">        &quot;&quot;&quot;利用队列实现树的层次遍历&quot;&quot;&quot;</span><br><span class="line">        if root &#x3D;&#x3D; None:</span><br><span class="line">            return</span><br><span class="line">        queue &#x3D; []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        while queue:</span><br><span class="line">            node &#x3D; queue.pop(0)</span><br><span class="line">            print node.elem,</span><br><span class="line">            if node.lchild !&#x3D; None:</span><br><span class="line">                queue.append(node.lchild)</span><br><span class="line">            if node.rchild !&#x3D; None:</span><br><span class="line">                queue.append(node.rchild)</span><br></pre></td></tr></table></figure>

<h2 id="排序与搜索"><a href="#排序与搜索" class="headerlink" title="排序与搜索"></a>排序与搜索</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序算法的运作如下：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def bubble_sort(alist):</span><br><span class="line">    for j in range(len(alist)-1,0,-1):</span><br><span class="line">        # j表示每次遍历需要比较的次数，是逐渐减小的</span><br><span class="line">        for i in range(j):</span><br><span class="line">            if alist[i] &gt; alist[i+1]:</span><br><span class="line">                alist[i], alist[i+1] &#x3D; alist[i+1], alist[i]</span><br><span class="line"></span><br><span class="line">li &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：稳定<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def selection_sort(alist):</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    # 需要进行n-1次选择操作</span><br><span class="line">    for i in range(n-1):</span><br><span class="line">        # 记录最小位置</span><br><span class="line">        min_index &#x3D; i</span><br><span class="line">        # 从i+1位置到末尾选择出最小数据</span><br><span class="line">        for j in range(i+1, n):</span><br><span class="line">            if alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index &#x3D; j</span><br><span class="line">        # 如果选择出的数据不在正确位置，进行交换</span><br><span class="line">        if min_index !&#x3D; i:</span><br><span class="line">            alist[i], alist[min_index] &#x3D; alist[min_index], alist[i]</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,226,93,17,77,31,44,55,20]</span><br><span class="line">selection_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(n2)</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：不稳定（考虑升序每次选择最大的情况）<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort(alist):</span><br><span class="line">    # 从第二个位置，即下标为1的元素开始向前插入</span><br><span class="line">    for i in range(1, len(alist)):</span><br><span class="line">        # 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span><br><span class="line">        for j in range(i, 0, -1):</span><br><span class="line">            if alist[j] &lt; alist[j-1]:</span><br><span class="line">                alist[j], alist[j-1] &#x3D; alist[j-1], alist[j]</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">insert_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：稳定<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def quick_sort(alist, start, end):</span><br><span class="line">    &quot;&quot;&quot;快速排序&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 递归的退出条件</span><br><span class="line">    if start &gt;&#x3D; end:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 设定起始元素为要寻找位置的基准元素</span><br><span class="line">    mid &#x3D; alist[start]</span><br><span class="line"></span><br><span class="line">    # low为序列左边的由左向右移动的游标</span><br><span class="line">    low &#x3D; start</span><br><span class="line"></span><br><span class="line">    # high为序列右边的由右向左移动的游标</span><br><span class="line">    high &#x3D; end</span><br><span class="line"></span><br><span class="line">    while low &lt; high:</span><br><span class="line">        # 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span><br><span class="line">        while low &lt; high and alist[high] &gt;&#x3D; mid:</span><br><span class="line">            high -&#x3D; 1</span><br><span class="line">        # 将high指向的元素放到low的位置上</span><br><span class="line">        alist[low] &#x3D; alist[high]</span><br><span class="line"></span><br><span class="line">        # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span><br><span class="line">        while low &lt; high and alist[low] &lt; mid:</span><br><span class="line">            low +&#x3D; 1</span><br><span class="line">        # 将low指向的元素放到high的位置上</span><br><span class="line">        alist[high] &#x3D; alist[low]</span><br><span class="line"></span><br><span class="line">    # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span><br><span class="line">    # 将基准元素放到该位置</span><br><span class="line">    alist[low] &#x3D; mid</span><br><span class="line"></span><br><span class="line">    # 对基准元素左边的子序列进行快速排序</span><br><span class="line">    quick_sort(alist, start, low-1)</span><br><span class="line"></span><br><span class="line">    # 对基准元素右边的子序列进行快速排序</span><br><span class="line">    quick_sort(alist, low+1, end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">quick_sort(alist,0,len(alist)-1)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(nlogn)</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定性：不稳定</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(alist):</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    # 初始步长</span><br><span class="line">    gap &#x3D; n &#x2F; 2</span><br><span class="line">    while gap &gt; 0:</span><br><span class="line">        # 按步长进行插入排序</span><br><span class="line">        for i in range(gap, n):</span><br><span class="line">            j &#x3D; i</span><br><span class="line">            # 插入排序</span><br><span class="line">            while j&gt;&#x3D;gap and alist[j-gap] &gt; alist[j]:</span><br><span class="line">                alist[j-gap], alist[j] &#x3D; alist[j], alist[j-gap]</span><br><span class="line">                j -&#x3D; gap</span><br><span class="line">        # 得到新的步长</span><br><span class="line">        gap &#x3D; gap &#x2F; 2</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">shell_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：根据步长序列的不同而不同</li>
<li>最坏时间复杂度：O(n2)</li>
<li>稳定想：不稳定</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def merge_sort(alist):</span><br><span class="line">    if len(alist) &lt;&#x3D; 1:</span><br><span class="line">        return alist</span><br><span class="line">    # 二分分解</span><br><span class="line">    num &#x3D; len(alist)&#x2F;2</span><br><span class="line">    left &#x3D; merge_sort(alist[:num])</span><br><span class="line">    right &#x3D; merge_sort(alist[num:])</span><br><span class="line">    # 合并</span><br><span class="line">    return merge(left,right)</span><br><span class="line"></span><br><span class="line">def merge(left, right):</span><br><span class="line">    &#39;&#39;&#39;合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组&#39;&#39;&#39;</span><br><span class="line">    #left与right的下标指针</span><br><span class="line">    l, r &#x3D; 0, 0</span><br><span class="line">    result &#x3D; []</span><br><span class="line">    while l&lt;len(left) and r&lt;len(right):</span><br><span class="line">        if left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r +&#x3D; 1</span><br><span class="line">    result +&#x3D; left[l:]</span><br><span class="line">    result +&#x3D; right[r:]</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">alist &#x3D; [54,26,93,17,77,31,44,55,20]</span><br><span class="line">sorted_alist &#x3D; mergeSort(alist)</span><br><span class="line">print(sorted_alist)</span><br></pre></td></tr></table></figure>
<h3 id="常见排序算法比较"><a href="#常见排序算法比较" class="headerlink" title="常见排序算法比较"></a>常见排序算法比较</h3><p><img src="https://img-blog.csdnimg.cn/20200224164553202.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MzU2ODU0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找。</p>
<h4 id="二分法查找实现"><a href="#二分法查找实现" class="headerlink" title="二分法查找实现"></a>二分法查找实现</h4><h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(alist, item):</span><br><span class="line">      first &#x3D; 0</span><br><span class="line">      last &#x3D; len(alist)-1</span><br><span class="line">      while first&lt;&#x3D;last:</span><br><span class="line">          midpoint &#x3D; (first + last)&#x2F;2</span><br><span class="line">          if alist[midpoint] &#x3D;&#x3D; item:</span><br><span class="line">              return True</span><br><span class="line">          elif item &lt; alist[midpoint]:</span><br><span class="line">              last &#x3D; midpoint-1</span><br><span class="line">          else:</span><br><span class="line">              first &#x3D; midpoint+1</span><br><span class="line">    return False</span><br><span class="line">testlist &#x3D; [0, 1, 2, 8, 13, 17, 19, 32, 42,]</span><br><span class="line">print(binary_search(testlist, 3))</span><br><span class="line">print(binary_search(testlist, 13))</span><br></pre></td></tr></table></figure>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(alist, item):</span><br><span class="line">    if len(alist) &#x3D;&#x3D; 0:</span><br><span class="line">        return False</span><br><span class="line">    else:</span><br><span class="line">        midpoint &#x3D; len(alist)&#x2F;&#x2F;2</span><br><span class="line">        if alist[midpoint]&#x3D;&#x3D;item:</span><br><span class="line">          return True</span><br><span class="line">        else:</span><br><span class="line">          if item&lt;alist[midpoint]:</span><br><span class="line">            return binary_search(alist[:midpoint],item)</span><br><span class="line">          else:</span><br><span class="line">            return binary_search(alist[midpoint+1:],item)</span><br><span class="line"></span><br><span class="line">testlist &#x3D; [0, 1, 2, 8, 13, 17, 19, 32, 42,]</span><br><span class="line">print(binary_search(testlist, 3))</span><br><span class="line">print(binary_search(testlist, 13))</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li>最优时间复杂度：O(1)</li>
<li>最坏时间复杂度：O(logn)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%AF%BB%E6%89%BE%E7%8B%AC%E7%AB%8B%E7%89%B9%E5%BE%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%AF%BB%E6%89%BE%E7%8B%AC%E7%AB%8B%E7%89%B9%E5%BE%81/" class="post-title-link" itemprop="url">集体智慧编程_第十章寻找独立特征</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-13 19:18:47 / 修改时间：19:19:30" itemprop="dateCreated datePublished" datetime="2020-02-13T19:18:47+08:00">2020-02-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>除了第三章的聚类算法属于非监督技术之外，其余大部分章节都主要集中在监督分类器上。本章将研究如何在数据集并未明确表示结果的前提下，从中<strong>提取重要的潜在特征来。</strong><br>鸡尾酒宴会。</p>
<h3 id="搜索一组新闻"><a href="#搜索一组新闻" class="headerlink" title="搜索一组新闻"></a>搜索一组新闻</h3><h4 id="选择新闻来源"><a href="#选择新闻来源" class="headerlink" title="选择新闻来源"></a>选择新闻来源</h4><p>选择的订阅源中的新闻内容存在重叠</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import feedparser</span><br><span class="line">import re</span><br><span class="line">feedlist&#x3D;[&#39;http:&#x2F;&#x2F;...&#39;,&#39;http:&#x2F;&#x2F;...&#39;]</span><br></pre></td></tr></table></figure>
<h4 id="下载新闻来源"><a href="#下载新闻来源" class="headerlink" title="下载新闻来源"></a>下载新闻来源</h4><p>接受一个大型的数据矩阵，每行代表一个数据项，每列代表数据项的一个属性。在本例中，行对应各类文章，列对应单词。<br>从订阅源中得到矩阵如下：</p>
<p>删除文章中所有的图片和HTNL标注</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def striphtml(h):</span><br><span class="line">   p&#x3D;&#39;&#39;</span><br><span class="line">   s&#x3D;0</span><br><span class="line">   for c in h:</span><br><span class="line">      if c&#x3D;&#x3D;&#39;&lt;&#39;:s&#x3D;1</span><br><span class="line">      elif c&#x3D;&#x3D;&#39;&gt;&#39;:s&#x3D;0 p+&#x3D;&#39; &#39;</span><br><span class="line">      elif s&#x3D;&#x3D;0:p+&#x3D;c</span><br><span class="line">   return p</span><br></pre></td></tr></table></figure>
<p>拆分文本中的单词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def separatewords():</span><br><span class="line">   splitter&#x3D;re.compile(&#39;\\W*&#39;)</span><br><span class="line">   return [s.lower() for s in splitter.split(text) if len(s)&gt;3]</span><br></pre></td></tr></table></figure>
<p>综合以上算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def getarticlewords():</span><br><span class="line">   allwords&#x3D;&#123;&#125;</span><br><span class="line">   articlewords&#x3D;[]</span><br><span class="line">   articletitles&#x3D;[]</span><br><span class="line">   ec&#x3D;0</span><br><span class="line">   for feed in feedlist:</span><br><span class="line">      f&#x3D;feedparser.parse(feed)</span><br><span class="line">      for e in f.entries:</span><br><span class="line">         if e.title in  articletitles:continue</span><br><span class="line">         #提取单词</span><br><span class="line">         txt&#x3D;e.title.encode(&#39;utf8&#39;)+stripHTML(e.description.encode(&#39;utf8&#39;))</span><br><span class="line">         words&#x3D;separatewords(txt)</span><br><span class="line">         articlewords.append(&#123;&#125;)</span><br><span class="line">         articletitles.append(e.title)</span><br><span class="line">         </span><br><span class="line">         for word in words:</span><br><span class="line">            allwords.setdefault(word,0)</span><br><span class="line">            allwords[word]+&#x3D;1</span><br><span class="line">            articlewords[ec],setdefault(word,0)</span><br><span class="line">            articlewords[ec][word]+&#x3D;1</span><br><span class="line">        ec+&#x3D;1</span><br><span class="line">  return allwords,articlewords,articletitles</span><br></pre></td></tr></table></figure>
<h4 id="转换成矩阵"><a href="#转换成矩阵" class="headerlink" title="转换成矩阵"></a>转换成矩阵</h4><p>在超过三篇文章中出现过，但在所有文章中出现的比例小于60%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def makematrix(allw,articlew):</span><br><span class="line">   wordvec&#x3D;[]</span><br><span class="line">   for w,c in allw.items():</span><br><span class="line">      if c&gt;3 and c&lt;len(articlew)*0.6:</span><br><span class="line">         wordvec.append(w)</span><br><span class="line">   l1&#x3D;[[(word in f and f[word] or 0)for word in wordvec]for f in articlew]</span><br><span class="line">   return l1,wordvec</span><br></pre></td></tr></table></figure>
<h3 id="先前的方法"><a href="#先前的方法" class="headerlink" title="先前的方法"></a>先前的方法</h3><h4 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h4><p>监督学习法。首先必须对几个样本故事进行分类。必须确定不同的分类。</p>
<h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><p>唯一一种非监督方法。</p>
<h3 id="非负矩阵因式分解NMF"><a href="#非负矩阵因式分解NMF" class="headerlink" title="非负矩阵因式分解NMF"></a>非负矩阵因式分解NMF</h3><p>特征矩阵：代表某个单词相对于某个特征的重要程度。</p>
<p>权值矩阵：将特征矩阵映射到文章矩阵。每个数字代表每个特征应用于每篇文章的程度。</p>
<p>文章矩阵为权值矩阵*特征矩阵。</p>
<h4 id="使用NUMPY"><a href="#使用NUMPY" class="headerlink" title="使用NUMPY"></a>使用NUMPY</h4><p>矩阵分解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def factorize(v,pc&#x3D;10,iter&#x3D;50):</span><br><span class="line">   ic&#x3D;shape(v)[0]</span><br><span class="line">   fc&#x3D;shape(v)[1]</span><br><span class="line">   w&#x3D;matrix([random.random() for j i range(pc)] for i in range(ic)])</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>

<p>略</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%A0%B8%E6%96%B9%E6%B3%95%E4%B8%8ESVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%A0%B8%E6%96%B9%E6%B3%95%E4%B8%8ESVM/" class="post-title-link" itemprop="url">集体智慧编程_第九章核方法与SVM</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-13 17:39:21 / 修改时间：17:40:14" itemprop="dateCreated datePublished" datetime="2020-02-13T17:39:21+08:00">2020-02-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为约会网站的用户寻找配对；数据包含数值型、名词性和大量的非线性关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class matchrow：</span><br><span class="line">    def __init__(self,row,allnum&#x3D;False):</span><br><span class="line">        if allnum:</span><br><span class="line">           self.data&#x3D;[float(row[i]) for i in range(len(row)-1)</span><br><span class="line">        else:</span><br><span class="line">           self.data&#x3D;row[0:len(data)-1]</span><br><span class="line">        self.match&#x3D;int(row[len(row)-1]))</span><br><span class="line">    def loadmatch(f,allnum&#x3D;False):</span><br><span class="line">        rows&#x3D;[]</span><br><span class="line">        for line in file(f):</span><br><span class="line">            rows.append(matchrow(line.split(&#39;,&#39;),allnum))</span><br><span class="line">        return rows</span><br></pre></td></tr></table></figure>
<h4 id="基本的线性分类"><a href="#基本的线性分类" class="headerlink" title="基本的线性分类"></a>基本的线性分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def lineartrain(rows):</span><br><span class="line">    averages&#x3D;&#123;&#125;</span><br><span class="line">    counts&#x3D;&#123;&#125;</span><br><span class="line">    for row in rows:</span><br><span class="line">        c1&#x3D;row.match</span><br><span class="line">        averages.setdefault(c1,[0.0]*(len(row.data)))</span><br><span class="line">        counts,setdefault(c1,0)</span><br><span class="line">        for i in range(len(row.data)):</span><br><span class="line">           averages[c1][i]&#x3D;float(row.data[i])</span><br><span class="line">        counts[c1]+&#x3D;1</span><br><span class="line">    for c1,avg in averages.items():</span><br><span class="line">        for i in range(len(avg)):</span><br><span class="line">            avg[i]&#x3D;avg[i]&#x2F;counts[c1]</span><br><span class="line">    return averages</span><br><span class="line">    确定匹配和不匹配状态下的数据的平均值，显示在图上。</span><br></pre></td></tr></table></figure>
<p>点积。class=sign((x-(m0+m1)/2)*(m0-m1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def dotproduct(v1,v2):</span><br><span class="line">    return sum([v1[i]*v2[i] for i in range(len(v1))])</span><br><span class="line">    </span><br><span class="line">def dpclassify(point,avgs):</span><br><span class="line">    b&#x3D;(dotproduct(avgs[1],avgs[1])-dotproduct(avgs[0],avgs[0]))&#x2F;2</span><br><span class="line">    y&#x3D;dotproduct(point,avgs[0])-dotproduct(point,avgs[1])+b</span><br><span class="line">    if y&gt;0: return 0</span><br><span class="line">    else: return 1</span><br></pre></td></tr></table></figure>
<h4 id="分类特征"><a href="#分类特征" class="headerlink" title="分类特征"></a>分类特征</h4><p>将数据转化为数值型。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def yesno(v):</span><br><span class="line">    if v&#x3D;&#x3D;&#39;yes&#39;: return 1</span><br><span class="line">    elif v&#x3D;&#x3D;&#39;no&#39;:return -1</span><br><span class="line">    else: return 0</span><br></pre></td></tr></table></figure>
<h4 id="兴趣列表"><a href="#兴趣列表" class="headerlink" title="兴趣列表"></a>兴趣列表</h4><p>统计具有相同的兴趣个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def matchcount(interest1,interest2):</span><br><span class="line">    l1&#x3D;interest1.split(&#39;:&#39;)</span><br><span class="line">    l2&#x3D;interest2.split(&#39;:&#39;)</span><br><span class="line">    x&#x3D;0</span><br><span class="line">    for v in l1:</span><br><span class="line">        if v in l2:</span><br><span class="line">           x+&#x3D;1</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>
<h4 id="利用Yahoo-Maps来确定距离"><a href="#利用Yahoo-Maps来确定距离" class="headerlink" title="利用Yahoo! Maps来确定距离"></a>利用Yahoo! Maps来确定距离</h4><p>略</p>
<h4 id="构造新的数据集"><a href="#构造新的数据集" class="headerlink" title="构造新的数据集"></a>构造新的数据集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def loadnumerical():</span><br><span class="line">    oldrows&#x3D;loadmatch(&#39;matchmaker.csv&#39;)</span><br><span class="line">    newrows&#x3D;[]</span><br><span class="line">    for row in oldrows:</span><br><span class="line">       d&#x3D;row.data</span><br><span class="line">       data&#x3D;[float(d[0]),yesno(d[1]),yesno(d[2]),float(d[5]),yesno(d[6]),yesno(d[7]),matchcount(d[3],d[8]),milesdistance(d[4],d[9]),</span><br><span class="line">       row.match]</span><br><span class="line">       newrows.append(matchrow(data))</span><br><span class="line">    return newrows</span><br></pre></td></tr></table></figure>
<h4 id="对数据进行缩放处理"><a href="#对数据进行缩放处理" class="headerlink" title="对数据进行缩放处理"></a>对数据进行缩放处理</h4><p>将所有数据转化为0-1之间的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def scaledata(rows):</span><br><span class="line">   low&#x3D;[99999999]*len(rows[0].data)</span><br><span class="line">   high&#x3D;[-9999999]*len(rows[0].data)</span><br><span class="line">   for row in rows:</span><br><span class="line">      d&#x3D;row.data</span><br><span class="line">      for i in range(len(d)):</span><br><span class="line">         if d[i]&lt;low[i]: low[i]&#x3D;d[i]</span><br><span class="line">         if d[i]&gt;high[i]: high[i]&#x3D;d[i]</span><br><span class="line">  def scaleinput(d):</span><br><span class="line">    return     [(d.data[i]-low[i])&#x2F;(high[i]-low[i])       </span><br><span class="line">    for i in range(len(low))]</span><br><span class="line">  newrows&#x3D;[matchrow(scaleinput(row.data)+[row.match]) for row in rows]</span><br><span class="line">  </span><br><span class="line">  return newrows,scaleinput</span><br></pre></td></tr></table></figure>
<h4 id="理解核方法"><a href="#理解核方法" class="headerlink" title="理解核方法"></a>理解核方法</h4><p>我们可以预先的坐标点进行变换，构造一个用一条直线就可以进行划分的新数据集。</p>
<h5 id="核技法"><a href="#核技法" class="headerlink" title="核技法"></a>核技法</h5><p>用一个新的函数来取代原来的点积函数，当借助某个映射函数将数据第一次变换到更高纬度的坐标空间时，新函数将会返回高纬度坐标空间的点积结果。————径向基函数。是非线性的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def rbf(v1,v2,gamma&#x3D;20):</span><br><span class="line">    dv&#x3D;[v1[i]-v2[i] for i in range(len(v1))]</span><br><span class="line">    l&#x3D;veclength(dv)</span><br><span class="line">    return math.e**(-gamma*l)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def getoffset(rows,gamma&#x3D;10):</span><br><span class="line">略</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def nlclassify(point,rows,offset,gamma&#x3D;10)</span><br><span class="line">    sum0&#x3D;0</span><br><span class="line">    sum1&#x3D;0</span><br><span class="line">    count1&#x3D;0</span><br><span class="line">    count0&#x3D;0</span><br><span class="line">    for row in rows:</span><br><span class="line">        if row.match&#x3D;&#x3D;0:</span><br><span class="line">             sum0+&#x3D;rbf(point,row.data,gamma)</span><br><span class="line">             count0+&#x3D;1</span><br><span class="line">        else:</span><br><span class="line">             sum1+&#x3D;rbf(point,row.data,gamma)</span><br><span class="line">             count1+&#x3D;1</span><br><span class="line">    y&#x3D;(1&#x2F;count0)*sum0-(1&#x2F;count1)*sum1+offset</span><br><span class="line">    </span><br><span class="line">    if y&lt;0:return 0</span><br><span class="line">    else return 1 #将经过处理的数据进行判别(dpclassify)</span><br></pre></td></tr></table></figure>

<h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><p><img src="/2020/02/13/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%A0%B8%E6%96%B9%E6%B3%95%E4%B8%8ESVM/C1343EB5CB5D470ABFC26C3D334CCC9B" alt="image"></p>
<p>我们引入一个LIBSVM的开源库，它能够对SVM模型进行训练、给出预测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from svm import *</span><br><span class="line">prob&#x3D;svm_problem([1,-1],[[1,0,1],[-1,0,-1]])</span><br><span class="line">param&#x3D;svm_parameter(kernel_type&#x3D;LINEAR,C&#x3D;10)</span><br><span class="line">#训练</span><br><span class="line">m&#x3D;svm_model(prob,param)</span><br><span class="line">#预测</span><br><span class="line">m.predice([1,1,1])</span><br></pre></td></tr></table></figure>
<h5 id="用SVM用于婚介数据集-系统自带的函数"><a href="#用SVM用于婚介数据集-系统自带的函数" class="headerlink" title="用SVM用于婚介数据集,系统自带的函数"></a>用SVM用于婚介数据集,系统自带的函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">answers,inputs&#x3D;[r.match for r in scaledset],[r.data for r in scaledset]</span><br><span class="line">param&#x3D;svm_parameter(kernel_type&#x3D;RBF)</span><br><span class="line">prob&#x3D;svm_problem(answers,inputs)</span><br><span class="line">m&#x3D;svm_model(prob,param)</span><br><span class="line"></span><br><span class="line">m.predict(scalef(newrow))</span><br><span class="line">#利用交叉验证函数来检验模型的质量...</span><br><span class="line">g&#x3D;cross_validation(prob,param,4)</span><br><span class="line">n&#x3D;sum([abs(answers[i]-g[i]) for i in range(len(g))</span><br></pre></td></tr></table></figure>
<p>若n=116,由于初始集为500，则得到了384项正确匹配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/10/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%B3%E7%AD%96%E6%A0%91%E5%BB%BA%E6%A8%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%86%B3%E7%AD%96%E6%A0%91%E5%BB%BA%E6%A8%A1/" class="post-title-link" itemprop="url">集体智慧编程_第七章决策树建模</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-10 15:26:14 / 修改时间：15:27:07" itemprop="dateCreated datePublished" datetime="2020-02-10T15:26:14+08:00">2020-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="预测注册用户"><a href="#预测注册用户" class="headerlink" title="预测注册用户"></a>预测注册用户</h3><p>针对某个web站点的用户行为及其最终购买决策。最后一栏的服务类型是我们需要预测的内容。<br>来源网站、位置、是否阅读过FAQ、浏览网页数、选择服务类型。</p>
<p>将数据文件加载进来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_data&#x3D;[line.split(&#39;\t&#39;) for line in file(&#39;decision_tree.txt&#39;)]</span><br></pre></td></tr></table></figure>
<h4 id="引入决策树"><a href="#引入决策树" class="headerlink" title="引入决策树"></a>引入决策树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class decisionnode:</span><br><span class="line">   def __init__(self,col&#x3D;-1,value&#x3D;None,results&#x3D;None,tb&#x3D;None,fb&#x3D;None):</span><br><span class="line">     self.col&#x3D;col</span><br><span class="line">     self.value&#x3D;value</span><br><span class="line">     self.results&#x3D;results</span><br><span class="line">     self.tb&#x3D;tb</span><br><span class="line">     self.fb&#x3D;fb</span><br></pre></td></tr></table></figure>
<h4 id="对树进行训练"><a href="#对树进行训练" class="headerlink" title="对树进行训练"></a>对树进行训练</h4><p>根据某一栏的数据将列表拆分成两个数据集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def divideset(rows,column,value):</span><br><span class="line">    #rows为数据集，columns为某一列的名字，</span><br><span class="line">    split_function&#x3D;None</span><br><span class="line">    if isinstance(value,int) or isinstance(value,float):</span><br><span class="line">        #如果value是数值型数据</span><br><span class="line">        #分成两组,row[column]&gt;&#x3D;value的返回true</span><br><span class="line">        split_function&#x3D;lambda row:row[column]&gt;&#x3D;value</span><br><span class="line">    else:#名词性数据</span><br><span class="line">        split_function&#x3D;lambda row:row[column]&#x3D;value</span><br><span class="line">    set1&#x3D;[row for row in rows if split_function(row)]</span><br><span class="line">    set2&#x3D;[row for row in rows if not split_function(row)]</span><br><span class="line">    return (set1,set2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dividest(my_data,2,&#39;yes&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="选择最合适的拆分方案"><a href="#选择最合适的拆分方案" class="headerlink" title="选择最合适的拆分方案"></a>选择最合适的拆分方案</h3><p>对数据集中最后一列的结果进行计数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def uniquecounts(rows):</span><br><span class="line">    results&#x3D;&#123;&#125;</span><br><span class="line">    for row in rows:</span><br><span class="line">       #计数结果在最后一列</span><br><span class="line">       r&#x3D;row[len(row)-1]</span><br><span class="line">       if r not in results: results[r]&#x3D;0</span><br><span class="line">       results[r]+&#x3D;1</span><br><span class="line">     return results</span><br></pre></td></tr></table></figure>
<h4 id="基尼不纯度"><a href="#基尼不纯度" class="headerlink" title="基尼不纯度"></a>基尼不纯度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def giniimpurity(rows):</span><br><span class="line">    total&#x3D;len(rows)</span><br><span class="line">    counts&#x3D;uniquecounts(rows)</span><br><span class="line">    imp&#x3D;0</span><br><span class="line">    for k1 in counts:</span><br><span class="line">        p1&#x3D;float(counts[k1])&#x2F;total</span><br><span class="line">        for k2 in counts:</span><br><span class="line">          if k1&#x3D;&#x3D;k2:continue</span><br><span class="line">          p2&#x3D;float(counts[k2])&#x2F;total</span><br><span class="line">          imp+&#x3D;p2*p1</span><br><span class="line">    return imp</span><br></pre></td></tr></table></figure>
<h4 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def entropy(rows):</span><br><span class="line">    from math import log</span><br><span class="line">    log2&#x3D;lambda x:log(x)&#x2F;log(2)</span><br><span class="line">    results&#x3D;uniquecounts(rows)</span><br><span class="line">    ent&#x3D;0</span><br><span class="line">    for r in results.keys():</span><br><span class="line">       p&#x3D;float(results[r])&#x2F;len(rows)</span><br><span class="line">       ent&#x3D;ent-p*log2(p)</span><br><span class="line">     return ent</span><br></pre></td></tr></table></figure>

<h3 id="以递归的方式构造树"><a href="#以递归的方式构造树" class="headerlink" title="以递归的方式构造树"></a>以递归的方式构造树</h3><p>通过为当前数据集选择最合适的拆分条件来构造树。<br>函数首先接受一个由数据行构成的列表作为参数。它遍历了数据集中的每一列，针对各列查找每一种可能的取值，并将数据集拆分成两个新的子集。通过将每个子集的熵乘以子集中所含数据项在原数据集中所占的比重，并记录熵最低的那一对集。如果该值比当前集合的熵大，则拆分过程结束。否则继续使用buildtree函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def buildtree(rows,scoref&#x3D;entropy):</span><br><span class="line">   if len(rows)&#x3D;&#x3D;0 return decisionnode()</span><br><span class="line">   current_score&#x3D;scoref(rows)</span><br><span class="line">   </span><br><span class="line">   best_gain&#x3D;0</span><br><span class="line">   best_criteria&#x3D;None</span><br><span class="line">   best_sets&#x3D;None</span><br><span class="line">   </span><br><span class="line">   #最后一列</span><br><span class="line">   column_count&#x3D;len(rows[0])-1</span><br><span class="line">   #不包括最后一列</span><br><span class="line">   for col in range(0,column_count):</span><br><span class="line">      column_values&#x3D;&#123;&#125;</span><br><span class="line">      for row in rows:</span><br><span class="line">          column_values[row[col]]&#x3D;1#获得该col列的值</span><br><span class="line">      #根据该列中的每个值，尝试对数据集进行划分</span><br><span class="line">      for value in column_values.keys():</span><br><span class="line">          (set1,set2)&#x3D;dividest(rows,col,value)</span><br><span class="line">          p&#x3D;float(len(set1))&#x2F;len(rows)</span><br><span class="line">          gain&#x3D;current_score-p*scoref(set1)-(1-p)*scoref(set2)</span><br><span class="line">          if gain&gt;best_gain and len(set1)&gt;0 and len(set2)&gt;0:</span><br><span class="line">              best_gain&#x3D;gain</span><br><span class="line">              best_criteria&#x3D;(col,value)</span><br><span class="line">              best_sets&#x3D;(set1,set2)</span><br><span class="line">    #创建子分支</span><br><span class="line">    if best_gain&gt;0:</span><br><span class="line">       truebranch&#x3D;buildtree(bestsets[0])</span><br><span class="line">       falsebranch&#x3D;buildtree(bestsets[1])</span><br><span class="line">       return decisionnode(col&#x3D;best_criteria[0],</span><br><span class="line">       value&#x3D;best_criteria[1],tb&#x3D;truebranch,fb&#x3D;falsebranch)</span><br><span class="line">    else:</span><br><span class="line">       return decisionnode(results&#x3D;uniquecounts(rows))</span><br></pre></td></tr></table></figure>

<h3 id="决策树的显示"><a href="#决策树的显示" class="headerlink" title="决策树的显示"></a>决策树的显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def printtree(tree,indent&#x3D;&#39; &#39;):</span><br><span class="line">    if tree.results!&#x3D;None:</span><br><span class="line">      print str(tree.results)</span><br><span class="line">    else:</span><br><span class="line">      print str(tree.col)+&#39;:&#39;+str(tree.value)+&#39;?&#39;</span><br><span class="line">      print indent+&#39;T-&gt;&#39;</span><br><span class="line">      printtree(tree.tb,indent+&#39; &#39;)</span><br><span class="line">      print indent+&#39;F-&gt;&#39;</span><br><span class="line">      printtree(tree.fb,indent+&#39; &#39;)</span><br></pre></td></tr></table></figure>
<h3 id="对新的观测数据进行分类"><a href="#对新的观测数据进行分类" class="headerlink" title="对新的观测数据进行分类"></a>对新的观测数据进行分类</h3><p>我们对新的观测数据作为参数，然后根据决策树进行分类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def classify(observation,tree):</span><br><span class="line">    if tree.results!&#x3D;None:</span><br><span class="line">       return tree.results</span><br><span class="line">    else:</span><br><span class="line">       v&#x3D;observation[tree.col]</span><br><span class="line">       branch&#x3D;None</span><br><span class="line">       if isinstance(v,int) or isinstance(v,float):</span><br><span class="line">          if v&gt;&#x3D;tree.value: branch&#x3D;tree.tb</span><br><span class="line">          else: branch&#x3D;tree.fb</span><br><span class="line">       else:</span><br><span class="line">          if v&#x3D;&#x3D;tree.value: branch&#x3D;tree.tb</span><br><span class="line">          else: branch&#x3D;tree.fb</span><br><span class="line">    return classify(observation,branch)</span><br></pre></td></tr></table></figure>
<h3 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h3><p>存在过拟合现象，会比实际情况根据特殊性。它可能是专门针对训练集所创建的分支，其熵值比真实情况低。解决办法：当熵减少的数量小于某个最小值时，我们就停止分支的创建。剪枝就是消除多余的节点。</p>
<p>剪枝的过程就是对具有相同父节点的一组节点进行检查，如果将其合并，熵的增加值是否会小于某个指定的阈值。如果确实如此，则将其合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def prune(tree,mingain):</span><br><span class="line">    #如果分支不是叶节点，则进行剪枝</span><br><span class="line">    if tree.tb.results&#x3D;&#x3D;None:</span><br><span class="line">      prune(tree.tb,mingain)</span><br><span class="line">    if tree.fb.results&#x3D;&#x3D;None:</span><br><span class="line">      prune(tree.fb,mingain)</span><br><span class="line">    #如果两个子分支都是叶节点，则判断它们是否需要合并</span><br><span class="line">    if tree.tb.results!&#x3D;None and tree.fb.results!&#x3D;None</span><br><span class="line">       tb,fb&#x3D;[],[]</span><br><span class="line">       for v,c in tree.tb.results.items():</span><br><span class="line">           tb+&#x3D;[[v]]*c</span><br><span class="line">       for v,c in tree.fb.results.items():</span><br><span class="line">           fb+&#x3D;[[v]]*c    </span><br><span class="line">       delta&#x3D;entrop(tb+fb)-(entropy(tb)+entropy(fb)&#x2F;2)</span><br><span class="line">       if delta&lt;mingain:</span><br><span class="line">          tree.tb,tree.fb&#x3D;None,None</span><br><span class="line">          tree.results&#x3D;uniquecounts(tb,fb)</span><br></pre></td></tr></table></figure>
<h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>加权统计</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def mdclassify(observation,tree):</span><br><span class="line">    if tree.results!&#x3D;None:</span><br><span class="line">       return tree.results</span><br><span class="line">     else:</span><br><span class="line">       v&#x3D;observation[tree.col]</span><br><span class="line">       if v&#x3D;&#x3D;None:</span><br><span class="line">          tr,fr&#x3D;mdclassify(observation,tree.tb),mdclassify(observation,tree.fb)</span><br><span class="line">          tcount&#x3D;sum(tr.values())</span><br><span class="line">          fcount&#x3D;sum(fr.values())</span><br><span class="line">          tw&#x3D;float(tcount)&#x2F;(tcount+fcount)</span><br><span class="line">          ....</span><br></pre></td></tr></table></figure>
<p>决策树最大的优势就在于它可以轻易地对一个受训模型进行解释。决策树可以同时接受分类数据和数值数据作为输入。还允许数据的不确定性分配。对于少数的几种可能的结果有效。本章的决策树只能创建满足“大于\小于”条件的节点。决策树最适合处理的是那些带有分界点的、由大量的分类数据和数值数据共同组成的数据集。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://annen-stack.github.io/2020/02/10/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%96%87%E6%A1%A3%E8%BF%87%E6%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="annen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/%E9%9B%86%E4%BD%93%E6%99%BA%E6%85%A7%E7%BC%96%E7%A8%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%96%87%E6%A1%A3%E8%BF%87%E6%BB%A4/" class="post-title-link" itemprop="url">集体智慧编程_第六章文档过滤</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-10 06:38:10 / 修改时间：06:38:32" itemprop="dateCreated datePublished" datetime="2020-02-10T06:38:10+08:00">2020-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="文档和单词"><a href="#文档和单词" class="headerlink" title="文档和单词"></a>文档和单词</h3><p>将单词作为特征。将任何非字母类字符为分隔符对文本进行划分，将文本拆分为一个个单词，并转化成小写形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import math</span><br><span class="line">def getwords(doc):</span><br><span class="line">    splitter.re.compile(&#39;\\W*&#39;)</span><br><span class="line">    words&#x3D;[s.lower() for s in splitter.split(doc) if len(s)&gt;2 and len(s)&lt;20]</span><br><span class="line">    #只返回一组不重复的单词</span><br><span class="line">    return dict([(w,1) for w in words])</span><br></pre></td></tr></table></figure>
<h3 id="对分类器进行训练"><a href="#对分类器进行训练" class="headerlink" title="对分类器进行训练"></a>对分类器进行训练</h3><p>首先编写一个代表分类器的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class classifier:</span><br><span class="line">    def __init__(self,getfeatures,filename&#x3D;None):</span><br><span class="line">        #统计特征、分类组合的数量</span><br><span class="line">        self.fc&#x3D;&#123;&#125;</span><br><span class="line">        #统计每个分类中的文档数量</span><br><span class="line">        self.cc&#x3D;&#123;&#125;</span><br><span class="line">        self.getfeatures&#x3D;getfeatures</span><br></pre></td></tr></table></figure>

<p>fc将记录位于各分类中不同特征的数量：</p>
<p>{‘python’:{‘bad’:0,’good’:6},’the’:{‘bad’:3,’good’:3}}</p>
<p>变量cc表示记录各分类被使用次数的字典。getfeatures为从即将被归类的内容项中提取出特征，在本例中就是我们定义过的getwords函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#增加对特征f、分类cat组合的计数值</span><br><span class="line">def incf(self,f,cat):</span><br><span class="line">    self.fc.setdefault(f,&#123;&#125;)</span><br><span class="line">    self.fc[f].setdefault(cat,0)</span><br><span class="line">    self.fc[f][cat]+&#x3D;1</span><br><span class="line">#增加对某一分类的计数值</span><br><span class="line">def incc(self,cat):</span><br><span class="line">    self.cc.setdefault(cat,0)</span><br><span class="line">    self.cc[cat]+&#x3D;1</span><br><span class="line">#某一特征出现在某一分类中的次数</span><br><span class="line">def fcount(self,f,cat):</span><br><span class="line">    if f in self.fc and cat in self.fc[f]:</span><br><span class="line">        return float(self.fc[f][cat])</span><br><span class="line">    return 0</span><br><span class="line">#属于某一分类的内容项</span><br><span class="line">def catcount(self,cat):</span><br><span class="line">    if cat in self.cc:</span><br><span class="line">        return float(self.cc[cat])</span><br><span class="line">    return 0</span><br><span class="line">#所有内容项</span><br><span class="line">def totalcount(self):</span><br><span class="line">    return sum(self.cc.values())</span><br><span class="line">#所有分类的列表</span><br><span class="line">def categories(self):</span><br><span class="line">    return self.cc.keys()</span><br></pre></td></tr></table></figure>
<p>Train方法接受一个内容项和一个分类作为参数。利用getfeatures函数，将内容项拆分为彼此独立的各个特征。利用incf函数，针对该分类为每个特征增加计数值。最后，函数会增加针对该分类的总计数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def train(self,item,cat):</span><br><span class="line">    features&#x3D;self.getfeatures(item)</span><br><span class="line">    #features为拆分出来的单词</span><br><span class="line">    for f in features:</span><br><span class="line">        self.incf(f,cat)</span><br><span class="line">    self.incc(cat)</span><br></pre></td></tr></table></figure>
<p>之前的代码放置在docclass.py中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import docclass</span><br><span class="line">c1&#x3D;docclass.classifier(docclass.getwords)</span><br><span class="line">c1.train(&#39;the quick brown fox jumps over the lazy dog&#39;,&#39;good&#39;)</span><br><span class="line">#代表上述单词分到good类</span><br><span class="line">c1.train(&#39;quick&#39;,&#39;good&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="计算概率"><a href="#计算概率" class="headerlink" title="计算概率"></a>计算概率</h3><p>可以用一个单词在一篇属于某个分类的文档中出现的次数，除以该分类的文档总数，计算出单词在分类中出现的概率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def fprob(self,f,cat):</span><br><span class="line">    if self.catcount(cat)&#x3D;&#x3D;0: return 0</span><br><span class="line">    return self.fcount(f,cat)&#x2F;self.catcount(cat)</span><br></pre></td></tr></table></figure>
<p>fprob概率为条件概率，pr(word|classification),即对于给定的分类某个单词出现的概率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.fprob(&#39;quick&#39;,&#39;good&#39;)</span><br></pre></td></tr></table></figure>
<p>表示一篇good分类的文档中包含该单词的概率为，pr(quick|good)=0.666</p>
<h4 id="从一个合理的推测开始"><a href="#从一个合理的推测开始" class="headerlink" title="从一个合理的推测开始"></a>从一个合理的推测开始</h4><p>上述的算法，对那些极少出现的单词异常敏感。对上述算法进行改进。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def weightedprob(self,f,cat,prf,weight&#x3D;1.0,ap&#x3D;0.5):</span><br><span class="line">    #计算当前概率值</span><br><span class="line">    basicprob&#x3D;prf(f,cat)</span><br><span class="line">    #统计特征在所有分类中出现的次数</span><br><span class="line">    totals&#x3D;sum([self.fcount(f,c) for f in self.categories()])</span><br><span class="line">    #计算加权平均</span><br><span class="line">    bp&#x3D;((weight*ap)+(totals*basicprob))&#x2F;(weight+totals)</span><br><span class="line">    return bp</span><br></pre></td></tr></table></figure>

<h3 id="朴素分类器"><a href="#朴素分类器" class="headerlink" title="朴素分类器"></a>朴素分类器</h3><p>朴素表示将要被组合的概率是彼此独立的。</p>
<h4 id="整片文档的概率"><a href="#整片文档的概率" class="headerlink" title="整片文档的概率"></a>整片文档的概率</h4><p>pr(python|bad)=0.2  </p>
<p>pr(casino|bad)=0.8    </p>
<p>pr(python&amp;casino|bad)=0.16</p>
<p>若计算整片文档，曾江文档中出现的特征概率相乘即可。如下算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#新建一个classifier的子类</span><br><span class="line">class naviebayes(classifier):</span><br><span class="line">      def docprob(self,item,cat):</span><br><span class="line">          features&#x3D;self.getfeatures(item)</span><br><span class="line">          #将所有特征概率相乘</span><br><span class="line">          p&#x3D;1</span><br><span class="line">          for f in features:p*&#x3D;self.weightedprob(f,cat,self,fprob)</span><br><span class="line">          return p</span><br></pre></td></tr></table></figure>

<p>目前我们已经知道如何计算pr(document|category),但我们需要给定一篇文档，它属于某个分类的概率是多少？<br>即pr(category|document),为此我们采用贝叶斯定理。</p>
<h4 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h4><p>pr(category|document)=pr(document|category)*pr(category)/pr(document)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def prob(self,item,cat):</span><br><span class="line">    catprob&#x3D;self.catcount(cat)&#x2F;self.totalcount()</span><br><span class="line">    docprob&#x3D;self.docprob(item,cat)</span><br><span class="line">    return catprob*docprob</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1.prob(&#39;quick rabbit&#39;,&#39;good&#39;)</span><br><span class="line">c1.prob(&#39;quick rabbit&#39;,&#39;bad&#39;)</span><br></pre></td></tr></table></figure>
<p>那个概率大，说明该短语更倾向于那个类。</p>
<h4 id="选择分类"><a href="#选择分类" class="headerlink" title="选择分类"></a>选择分类</h4><p>避免将普通邮件当做垃圾邮件。设定阈值。<br>假设过滤到bad的分类阈值为3，则针对bad分类的概率就必须至少3倍于针对good的概率才行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,getfeatures):</span><br><span class="line">    classifier.__init__(self,getfeatures)</span><br><span class="line">    self.thresholds&#x3D;&#123;&#125;</span><br><span class="line">def setthreshold(self,cat,t):</span><br><span class="line">    self.thresholds[cat]&#x3D;t</span><br><span class="line">def getthreshold(self,cat):</span><br><span class="line">    if cat not in self.thresholds: return 1</span><br><span class="line">    return self.thresholds[cat]</span><br></pre></td></tr></table></figure>
<p>将计算每个分类的概率，从中得到最大值，并将其余次大概率值进行对比，确定是否超过了阈值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def classify(self,item,default&#x3D;None):</span><br><span class="line">    probs&#x3D;&#123;&#125;</span><br><span class="line">    #寻找概率最大的分类</span><br><span class="line">    max&#x3D;0</span><br><span class="line">    for cat in self.categories():</span><br><span class="line">       probs[cat]&#x3D;self.prob(item,cat)</span><br><span class="line">       if probs[cat]&gt;max:</span><br><span class="line">          max&#x3D;probs[cat]</span><br><span class="line">          best&#x3D;cat</span><br><span class="line">    #确保概率值超过阈值*次概率值</span><br><span class="line">    for cat in probs:</span><br><span class="line">      if cat&#x3D;&#x3D;best:continue</span><br><span class="line">      if probs[cat]*self.getthreshold(best)&gt;probs[best]:return default</span><br><span class="line">    return best</span><br></pre></td></tr></table></figure>
<p>我们已经建立起一个完整的文档分类系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1.setthreshold(&#39;bad&#39;,3.0)</span><br><span class="line">c1.classify(&#39;quick money&#39;,default&#x3D;&#39;unknown&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="费舍尔方法"><a href="#费舍尔方法" class="headerlink" title="费舍尔方法"></a>费舍尔方法</h3><p>是前面介绍的朴素贝叶斯的一种替代方案</p>
<h3 id="将经过训练的分类器持久化"><a href="#将经过训练的分类器持久化" class="headerlink" title="将经过训练的分类器持久化"></a>将经过训练的分类器持久化</h3><p>本节中将classifier所用的字典，都替换成一个持久化的数据存储结构。请在classifier中添加一个方法，为该分类器打开数据库，执行建表操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pysqlite2 import dbapi2 as sqlite</span><br><span class="line">def setdb(self,dbfile):</span><br><span class="line">    self.con&#x3D;sqlite.connect(dbfile)</span><br><span class="line">    self.con.execute(&#39;create table if not exists fc(feature,category,count)&#39;)</span><br><span class="line">    self.con.execute(&#39;create table if not exists cc(category,count)&#39;)</span><br></pre></td></tr></table></figure>
<p>如果我们打算将分类器移植到另个数据库上，需要修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#增加对特征f、分类cat组合的计数值</span><br><span class="line">def incf(self,f,cat):</span><br><span class="line">    count&#x3D;self.fcount(f.cat)</span><br><span class="line">    if count&#x3D;&#x3D;0:</span><br><span class="line">       self.con.execute(&quot;insert into fc values(&#39;%s&#39;,&#39;%s&#39;,1)&quot; %(f,cat))</span><br><span class="line">    else:</span><br><span class="line">       self.con.execute(&quot;update fc set count&#x3D;&#39;%d&#39; where feature&#x3D;&#39;%s&#39; and category&#x3D;&#39;%s&#39;&quot;   %(count+1,f,cat))</span><br><span class="line">....</span><br></pre></td></tr></table></figure>


<p>获取所用分类的列表与文档总数的方法也被替换掉。<br>最后添加一条提交语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.con.commit()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.setdb(&#39;test1.db&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="过滤博客订阅源"><a href="#过滤博客订阅源" class="headerlink" title="过滤博客订阅源"></a>过滤博客订阅源</h3><p>我们只希望阅读某个分类的文章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import feedparser</span><br><span class="line">import re</span><br><span class="line">def read(feed,classifier):</span><br><span class="line">    f&#x3D;feedparser.parse(feed)</span><br><span class="line">    for entry in f[&#39;entries&#39;]:</span><br><span class="line">       print...</span><br><span class="line">       print &#39;guess: &#39;+str(classifier.classify(fulltext))</span><br><span class="line">       #请求用户给出正确分类，并据此进行训练</span><br><span class="line">       c1&#x3D;raw_input(&#39;enter category: &#39;)</span><br><span class="line">       classifier.train(fulltext,c1)</span><br></pre></td></tr></table></figure>
<p>略</p>
<h3 id="对特征检测的改进"><a href="#对特征检测的改进" class="headerlink" title="对特征检测的改进"></a>对特征检测的改进</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def entryfeatures(entry):</span><br><span class="line">    splitter.re.compile(&#39;\\W*&#39;)</span><br><span class="line">    f&#x3D;&#123;&#125;</span><br><span class="line">    titlewords&#x3D;[s.lower() for s in splitter.split(entry[&#39;title&#39;]) if len(s)&gt;2 and len(s)&lt;20]</span><br><span class="line">    for w in titlewords:f[&#39;title :&#39;+w]&#x3D;1</span><br><span class="line">    summarywords&#x3D;[s.lower() for s in splitter.split(entry[&#39;summary&#39;]) if len(s)&gt;2 and len(s)&lt;20]</span><br><span class="line">    #统计大写单词</span><br><span class="line">    uc&#x3D;0</span><br><span class="line">    for i in range(len(summarywords)):</span><br><span class="line">        w&#x3D;summarywords[i]</span><br><span class="line">        f[w]&#x3D;1</span><br><span class="line">        if w.isupper():uc+&#x3D;1</span><br><span class="line">        if i&lt;len(summarywords)-1:</span><br><span class="line">           twowords&#x3D;&#39; &#39;.join(summarywords[i:i+1])</span><br><span class="line">           f[twowords]&#x3D;1</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure>
<p>贝叶斯分类器经常被用于文档分类的原因是，它所要求的计算资源更少。但是神经网络和支持向量机有个很大的优势，可以捕捉输入特征之间更为复杂的关系。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ah</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ah</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
